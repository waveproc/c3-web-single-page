<!DOCTYPE html>
<!--

  Instructions:

  - Save this file.
  - Replace "c3lang" with your GitHub username.
  - Replace "c3c" with your GitHub repo name.
  - Replace "C3" with your project name.
  - Upload this file (or commit to GitHub Pages).

  Customize as you see fit!

-->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>C3</title>

  <!-- Flatdoc -->
  <script src="C3_files/jquery.min.js"></script>
  <script src="C3_files/legacy.js"></script>
  <script src="C3_files/flatdoc.js"></script>

  <!-- Flatdoc theme -->
  <link href="C3_files/style.css" rel="stylesheet">
  <script src="C3_files/script.js"></script>

  <!-- Meta -->
  <meta content="C3" property="og:title">
  <meta content="C3 description goes here." name="description">

  <!-- Initializer -->
  <script>
    const mdFiles = [
      "Getting Started/index.mdx",
      "Getting Started/design-goals.md",
      "Getting Started/roadmap.md",
      "Getting Started/prebuilt-binaries.md",
      "Getting Started/compile.md",
      "Getting Started/hello-world.md",
      "Getting Started/projects.mdx",
      "Get Involved/index.md",
      "Language Fundamentals/basic-types-and-values.md",
      "Language Fundamentals/comments.md",
      "Language Fundamentals/naming.md",
      "Language Fundamentals/variables.md",
      "Language Fundamentals/expressions.md",
      "Language Fundamentals/statements.md",
      "Language Fundamentals/functions.md",
      "Language Fundamentals/modules.md",
      "Language Overview/examples.md",
      "FAQ/changesfromc.md",
      "Language Overview/types.md",
      "Language Common/arrays.md",
      "Language Common/define.md",
      "Language Common/strings.md",
      "Language Common/vectors.md",
      "Language Common/optionals-essential.md",
      "Language Common/optionals-advanced.md",
      "Language Common/defer.md",
      "Language Common/contracts.md",
      "Language Common/attributes.md",
      "Language Common/cinterop.md",
      "Generic Programming/anyinterfaces.md",
      "Generic Programming/operator-overloading.md",
      "Generic Programming/generics.md",
      "Generic Programming/macros.md",
      "Generic Programming/compiletime.md",
      "Generic Programming/reflection.md",
      "Standard Library/index.mdx",
      "Standard Library/stdlib_refcard.md",
      "Language Rules/conversion.md",
      "Language Rules/precedence.md",
      "Language Rules/undefined-behaviour.md",
      "Misc Advanced/builtins.md",
      "Misc Advanced/library-packaging.md",
      "Misc Advanced/asm.md",
      "Build Your Project/build-commands.mdx",
      "Build Your Project/project-config.md",
      "FAQ/index.mdx",
      "FAQ/allfeatures.md",
      "FAQ/compare-languages.md",
      "FAQ/changesfromc.md",
      "FAQ/rejected-ideas.md",
      "Implementation Details/grammar.md",
      "Implementation Details/specification.md",
      "Thank You/index.mdx"
    ];
    Flatdoc.run({
      fetcher: Flatdoc.file(mdFiles),
    });
  </script>
</head>

<body role="flatdoc">

  <div class="header">
    <div class="left">
      <h1>C3</h1>
      <ul>
        <li><a href="https://github.com/c3lang/c3c">View on GitHub</a></li>
        <li><a href="https://github.com/c3lang/c3c/issues">Issues</a></li>
      </ul>
    </div>
    <div class="right">
      <!-- GitHub buttons: see https://ghbtns.com -->
      <iframe src="C3_files/github-btn.html" allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
    </div>
  </div>

  <div class="content-root">
    <div class="menubar">
      <div class="menu section" role="flatdoc-menu"><ul><li id="root-item" class="level-0"><ul class="level-1" id="root-list"><li id="root-item" class="level-1"><ul class="level-2" id="root-list"><li id="-order-1-item" class="level-2"><a id="-order-1-link" href="#-order-1" class="level-2 active">  order: 1</a></li></ul></li><li id="root-item" class="level-1"><ul class="level-2" id="root-list"><li id="-c3-programming-language-item" class="level-2"><a id="-c3-programming-language-link" href="#-c3-programming-language" class="level-2">C3 Programming Language</a><ul class="level-3" id="-c3-programming-language-list"><li id="-c3-programming-language-ergonomics-and-safety-item" class="level-3"><a id="-c3-programming-language-ergonomics-and-safety-link" href="#-c3-programming-language-ergonomics-and-safety" class="level-3">🦺 Ergonomics and Safety</a></li><li id="-c3-programming-language-performance-by-default-item" class="level-3"><a id="-c3-programming-language-performance-by-default-link" href="#-c3-programming-language-performance-by-default" class="level-3">⚡ Performance by default</a></li><li id="-c3-programming-language-batteries-included-standard-library-item" class="level-3"><a id="-c3-programming-language-batteries-included-standard-library-link" href="#-c3-programming-language-batteries-included-standard-library" class="level-3">🔋Batteries included standard library</a></li><li id="-c3-programming-language-leverage-existing-c-or-c-libraries-item" class="level-3"><a id="-c3-programming-language-leverage-existing-c-or-c-libraries-link" href="#-c3-programming-language-leverage-existing-c-or-c-libraries" class="level-3">🔧 Leverage existing C or C++ libraries</a></li><li id="-c3-programming-language-modules-are-simple-item" class="level-3"><a id="-c3-programming-language-modules-are-simple-link" href="#-c3-programming-language-modules-are-simple" class="level-3">📦 Modules are simple</a></li><li id="-c3-programming-language-macros-without-a-phd-item" class="level-3"><a id="-c3-programming-language-macros-without-a-phd-link" href="#-c3-programming-language-macros-without-a-phd" class="level-3">🎓 Macros without a PhD</a></li></ul></li></ul></li><li id="root-item" class="level-1"><ul class="level-2" id="root-list"><li id="-order-2-item" class="level-2"><a id="-order-2-link" href="#-order-2" class="level-2">  order: 2</a></li></ul></li><li id="root-item" class="level-1"><ul class="level-2" id="root-list"><li id="-design-goals-item" class="level-2"><a id="-design-goals-link" href="#-design-goals" class="level-2">Design goals</a></li></ul></li><li id="root-item" class="level-1"><ul class="level-2" id="root-list"><li id="-features-item" class="level-2"><a id="-features-link" href="#-features" class="level-2">Features</a></li></ul></li><li id="root-item" class="level-1"><ul class="level-2" id="root-list"><li id="-c3-background-item" class="level-2"><a id="-c3-background-link" href="#-c3-background" class="level-2">C3 Background</a></li></ul></li><li id="root-item" class="level-1"><ul class="level-2" id="root-list"><li id="-order-3-item" class="level-2"><a id="-order-3-link" href="#-order-3" class="level-2">  order: 3</a></li></ul></li><li id="root-item" class="level-1"><ul class="level-2" id="root-list"><li id="-c3-roadmap-item" class="level-2"><a id="-c3-roadmap-link" href="#-c3-roadmap" class="level-2">C3 Roadmap</a><ul class="level-3" id="-c3-roadmap-list"><li id="-c3-roadmap-c3-is-feature-stable-item" class="level-3"><a id="-c3-roadmap-c3-is-feature-stable-link" href="#-c3-roadmap-c3-is-feature-stable" class="level-3">C3 Is Feature Stable</a></li><li id="-c3-roadmap-compatibility-item" class="level-3"><a id="-c3-roadmap-compatibility-link" href="#-c3-roadmap-compatibility" class="level-3">Compatibility</a></li><li id="-c3-roadmap-standard-library-item" class="level-3"><a id="-c3-roadmap-standard-library-link" href="#-c3-roadmap-standard-library" class="level-3">Standard library</a></li></ul></li></ul></li><li id="root-item" class="level-1"><ul class="level-2" id="root-list"><li id="-order-20-item" class="level-2"><a id="-order-20-link" href="#-order-20" class="level-2">  order: 20</a></li></ul></li><li id="prebuilt-binaries-item" class="level-1"><a id="prebuilt-binaries-link" href="#prebuilt-binaries" class="level-1">Prebuilt binaries</a><ul class="level-2" id="prebuilt-binaries-list"><li id="prebuilt-binaries-installing-on-windows-item" class="level-2"><a id="prebuilt-binaries-installing-on-windows-link" href="#prebuilt-binaries-installing-on-windows" class="level-2">Installing on Windows</a><ul class="level-3" id="prebuilt-binaries-installing-on-windows-list"><li id="prebuilt-binaries-installing-on-windows-optional-set-c3c-as-a-global-environment-variable-item" class="level-3"><a id="prebuilt-binaries-installing-on-windows-optional-set-c3c-as-a-global-environment-variable-link" href="#prebuilt-binaries-installing-on-windows-optional-set-c3c-as-a-global-environment-variable" class="level-3">Optional: set c3c as a global environment variable</a></li></ul></li><li id="prebuilt-binaries-installing-on-mac-arm64-item" class="level-2"><a id="prebuilt-binaries-installing-on-mac-arm64-link" href="#prebuilt-binaries-installing-on-mac-arm64" class="level-2">Installing on Mac Arm64</a></li><li id="prebuilt-binaries-installing-on-ubuntu-item" class="level-2"><a id="prebuilt-binaries-installing-on-ubuntu-link" href="#prebuilt-binaries-installing-on-ubuntu" class="level-2">Installing on Ubuntu</a></li><li id="prebuilt-binaries-installing-on-debian-item" class="level-2"><a id="prebuilt-binaries-installing-on-debian-link" href="#prebuilt-binaries-installing-on-debian" class="level-2">Installing on Debian</a></li><li id="prebuilt-binaries-installing-on-arch-linux-item" class="level-2"><a id="prebuilt-binaries-installing-on-arch-linux-link" href="#prebuilt-binaries-installing-on-arch-linux" class="level-2">Installing on Arch Linux</a></li><li id="prebuilt-binaries-order-21-item" class="level-2"><a id="prebuilt-binaries-order-21-link" href="#prebuilt-binaries-order-21" class="level-2">  order: 21</a></li><li id="prebuilt-binaries-1-install-llvm-item" class="level-2"><a id="prebuilt-binaries-1-install-llvm-link" href="#prebuilt-binaries-1-install-llvm" class="level-2">1. Install LLVM</a></li><li id="prebuilt-binaries-2-clone-the-c3-compiler-source-code-from-github-item" class="level-2"><a id="prebuilt-binaries-2-clone-the-c3-compiler-source-code-from-github-link" href="#prebuilt-binaries-2-clone-the-c3-compiler-source-code-from-github" class="level-2">2. Clone the C3 compiler source code from Github</a></li><li id="prebuilt-binaries-3-build-the-compiler-item" class="level-2"><a id="prebuilt-binaries-3-build-the-compiler-link" href="#prebuilt-binaries-3-build-the-compiler" class="level-2">3. Build the compiler</a></li><li id="prebuilt-binaries-4-test-it-out-item" class="level-2"><a id="prebuilt-binaries-4-test-it-out-link" href="#prebuilt-binaries-4-test-it-out" class="level-2">4. Test it out</a></li></ul></li><li id="building-via-docker-item" class="level-1"><a id="building-via-docker-link" href="#building-via-docker" class="level-1">Building via Docker</a></li><li id="building-on-mac-using-homebrew-item" class="level-1"><a id="building-on-mac-using-homebrew-link" href="#building-on-mac-using-homebrew" class="level-1">Building on Mac using Homebrew</a></li><li id="building-on-mac-using-macports-item" class="level-1"><a id="building-on-mac-using-macports-link" href="#building-on-mac-using-macports" class="level-1">Building on Mac using MacPorts</a><ul class="level-2" id="building-on-mac-using-macports-list"><li id="building-on-mac-using-macports-order-30-item" class="level-2"><a id="building-on-mac-using-macports-order-30-link" href="#building-on-mac-using-macports-order-30" class="level-2">  order: 30</a></li><li id="building-on-mac-using-macports-hello-world-item" class="level-2"><a id="building-on-mac-using-macports-hello-world-link" href="#building-on-mac-using-macports-hello-world" class="level-2">👋 Hello world</a><ul class="level-3" id="building-on-mac-using-macports-hello-world-list"><li id="building-on-mac-using-macports-hello-world-function-scope-item" class="level-3"><a id="building-on-mac-using-macports-hello-world-function-scope-link" href="#building-on-mac-using-macports-hello-world-function-scope" class="level-3">🔭 Function scope</a></li><li id="building-on-mac-using-macports-hello-world-imports-can-use-a-shorthand-item" class="level-3"><a id="building-on-mac-using-macports-hello-world-imports-can-use-a-shorthand-link" href="#building-on-mac-using-macports-hello-world-imports-can-use-a-shorthand" class="level-3">📏 Imports can use a shorthand</a></li><li id="building-on-mac-using-macports-hello-world-compiling-and-running-item" class="level-3"><a id="building-on-mac-using-macports-hello-world-compiling-and-running-link" href="#building-on-mac-using-macports-hello-world-compiling-and-running" class="level-3">🏃 Compiling and running</a></li><li id="building-on-mac-using-macports-hello-world-successfully-working-item" class="level-3"><a id="building-on-mac-using-macports-hello-world-successfully-working-link" href="#building-on-mac-using-macports-hello-world-successfully-working" class="level-3">🎉 Successfully working?</a></li><li id="building-on-mac-using-macports-hello-world-need-help-item" class="level-3"><a id="building-on-mac-using-macports-hello-world-need-help-link" href="#building-on-mac-using-macports-hello-world-need-help" class="level-3">❓ Need help?</a></li></ul></li><li id="building-on-mac-using-macports-order-31-item" class="level-2"><a id="building-on-mac-using-macports-order-31-link" href="#building-on-mac-using-macports-order-31" class="level-2">  order: 31</a></li><li id="building-on-mac-using-macports-projects-in-c3-item" class="level-2"><a id="building-on-mac-using-macports-projects-in-c3-link" href="#building-on-mac-using-macports-projects-in-c3" class="level-2">Projects in C3</a><ul class="level-3" id="building-on-mac-using-macports-projects-in-c3-list"><li id="building-on-mac-using-macports-projects-in-c3-creating-a-new-project-item" class="level-3"><a id="building-on-mac-using-macports-projects-in-c3-creating-a-new-project-link" href="#building-on-mac-using-macports-projects-in-c3-creating-a-new-project" class="level-3">💡 Creating a new project</a></li><li id="building-on-mac-using-macports-projects-in-c3-project-structure-item" class="level-3"><a id="building-on-mac-using-macports-projects-in-c3-project-structure-link" href="#building-on-mac-using-macports-projects-in-c3-project-structure" class="level-3">📁 Project structure</a></li><li id="building-on-mac-using-macports-projects-in-c3-building-the-project-item" class="level-3"><a id="building-on-mac-using-macports-projects-in-c3-building-the-project-link" href="#building-on-mac-using-macports-projects-in-c3-building-the-project" class="level-3">🔧 Building the project</a></li></ul></li><li id="building-on-mac-using-macports-contributions-welcome-item" class="level-2"><a id="building-on-mac-using-macports-contributions-welcome-link" href="#building-on-mac-using-macports-contributions-welcome" class="level-2">Contributions Welcome!</a><ul class="level-3" id="building-on-mac-using-macports-contributions-welcome-list"><li id="building-on-mac-using-macports-contributions-welcome-discuss-the-language-item" class="level-3"><a id="building-on-mac-using-macports-contributions-welcome-discuss-the-language-link" href="#building-on-mac-using-macports-contributions-welcome-discuss-the-language" class="level-3">💬 Discuss The Language</a></li><li id="building-on-mac-using-macports-contributions-welcome-suggest-improvements-item" class="level-3"><a id="building-on-mac-using-macports-contributions-welcome-suggest-improvements-link" href="#building-on-mac-using-macports-contributions-welcome-suggest-improvements" class="level-3">💡 Suggest Improvements</a></li><li id="building-on-mac-using-macports-contributions-welcome-contribute-item" class="level-3"><a id="building-on-mac-using-macports-contributions-welcome-contribute-link" href="#building-on-mac-using-macports-contributions-welcome-contribute" class="level-3">💪 Contribute</a></li></ul></li><li id="building-on-mac-using-macports-order-33-item" class="level-2"><a id="building-on-mac-using-macports-order-33-link" href="#building-on-mac-using-macports-order-33" class="level-2">  order: 33</a></li><li id="building-on-mac-using-macports-integers-item" class="level-2"><a id="building-on-mac-using-macports-integers-link" href="#building-on-mac-using-macports-integers" class="level-2">Integers</a><ul class="level-3" id="building-on-mac-using-macports-integers-list"><li id="building-on-mac-using-macports-integers-integer-constants-item" class="level-3"><a id="building-on-mac-using-macports-integers-integer-constants-link" href="#building-on-mac-using-macports-integers-integer-constants" class="level-3">Integer constants</a></li><li id="building-on-mac-using-macports-integers-constant-suffixes-item" class="level-3"><a id="building-on-mac-using-macports-integers-constant-suffixes-link" href="#building-on-mac-using-macports-integers-constant-suffixes" class="level-3">Constant suffixes</a></li></ul></li><li id="building-on-mac-using-macports-booleans-item" class="level-2"><a id="building-on-mac-using-macports-booleans-link" href="#building-on-mac-using-macports-booleans" class="level-2">Booleans</a><ul class="level-3" id="building-on-mac-using-macports-booleans-list"><li id="building-on-mac-using-macports-booleans-character-literals-item" class="level-3"><a id="building-on-mac-using-macports-booleans-character-literals-link" href="#building-on-mac-using-macports-booleans-character-literals" class="level-3">Character literals</a></li></ul></li><li id="building-on-mac-using-macports-floating-point-types-item" class="level-2"><a id="building-on-mac-using-macports-floating-point-types-link" href="#building-on-mac-using-macports-floating-point-types" class="level-2">Floating point types</a><ul class="level-3" id="building-on-mac-using-macports-floating-point-types-list"><li id="building-on-mac-using-macports-floating-point-types-floating-point-constants-item" class="level-3"><a id="building-on-mac-using-macports-floating-point-types-floating-point-constants-link" href="#building-on-mac-using-macports-floating-point-types-floating-point-constants" class="level-3">Floating point constants</a></li></ul></li><li id="building-on-mac-using-macports-arrays-item" class="level-2"><a id="building-on-mac-using-macports-arrays-link" href="#building-on-mac-using-macports-arrays" class="level-2">Arrays</a></li><li id="building-on-mac-using-macports-slices-item" class="level-2"><a id="building-on-mac-using-macports-slices-link" href="#building-on-mac-using-macports-slices" class="level-2">Slices</a></li><li id="building-on-mac-using-macports-vectors-item" class="level-2"><a id="building-on-mac-using-macports-vectors-link" href="#building-on-mac-using-macports-vectors" class="level-2">Vectors</a></li><li id="building-on-mac-using-macports-string-literals-item" class="level-2"><a id="building-on-mac-using-macports-string-literals-link" href="#building-on-mac-using-macports-string-literals" class="level-2">String literals</a></li><li id="building-on-mac-using-macports-base64-and-hex-data-literals-item" class="level-2"><a id="building-on-mac-using-macports-base64-and-hex-data-literals-link" href="#building-on-mac-using-macports-base64-and-hex-data-literals" class="level-2">Base64 and hex data literals</a></li><li id="building-on-mac-using-macports-pointer-types-item" class="level-2"><a id="building-on-mac-using-macports-pointer-types-link" href="#building-on-mac-using-macports-pointer-types" class="level-2">Pointer types</a><ul class="level-3" id="building-on-mac-using-macports-pointer-types-list"><li id="building-on-mac-using-macports-pointer-types-void-item" class="level-3"><a id="building-on-mac-using-macports-pointer-types-void-link" href="#building-on-mac-using-macports-pointer-types-void" class="level-3">void*</a></li></ul></li><li id="building-on-mac-using-macports-printing-values-item" class="level-2"><a id="building-on-mac-using-macports-printing-values-link" href="#building-on-mac-using-macports-printing-values" class="level-2">Printing values</a></li><li id="building-on-mac-using-macports-doc-contracts-item" class="level-2"><a id="building-on-mac-using-macports-doc-contracts-link" href="#building-on-mac-using-macports-doc-contracts" class="level-2">Doc contracts</a><ul class="level-3" id="building-on-mac-using-macports-doc-contracts-list"><li id="building-on-mac-using-macports-doc-contracts-doc-contracts-are-parsed-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-doc-contracts-are-parsed-link" href="#building-on-mac-using-macports-doc-contracts-doc-contracts-are-parsed" class="level-3">Doc Contracts Are Parsed</a></li><li id="building-on-mac-using-macports-doc-contracts-available-annotations-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-available-annotations-link" href="#building-on-mac-using-macports-doc-contracts-available-annotations" class="level-3">Available annotations</a></li><li id="building-on-mac-using-macports-doc-contracts-structs-unions-enums-and-faults-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-structs-unions-enums-and-faults-link" href="#building-on-mac-using-macports-doc-contracts-structs-unions-enums-and-faults" class="level-3">Structs, unions, enums and faults</a></li><li id="building-on-mac-using-macports-doc-contracts-variables-and-parameters-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-variables-and-parameters-link" href="#building-on-mac-using-macports-doc-contracts-variables-and-parameters" class="level-3">Variables and parameters</a></li><li id="building-on-mac-using-macports-doc-contracts-global-constants-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-global-constants-link" href="#building-on-mac-using-macports-doc-contracts-global-constants" class="level-3">Global constants</a></li><li id="building-on-mac-using-macports-doc-contracts-enum-fault-values-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-enum-fault-values-link" href="#building-on-mac-using-macports-doc-contracts-enum-fault-values" class="level-3">Enum / Fault values</a></li><li id="building-on-mac-using-macports-doc-contracts-struct-union-members-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-struct-union-members-link" href="#building-on-mac-using-macports-doc-contracts-struct-union-members" class="level-3">Struct / union members</a></li><li id="building-on-mac-using-macports-doc-contracts-modules-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-modules-link" href="#building-on-mac-using-macports-doc-contracts-modules" class="level-3">Modules</a></li><li id="building-on-mac-using-macports-doc-contracts-functions-and-macros-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-functions-and-macros-link" href="#building-on-mac-using-macports-doc-contracts-functions-and-macros" class="level-3">Functions and macros</a></li><li id="building-on-mac-using-macports-doc-contracts-zero-init-by-default-item" class="level-3"><a id="building-on-mac-using-macports-doc-contracts-zero-init-by-default-link" href="#building-on-mac-using-macports-doc-contracts-zero-init-by-default" class="level-3">Zero init by default</a></li></ul></li><li id="building-on-mac-using-macports-well-defined-evaluation-order-item" class="level-2"><a id="building-on-mac-using-macports-well-defined-evaluation-order-link" href="#building-on-mac-using-macports-well-defined-evaluation-order" class="level-2">Well-defined evaluation order</a></li><li id="building-on-mac-using-macports-compound-literals-item" class="level-2"><a id="building-on-mac-using-macports-compound-literals-link" href="#building-on-mac-using-macports-compound-literals" class="level-2">Compound literals</a></li><li id="building-on-mac-using-macports-constant-expressions-item" class="level-2"><a id="building-on-mac-using-macports-constant-expressions-link" href="#building-on-mac-using-macports-constant-expressions" class="level-2">Constant expressions</a></li><li id="building-on-mac-using-macports-including-binary-data-item" class="level-2"><a id="building-on-mac-using-macports-including-binary-data-link" href="#building-on-mac-using-macports-including-binary-data" class="level-2">Including binary data</a></li><li id="building-on-mac-using-macports-expression-blocks-item" class="level-2"><a id="building-on-mac-using-macports-expression-blocks-link" href="#building-on-mac-using-macports-expression-blocks" class="level-2">Expression blocks</a></li><li id="building-on-mac-using-macports-labelled-break-and-continue-item" class="level-2"><a id="building-on-mac-using-macports-labelled-break-and-continue-link" href="#building-on-mac-using-macports-labelled-break-and-continue" class="level-2">Labelled break and continue</a></li><li id="building-on-mac-using-macports-do-without-while-item" class="level-2"><a id="building-on-mac-using-macports-do-without-while-link" href="#building-on-mac-using-macports-do-without-while" class="level-2">Do-without-while</a></li><li id="building-on-mac-using-macports-nextcase-and-labelled-nextcase-item" class="level-2"><a id="building-on-mac-using-macports-nextcase-and-labelled-nextcase-link" href="#building-on-mac-using-macports-nextcase-and-labelled-nextcase" class="level-2">Nextcase and labelled nextcase</a></li><li id="building-on-mac-using-macports-switch-cases-with-runtime-evaluation-item" class="level-2"><a id="building-on-mac-using-macports-switch-cases-with-runtime-evaluation-link" href="#building-on-mac-using-macports-switch-cases-with-runtime-evaluation" class="level-2">Switch cases with runtime evaluation</a></li><li id="building-on-mac-using-macports-regular-functions-item" class="level-2"><a id="building-on-mac-using-macports-regular-functions-link" href="#building-on-mac-using-macports-regular-functions" class="level-2">Regular functions</a><ul class="level-3" id="building-on-mac-using-macports-regular-functions-list"><li id="building-on-mac-using-macports-regular-functions-function-arguments-item" class="level-3"><a id="building-on-mac-using-macports-regular-functions-function-arguments-link" href="#building-on-mac-using-macports-regular-functions-function-arguments" class="level-3">Function arguments</a></li><li id="building-on-mac-using-macports-regular-functions-splat-item" class="level-3"><a id="building-on-mac-using-macports-regular-functions-splat-link" href="#building-on-mac-using-macports-regular-functions-splat" class="level-3">Splat</a></li><li id="building-on-mac-using-macports-regular-functions-named-arguments-and-varargs-item" class="level-3"><a id="building-on-mac-using-macports-regular-functions-named-arguments-and-varargs-link" href="#building-on-mac-using-macports-regular-functions-named-arguments-and-varargs" class="level-3">Named arguments and varargs</a></li><li id="building-on-mac-using-macports-regular-functions-functions-and-optional-returns-item" class="level-3"><a id="building-on-mac-using-macports-regular-functions-functions-and-optional-returns-link" href="#building-on-mac-using-macports-regular-functions-functions-and-optional-returns" class="level-3">Functions and Optional returns</a></li></ul></li><li id="building-on-mac-using-macports-methods-item" class="level-2"><a id="building-on-mac-using-macports-methods-link" href="#building-on-mac-using-macports-methods" class="level-2">Methods</a><ul class="level-3" id="building-on-mac-using-macports-methods-list"><li id="building-on-mac-using-macports-methods-implicit-first-parameters-item" class="level-3"><a id="building-on-mac-using-macports-methods-implicit-first-parameters-link" href="#building-on-mac-using-macports-methods-implicit-first-parameters" class="level-3">Implicit first parameters</a></li><li id="building-on-mac-using-macports-methods-restrictions-on-methods-item" class="level-3"><a id="building-on-mac-using-macports-methods-restrictions-on-methods-link" href="#building-on-mac-using-macports-methods-restrictions-on-methods" class="level-3">Restrictions on methods</a></li></ul></li><li id="building-on-mac-using-macports-contracts-item" class="level-2"><a id="building-on-mac-using-macports-contracts-link" href="#building-on-mac-using-macports-contracts" class="level-2">Contracts</a></li><li id="building-on-mac-using-macports-short-function-declaration-syntax-item" class="level-2"><a id="building-on-mac-using-macports-short-function-declaration-syntax-link" href="#building-on-mac-using-macports-short-function-declaration-syntax" class="level-2">Short function declaration syntax</a></li><li id="building-on-mac-using-macports-lambdas-item" class="level-2"><a id="building-on-mac-using-macports-lambdas-link" href="#building-on-mac-using-macports-lambdas" class="level-2">Lambdas</a></li><li id="building-on-mac-using-macports-static-initializer-and-finalizers-item" class="level-2"><a id="building-on-mac-using-macports-static-initializer-and-finalizers-link" href="#building-on-mac-using-macports-static-initializer-and-finalizers" class="level-2">Static initializer and finalizers</a><ul class="level-3" id="building-on-mac-using-macports-static-initializer-and-finalizers-list"><li id="building-on-mac-using-macports-static-initializer-and-finalizers-changing-priority-of-static-initializers-and-finalizers-item" class="level-3"><a id="building-on-mac-using-macports-static-initializer-and-finalizers-changing-priority-of-static-initializers-and-finalizers-link" href="#building-on-mac-using-macports-static-initializer-and-finalizers-changing-priority-of-static-initializers-and-finalizers" class="level-3">Changing priority of static initializers and finalizers</a></li></ul></li><li id="building-on-mac-using-macports-details-item" class="level-2"><a id="building-on-mac-using-macports-details-link" href="#building-on-mac-using-macports-details" class="level-2">Details</a></li><li id="building-on-mac-using-macports-importing-modules-item" class="level-2"><a id="building-on-mac-using-macports-importing-modules-link" href="#building-on-mac-using-macports-importing-modules" class="level-2">Importing Modules</a></li><li id="building-on-mac-using-macports-implicit-imports-item" class="level-2"><a id="building-on-mac-using-macports-implicit-imports-link" href="#building-on-mac-using-macports-implicit-imports" class="level-2">Implicit Imports</a></li><li id="building-on-mac-using-macports-visibility-item" class="level-2"><a id="building-on-mac-using-macports-visibility-link" href="#building-on-mac-using-macports-visibility" class="level-2">Visibility</a></li><li id="building-on-mac-using-macports-overriding-symbol-visibility-rules-item" class="level-2"><a id="building-on-mac-using-macports-overriding-symbol-visibility-rules-link" href="#building-on-mac-using-macports-overriding-symbol-visibility-rules" class="level-2">Overriding Symbol Visibility Rules</a></li><li id="building-on-mac-using-macports-changing-the-default-visibility-item" class="level-2"><a id="building-on-mac-using-macports-changing-the-default-visibility-link" href="#building-on-mac-using-macports-changing-the-default-visibility" class="level-2">Changing The Default Visibility</a></li><li id="building-on-mac-using-macports-linker-visibility-and-exports-item" class="level-2"><a id="building-on-mac-using-macports-linker-visibility-and-exports-link" href="#building-on-mac-using-macports-linker-visibility-and-exports" class="level-2">Linker Visibility and Exports</a></li><li id="building-on-mac-using-macports-using-functions-and-types-from-other-modules-item" class="level-2"><a id="building-on-mac-using-macports-using-functions-and-types-from-other-modules-link" href="#building-on-mac-using-macports-using-functions-and-types-from-other-modules" class="level-2">Using Functions and Types From Other Modules</a></li><li id="building-on-mac-using-macports-module-sections-item" class="level-2"><a id="building-on-mac-using-macports-module-sections-link" href="#building-on-mac-using-macports-module-sections" class="level-2">Module Sections</a></li><li id="building-on-mac-using-macports-versioning-and-dynamic-inclusion-item" class="level-2"><a id="building-on-mac-using-macports-versioning-and-dynamic-inclusion-link" href="#building-on-mac-using-macports-versioning-and-dynamic-inclusion" class="level-2">Versioning and Dynamic Inclusion</a></li><li id="building-on-mac-using-macports-textual-includes-item" class="level-2"><a id="building-on-mac-using-macports-textual-includes-link" href="#building-on-mac-using-macports-textual-includes" class="level-2">Textual Includes</a><ul class="level-3" id="building-on-mac-using-macports-textual-includes-list"><li id="building-on-mac-using-macports-textual-includes-include-item" class="level-3"><a id="building-on-mac-using-macports-textual-includes-include-link" href="#building-on-mac-using-macports-textual-includes-include" class="level-3">$include</a></li><li id="building-on-mac-using-macports-textual-includes-exec-item" class="level-3"><a id="building-on-mac-using-macports-textual-includes-exec-link" href="#building-on-mac-using-macports-textual-includes-exec" class="level-3">$exec</a></li></ul></li><li id="building-on-mac-using-macports-non-recursive-imports-item" class="level-2"><a id="building-on-mac-using-macports-non-recursive-imports-link" href="#building-on-mac-using-macports-non-recursive-imports" class="level-2">Non-Recursive Imports</a></li><li id="building-on-mac-using-macports-overview-item" class="level-2"><a id="building-on-mac-using-macports-overview-link" href="#building-on-mac-using-macports-overview" class="level-2">Overview</a></li><li id="building-on-mac-using-macports-if-statement-item" class="level-2"><a id="building-on-mac-using-macports-if-statement-link" href="#building-on-mac-using-macports-if-statement" class="level-2">If Statement</a></li><li id="building-on-mac-using-macports-for-loop-item" class="level-2"><a id="building-on-mac-using-macports-for-loop-link" href="#building-on-mac-using-macports-for-loop" class="level-2">For Loop</a></li><li id="building-on-mac-using-macports-foreach-loop-item" class="level-2"><a id="building-on-mac-using-macports-foreach-loop-link" href="#building-on-mac-using-macports-foreach-loop" class="level-2">Foreach Loop</a></li><li id="building-on-mac-using-macports-while-loop-item" class="level-2"><a id="building-on-mac-using-macports-while-loop-link" href="#building-on-mac-using-macports-while-loop" class="level-2">While Loop</a></li><li id="building-on-mac-using-macports-enum-and-switch-item" class="level-2"><a id="building-on-mac-using-macports-enum-and-switch-link" href="#building-on-mac-using-macports-enum-and-switch" class="level-2">Enum And Switch</a></li><li id="building-on-mac-using-macports-defer-item" class="level-2"><a id="building-on-mac-using-macports-defer-link" href="#building-on-mac-using-macports-defer" class="level-2">Defer</a></li><li id="building-on-mac-using-macports-struct-types-item" class="level-2"><a id="building-on-mac-using-macports-struct-types-link" href="#building-on-mac-using-macports-struct-types" class="level-2">Struct Types</a></li><li id="building-on-mac-using-macports-function-pointers-item" class="level-2"><a id="building-on-mac-using-macports-function-pointers-link" href="#building-on-mac-using-macports-function-pointers" class="level-2">Function Pointers</a></li><li id="building-on-mac-using-macports-error-handling-item" class="level-2"><a id="building-on-mac-using-macports-error-handling-link" href="#building-on-mac-using-macports-error-handling" class="level-2">Error Handling</a></li><li id="building-on-mac-using-macports-contracts-item" class="level-2"><a id="building-on-mac-using-macports-contracts-link" href="#building-on-mac-using-macports-contracts" class="level-2">Contracts</a></li><li id="building-on-mac-using-macports-struct-methods-item" class="level-2"><a id="building-on-mac-using-macports-struct-methods-link" href="#building-on-mac-using-macports-struct-methods" class="level-2">Struct Methods</a></li><li id="building-on-mac-using-macports-macros-item" class="level-2"><a id="building-on-mac-using-macports-macros-link" href="#building-on-mac-using-macports-macros" class="level-2">Macros</a><ul class="level-3" id="building-on-mac-using-macports-macros-list"><li id="building-on-mac-using-macports-macros-compile-time-reflection-execution-item" class="level-3"><a id="building-on-mac-using-macports-macros-compile-time-reflection-execution-link" href="#building-on-mac-using-macports-macros-compile-time-reflection-execution" class="level-3">Compile Time Reflection &amp; Execution</a></li><li id="building-on-mac-using-macports-macros-compile-time-execution-item" class="level-3"><a id="building-on-mac-using-macports-macros-compile-time-execution-link" href="#building-on-mac-using-macports-macros-compile-time-execution" class="level-3">Compile Time Execution</a></li></ul></li><li id="building-on-mac-using-macports-generic-modules-item" class="level-2"><a id="building-on-mac-using-macports-generic-modules-link" href="#building-on-mac-using-macports-generic-modules" class="level-2">Generic Modules</a></li><li id="building-on-mac-using-macports-dynamic-calls-item" class="level-2"><a id="building-on-mac-using-macports-dynamic-calls-link" href="#building-on-mac-using-macports-dynamic-calls" class="level-2">Dynamic Calls</a></li><li id="building-on-mac-using-macports-overview-item" class="level-2"><a id="building-on-mac-using-macports-overview-link" href="#building-on-mac-using-macports-overview" class="level-2">Overview</a></li><li id="building-on-mac-using-macports-basic-types-item" class="level-2"><a id="building-on-mac-using-macports-basic-types-link" href="#building-on-mac-using-macports-basic-types" class="level-2">Basic types</a><ul class="level-3" id="building-on-mac-using-macports-basic-types-list"><li id="building-on-mac-using-macports-basic-types-c-compatibility-item" class="level-3"><a id="building-on-mac-using-macports-basic-types-c-compatibility-link" href="#building-on-mac-using-macports-basic-types-c-compatibility" class="level-3">C compatibility</a></li></ul></li><li id="building-on-mac-using-macports-other-built-in-types-item" class="level-2"><a id="building-on-mac-using-macports-other-built-in-types-link" href="#building-on-mac-using-macports-other-built-in-types" class="level-2">Other built-in types</a><ul class="level-3" id="building-on-mac-using-macports-other-built-in-types-list"><li id="building-on-mac-using-macports-other-built-in-types-pointer-types-item" class="level-3"><a id="building-on-mac-using-macports-other-built-in-types-pointer-types-link" href="#building-on-mac-using-macports-other-built-in-types-pointer-types" class="level-3">Pointer types</a></li><li id="building-on-mac-using-macports-other-built-in-types-the-typeid-type-item" class="level-3"><a id="building-on-mac-using-macports-other-built-in-types-the-typeid-type-link" href="#building-on-mac-using-macports-other-built-in-types-the-typeid-type" class="level-3">The typeid type</a></li><li id="building-on-mac-using-macports-other-built-in-types-the-any-type-item" class="level-3"><a id="building-on-mac-using-macports-other-built-in-types-the-any-type-link" href="#building-on-mac-using-macports-other-built-in-types-the-any-type" class="level-3">The any type</a></li><li id="building-on-mac-using-macports-other-built-in-types-array-types-item" class="level-3"><a id="building-on-mac-using-macports-other-built-in-types-array-types-link" href="#building-on-mac-using-macports-other-built-in-types-array-types" class="level-3">Array types</a></li><li id="building-on-mac-using-macports-other-built-in-types-vector-types-item" class="level-3"><a id="building-on-mac-using-macports-other-built-in-types-vector-types-link" href="#building-on-mac-using-macports-other-built-in-types-vector-types" class="level-3">Vector types</a></li></ul></li><li id="building-on-mac-using-macports-types-created-using-def-item" class="level-2"><a id="building-on-mac-using-macports-types-created-using-def-link" href="#building-on-mac-using-macports-types-created-using-def" class="level-2">Types created using def</a><ul class="level-3" id="building-on-mac-using-macports-types-created-using-def-list"><li id="building-on-mac-using-macports-types-created-using-def-typedef-item" class="level-3"><a id="building-on-mac-using-macports-types-created-using-def-typedef-link" href="#building-on-mac-using-macports-types-created-using-def-typedef" class="level-3">“typedef”</a></li><li id="building-on-mac-using-macports-types-created-using-def-function-pointer-types-item" class="level-3"><a id="building-on-mac-using-macports-types-created-using-def-function-pointer-types-link" href="#building-on-mac-using-macports-types-created-using-def-function-pointer-types" class="level-3">Function pointer types</a></li><li id="building-on-mac-using-macports-types-created-using-def-distinct-types-item" class="level-3"><a id="building-on-mac-using-macports-types-created-using-def-distinct-types-link" href="#building-on-mac-using-macports-types-created-using-def-distinct-types" class="level-3">Distinct types</a></li><li id="building-on-mac-using-macports-types-created-using-def-generic-types-item" class="level-3"><a id="building-on-mac-using-macports-types-created-using-def-generic-types-link" href="#building-on-mac-using-macports-types-created-using-def-generic-types" class="level-3">Generic types</a></li></ul></li><li id="building-on-mac-using-macports-enum-item" class="level-2"><a id="building-on-mac-using-macports-enum-link" href="#building-on-mac-using-macports-enum" class="level-2">Enum</a><ul class="level-3" id="building-on-mac-using-macports-enum-list"><li id="building-on-mac-using-macports-enum-enum-associated-values-item" class="level-3"><a id="building-on-mac-using-macports-enum-enum-associated-values-link" href="#building-on-mac-using-macports-enum-enum-associated-values" class="level-3">Enum associated values</a></li><li id="building-on-mac-using-macports-enum-enum-type-inference-item" class="level-3"><a id="building-on-mac-using-macports-enum-enum-type-inference-link" href="#building-on-mac-using-macports-enum-enum-type-inference" class="level-3">Enum type inference</a></li></ul></li><li id="building-on-mac-using-macports-optional-type-item" class="level-2"><a id="building-on-mac-using-macports-optional-type-link" href="#building-on-mac-using-macports-optional-type" class="level-2">Optional Type</a><ul class="level-3" id="building-on-mac-using-macports-optional-type-list"><li id="building-on-mac-using-macports-optional-type-optional-excuses-are-of-type-fault-item" class="level-3"><a id="building-on-mac-using-macports-optional-type-optional-excuses-are-of-type-fault-link" href="#building-on-mac-using-macports-optional-type-optional-excuses-are-of-type-fault" class="level-3">Optional Excuses are of type Fault</a></li></ul></li><li id="building-on-mac-using-macports-struct-types-item" class="level-2"><a id="building-on-mac-using-macports-struct-types-link" href="#building-on-mac-using-macports-struct-types" class="level-2">Struct types</a></li><li id="building-on-mac-using-macports-struct-subtyping-item" class="level-2"><a id="building-on-mac-using-macports-struct-subtyping-link" href="#building-on-mac-using-macports-struct-subtyping" class="level-2">Struct subtyping</a></li><li id="building-on-mac-using-macports-union-types-item" class="level-2"><a id="building-on-mac-using-macports-union-types-link" href="#building-on-mac-using-macports-union-types" class="level-2">Union types</a></li><li id="building-on-mac-using-macports-nested-sub-structs-unions-item" class="level-2"><a id="building-on-mac-using-macports-nested-sub-structs-unions-link" href="#building-on-mac-using-macports-nested-sub-structs-unions" class="level-2">Nested sub-structs / unions</a></li><li id="building-on-mac-using-macports-bitstructs-item" class="level-2"><a id="building-on-mac-using-macports-bitstructs-link" href="#building-on-mac-using-macports-bitstructs" class="level-2">Bitstructs</a></li><li id="building-on-mac-using-macports-fixed-size-1d-arrays-item" class="level-2"><a id="building-on-mac-using-macports-fixed-size-1d-arrays-link" href="#building-on-mac-using-macports-fixed-size-1d-arrays" class="level-2">Fixed Size 1D Arrays</a></li><li id="building-on-mac-using-macports-slice-item" class="level-2"><a id="building-on-mac-using-macports-slice-link" href="#building-on-mac-using-macports-slice" class="level-2">Slice</a><ul class="level-3" id="building-on-mac-using-macports-slice-list"><li id="building-on-mac-using-macports-slice-slicing-arrays-item" class="level-3"><a id="building-on-mac-using-macports-slice-slicing-arrays-link" href="#building-on-mac-using-macports-slice-slicing-arrays" class="level-3">Slicing Arrays</a></li><li id="building-on-mac-using-macports-slice-conversion-list-item" class="level-3"><a id="building-on-mac-using-macports-slice-conversion-list-link" href="#building-on-mac-using-macports-slice-conversion-list" class="level-3">Conversion List</a></li></ul></li><li id="building-on-mac-using-macports-iteration-over-arrays-item" class="level-2"><a id="building-on-mac-using-macports-iteration-over-arrays-link" href="#building-on-mac-using-macports-iteration-over-arrays" class="level-2">Iteration Over Arrays</a><ul class="level-3" id="building-on-mac-using-macports-iteration-over-arrays-list"><li id="building-on-mac-using-macports-iteration-over-arrays-foreach-element-by-copy-item" class="level-3"><a id="building-on-mac-using-macports-iteration-over-arrays-foreach-element-by-copy-link" href="#building-on-mac-using-macports-iteration-over-arrays-foreach-element-by-copy" class="level-3">Foreach element by copy</a></li><li id="building-on-mac-using-macports-iteration-over-arrays-foreach-element-by-reference-item" class="level-3"><a id="building-on-mac-using-macports-iteration-over-arrays-foreach-element-by-reference-link" href="#building-on-mac-using-macports-iteration-over-arrays-foreach-element-by-reference" class="level-3">Foreach element by reference</a></li><li id="building-on-mac-using-macports-iteration-over-arrays-foreach_r-reverse-iterating-item" class="level-3"><a id="building-on-mac-using-macports-iteration-over-arrays-foreach_r-reverse-iterating-link" href="#building-on-mac-using-macports-iteration-over-arrays-foreach_r-reverse-iterating" class="level-3">Foreach_r reverse iterating</a></li></ul></li><li id="building-on-mac-using-macports-iteration-over-array-like-types-item" class="level-2"><a id="building-on-mac-using-macports-iteration-over-array-like-types-link" href="#building-on-mac-using-macports-iteration-over-array-like-types" class="level-2">Iteration Over Array-Like types</a></li><li id="building-on-mac-using-macports-dynamic-arrays-and-lists-item" class="level-2"><a id="building-on-mac-using-macports-dynamic-arrays-and-lists-link" href="#building-on-mac-using-macports-dynamic-arrays-and-lists" class="level-2">Dynamic Arrays and Lists</a></li><li id="building-on-mac-using-macports-fixed-size-multi-dimensional-arrays-item" class="level-2"><a id="building-on-mac-using-macports-fixed-size-multi-dimensional-arrays-link" href="#building-on-mac-using-macports-fixed-size-multi-dimensional-arrays" class="level-2">Fixed Size Multi-Dimensional Arrays</a></li></ul></li><li id="the-def-statement-item" class="level-1"><a id="the-def-statement-link" href="#the-def-statement" class="level-1">The “def” statement</a><ul class="level-2" id="the-def-statement-list"><li id="the-def-statement-defining-a-type-alias-item" class="level-2"><a id="the-def-statement-defining-a-type-alias-link" href="#the-def-statement-defining-a-type-alias" class="level-2">Defining a type alias</a></li><li id="the-def-statement-distinct-types-item" class="level-2"><a id="the-def-statement-distinct-types-link" href="#the-def-statement-distinct-types" class="level-2">Distinct types</a></li><li id="the-def-statement-distinct-inline-item" class="level-2"><a id="the-def-statement-distinct-inline-link" href="#the-def-statement-distinct-inline" class="level-2">Distinct inline</a></li><li id="the-def-statement-function-and-variable-aliases-item" class="level-2"><a id="the-def-statement-function-and-variable-aliases-link" href="#the-def-statement-function-and-variable-aliases" class="level-2">Function and variable aliases</a></li><li id="the-def-statement-using-def-to-create-generic-types-functions-and-variables-item" class="level-2"><a id="the-def-statement-using-def-to-create-generic-types-functions-and-variables-link" href="#the-def-statement-using-def-to-create-generic-types-functions-and-variables" class="level-2">Using def to create generic types, functions and variables</a></li><li id="the-def-statement-function-pointer-default-arguments-and-named-parameters-item" class="level-2"><a id="the-def-statement-function-pointer-default-arguments-and-named-parameters-link" href="#the-def-statement-function-pointer-default-arguments-and-named-parameters" class="level-2">Function pointer default arguments and named parameters</a><ul class="level-3" id="the-def-statement-function-pointer-default-arguments-and-named-parameters-list"><li id="the-def-statement-function-pointer-default-arguments-and-named-parameters-string-item" class="level-3"><a id="the-def-statement-function-pointer-default-arguments-and-named-parameters-string-link" href="#the-def-statement-function-pointer-default-arguments-and-named-parameters-string" class="level-3">String</a></li><li id="the-def-statement-function-pointer-default-arguments-and-named-parameters-zstring-item" class="level-3"><a id="the-def-statement-function-pointer-default-arguments-and-named-parameters-zstring-link" href="#the-def-statement-function-pointer-default-arguments-and-named-parameters-zstring" class="level-3">ZString</a></li></ul></li><li id="the-def-statement-member-functions-item" class="level-2"><a id="the-def-statement-member-functions-link" href="#the-def-statement-member-functions" class="level-2">Member functions:</a><ul class="level-3" id="the-def-statement-member-functions-list"><li id="the-def-statement-member-functions-string-member-functions-item" class="level-3"><a id="the-def-statement-member-functions-string-member-functions-link" href="#the-def-statement-member-functions-string-member-functions" class="level-3">String Member Functions</a></li><li id="the-def-statement-member-functions-zstring-member-functions-item" class="level-3"><a id="the-def-statement-member-functions-zstring-member-functions-link" href="#the-def-statement-member-functions-zstring-member-functions" class="level-3">ZString Member Functions</a></li><li id="the-def-statement-member-functions-scalar-values-item" class="level-3"><a id="the-def-statement-member-functions-scalar-values-link" href="#the-def-statement-member-functions-scalar-values" class="level-3">Scalar values</a></li></ul></li><li id="the-def-statement-additional-operations-item" class="level-2"><a id="the-def-statement-additional-operations-link" href="#the-def-statement-additional-operations" class="level-2">Additional operations</a></li><li id="the-def-statement-swizzling-item" class="level-2"><a id="the-def-statement-swizzling-link" href="#the-def-statement-swizzling" class="level-2">Swizzling</a></li><li id="the-def-statement-array-like-operations-item" class="level-2"><a id="the-def-statement-array-like-operations-link" href="#the-def-statement-array-like-operations" class="level-2">Array-like operations</a></li><li id="the-def-statement-what-is-an-optional-item" class="level-2"><a id="the-def-statement-what-is-an-optional-link" href="#the-def-statement-what-is-an-optional" class="level-2">What is an Optional?</a></li><li id="the-def-statement-unwrapping-an-optional-item" class="level-2"><a id="the-def-statement-unwrapping-an-optional-link" href="#the-def-statement-unwrapping-an-optional" class="level-2">🎁 Unwrapping an Optional</a></li><li id="the-def-statement-checking-if-an-optional-is-empty-item" class="level-2"><a id="the-def-statement-checking-if-an-optional-is-empty-link" href="#the-def-statement-checking-if-an-optional-is-empty" class="level-2">Checking if an Optional is empty</a><ul class="level-3" id="the-def-statement-checking-if-an-optional-is-empty-list"><li id="the-def-statement-checking-if-an-optional-is-empty-automatically-unwrapping-an-optional-result-item" class="level-3"><a id="the-def-statement-checking-if-an-optional-is-empty-automatically-unwrapping-an-optional-result-link" href="#the-def-statement-checking-if-an-optional-is-empty-automatically-unwrapping-an-optional-result" class="level-3">Automatically unwrapping an Optional result</a></li><li id="the-def-statement-checking-if-an-optional-is-empty-using-the-rethrow-operator-to-unwrap-an-optional-value-item" class="level-3"><a id="the-def-statement-checking-if-an-optional-is-empty-using-the-rethrow-operator-to-unwrap-an-optional-value-link" href="#the-def-statement-checking-if-an-optional-is-empty-using-the-rethrow-operator-to-unwrap-an-optional-value" class="level-3">Using the Rethrow operator ! to unwrap an Optional value</a></li></ul></li><li id="the-def-statement-optionals-affect-types-and-control-flow-item" class="level-2"><a id="the-def-statement-optionals-affect-types-and-control-flow-link" href="#the-def-statement-optionals-affect-types-and-control-flow" class="level-2">⚠️ Optionals affect types and control flow</a><ul class="level-3" id="the-def-statement-optionals-affect-types-and-control-flow-list"><li id="the-def-statement-optionals-affect-types-and-control-flow-optionals-in-expressions-produce-optionals-item" class="level-3"><a id="the-def-statement-optionals-affect-types-and-control-flow-optionals-in-expressions-produce-optionals-link" href="#the-def-statement-optionals-affect-types-and-control-flow-optionals-in-expressions-produce-optionals" class="level-3">Optionals in expressions produce Optionals</a></li><li id="the-def-statement-optionals-affect-types-and-control-flow-optionals-affect-function-return-types-item" class="level-3"><a id="the-def-statement-optionals-affect-types-and-control-flow-optionals-affect-function-return-types-link" href="#the-def-statement-optionals-affect-types-and-control-flow-optionals-affect-function-return-types" class="level-3">Optionals affect function return types</a></li><li id="the-def-statement-optionals-affect-types-and-control-flow-functions-conditionally-run-when-called-with-optional-arguments-item" class="level-3"><a id="the-def-statement-optionals-affect-types-and-control-flow-functions-conditionally-run-when-called-with-optional-arguments-link" href="#the-def-statement-optionals-affect-types-and-control-flow-functions-conditionally-run-when-called-with-optional-arguments" class="level-3">Functions conditionally run when called with Optional arguments</a></li></ul></li><li id="the-def-statement-interfacing-with-c-item" class="level-2"><a id="the-def-statement-interfacing-with-c-link" href="#the-def-statement-interfacing-with-c" class="level-2">Interfacing with C</a><ul class="level-3" id="the-def-statement-interfacing-with-c-list"><li id="the-def-statement-interfacing-with-c-optionals-are-only-defined-in-certain-code-item" class="level-3"><a id="the-def-statement-interfacing-with-c-optionals-are-only-defined-in-certain-code-link" href="#the-def-statement-interfacing-with-c-optionals-are-only-defined-in-certain-code" class="level-3">Optionals are only defined in certain code</a></li></ul></li><li id="the-def-statement-handling-an-empty-optional-item" class="level-2"><a id="the-def-statement-handling-an-empty-optional-link" href="#the-def-statement-handling-an-empty-optional" class="level-2">Handling an empty Optional</a><ul class="level-3" id="the-def-statement-handling-an-empty-optional-list"><li id="the-def-statement-handling-an-empty-optional-file-reading-example-item" class="level-3"><a id="the-def-statement-handling-an-empty-optional-file-reading-example-link" href="#the-def-statement-handling-an-empty-optional-file-reading-example" class="level-3">File reading example</a></li><li id="the-def-statement-handling-an-empty-optional-return-a-default-value-if-optional-is-empty-item" class="level-3"><a id="the-def-statement-handling-an-empty-optional-return-a-default-value-if-optional-is-empty-link" href="#the-def-statement-handling-an-empty-optional-return-a-default-value-if-optional-is-empty" class="level-3">Return a default value if Optional is empty</a></li><li id="the-def-statement-handling-an-empty-optional-force-unwrapping-expressions-item" class="level-3"><a id="the-def-statement-handling-an-empty-optional-force-unwrapping-expressions-link" href="#the-def-statement-handling-an-empty-optional-force-unwrapping-expressions" class="level-3">Force unwrapping expressions</a></li><li id="the-def-statement-handling-an-empty-optional-find-empty-optional-without-reading-the-excuse-item" class="level-3"><a id="the-def-statement-handling-an-empty-optional-find-empty-optional-without-reading-the-excuse-link" href="#the-def-statement-handling-an-empty-optional-find-empty-optional-without-reading-the-excuse" class="level-3">Find empty Optional without reading the Excuse</a></li><li id="the-def-statement-handling-an-empty-optional-find-empty-optional-and-switch-on-excuse-item" class="level-3"><a id="the-def-statement-handling-an-empty-optional-find-empty-optional-and-switch-on-excuse-link" href="#the-def-statement-handling-an-empty-optional-find-empty-optional-and-switch-on-excuse" class="level-3">Find empty Optional and switch on Excuse</a></li></ul></li><li id="the-def-statement-run-code-if-the-optional-has-a-result-item" class="level-2"><a id="the-def-statement-run-code-if-the-optional-has-a-result-link" href="#the-def-statement-run-code-if-the-optional-has-a-result" class="level-2">Run code if the Optional has a result</a></li><li id="the-def-statement-shorthands-to-work-with-optionals-item" class="level-2"><a id="the-def-statement-shorthands-to-work-with-optionals-link" href="#the-def-statement-shorthands-to-work-with-optionals" class="level-2">Shorthands to work with Optionals</a><ul class="level-3" id="the-def-statement-shorthands-to-work-with-optionals-list"><li id="the-def-statement-shorthands-to-work-with-optionals-getting-the-excuse-item" class="level-3"><a id="the-def-statement-shorthands-to-work-with-optionals-getting-the-excuse-link" href="#the-def-statement-shorthands-to-work-with-optionals-getting-the-excuse" class="level-3">Getting the Excuse</a></li><li id="the-def-statement-shorthands-to-work-with-optionals-checking-if-an-optional-has-a-result-without-unwrapping-item" class="level-3"><a id="the-def-statement-shorthands-to-work-with-optionals-checking-if-an-optional-has-a-result-without-unwrapping-link" href="#the-def-statement-shorthands-to-work-with-optionals-checking-if-an-optional-has-a-result-without-unwrapping" class="level-3">Checking if an Optional has a result without unwrapping</a></li></ul></li><li id="the-def-statement-no-void-variables-item" class="level-2"><a id="the-def-statement-no-void-variables-link" href="#the-def-statement-no-void-variables" class="level-2">No void! variables</a></li></ul></li><li id="defer-item" class="level-1"><a id="defer-link" href="#defer" class="level-1">Defer</a><ul class="level-2" id="defer-list"><li id="root-item" class="level-2"><ul class="level-3" id="root-list"><li id="defer-end-of-a-scope-item" class="level-3"><a id="defer-end-of-a-scope-link" href="#defer-end-of-a-scope" class="level-3">End of a scope</a></li><li id="defer-defer-execution-order-item" class="level-3"><a id="defer-defer-execution-order-link" href="#defer-defer-execution-order" class="level-3">Defer Execution order</a></li><li id="defer-example-defer-item" class="level-3"><a id="defer-example-defer-link" href="#defer-example-defer" class="level-3">Example defer</a></li></ul></li><li id="defer-defer-try-item" class="level-2"><a id="defer-defer-try-link" href="#defer-defer-try" class="level-2">Defer try</a><ul class="level-3" id="defer-defer-try-list"><li id="defer-defer-try-examples-item" class="level-3"><a id="defer-defer-try-examples-link" href="#defer-defer-try-examples" class="level-3">Examples</a></li></ul></li><li id="defer-defer-catch-item" class="level-2"><a id="defer-defer-catch-link" href="#defer-defer-catch" class="level-2">Defer catch</a><ul class="level-3" id="defer-defer-catch-list"><li id="defer-defer-catch-memory-allocation-example-item" class="level-3"><a id="defer-defer-catch-memory-allocation-example-link" href="#defer-defer-catch-memory-allocation-example" class="level-3">Memory allocation example</a></li></ul></li><li id="defer-pitfalls-with-defer-and-defer-catch-item" class="level-2"><a id="defer-pitfalls-with-defer-and-defer-catch-link" href="#defer-pitfalls-with-defer-and-defer-catch" class="level-2">Pitfalls with defer and defer catch</a></li></ul></li><li id="pre-conditions-item" class="level-1"><a id="pre-conditions-link" href="#pre-conditions" class="level-1">Pre-conditions</a></li><li id="post-conditions-item" class="level-1"><a id="post-conditions-link" href="#post-conditions" class="level-1">Post conditions</a><ul class="level-2" id="post-conditions-list"><li id="post-conditions-parameter-annotations-item" class="level-2"><a id="post-conditions-parameter-annotations-link" href="#post-conditions-parameter-annotations" class="level-2">Parameter annotations</a><ul class="level-3" id="post-conditions-parameter-annotations-list"><li id="post-conditions-parameter-annotations-pure-in-detail-item" class="level-3"><a id="post-conditions-parameter-annotations-pure-in-detail-link" href="#post-conditions-parameter-annotations-pure-in-detail" class="level-3">Pure in detail</a></li></ul></li></ul></li><li id="pre-conditions-for-macros-item" class="level-1"><a id="pre-conditions-for-macros-link" href="#pre-conditions-for-macros" class="level-1">Pre conditions for macros</a><ul class="level-2" id="pre-conditions-for-macros-list"><li id="pre-conditions-for-macros-built-in-attributes-item" class="level-2"><a id="pre-conditions-for-macros-built-in-attributes-link" href="#pre-conditions-for-macros-built-in-attributes" class="level-2">Built in attributes</a><ul class="level-3" id="pre-conditions-for-macros-built-in-attributes-list"><li id="pre-conditions-for-macros-built-in-attributes-adhoc-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-adhoc-link" href="#pre-conditions-for-macros-built-in-attributes-adhoc" class="level-3">@adhoc</a></li><li id="pre-conditions-for-macros-built-in-attributes-alignalignment-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-alignalignment-link" href="#pre-conditions-for-macros-built-in-attributes-alignalignment" class="level-3">@align(alignment)</a></li><li id="pre-conditions-for-macros-built-in-attributes-benchmark-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-benchmark-link" href="#pre-conditions-for-macros-built-in-attributes-benchmark" class="level-3">@benchmark</a></li><li id="pre-conditions-for-macros-built-in-attributes-bigendian-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-bigendian-link" href="#pre-conditions-for-macros-built-in-attributes-bigendian" class="level-3">@bigendian</a></li><li id="pre-conditions-for-macros-built-in-attributes-builtin-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-builtin-link" href="#pre-conditions-for-macros-built-in-attributes-builtin" class="level-3">@builtin</a></li><li id="pre-conditions-for-macros-built-in-attributes-callc-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-callc-link" href="#pre-conditions-for-macros-built-in-attributes-callc" class="level-3">@callc</a></li><li id="pre-conditions-for-macros-built-in-attributes-deprecated-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-deprecated-link" href="#pre-conditions-for-macros-built-in-attributes-deprecated" class="level-3">@deprecated</a></li><li id="pre-conditions-for-macros-built-in-attributes-export-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-export-link" href="#pre-conditions-for-macros-built-in-attributes-export" class="level-3">@export</a></li><li id="pre-conditions-for-macros-built-in-attributes-extern-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-extern-link" href="#pre-conditions-for-macros-built-in-attributes-extern" class="level-3">@extern</a></li><li id="pre-conditions-for-macros-built-in-attributes-finalizer-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-finalizer-link" href="#pre-conditions-for-macros-built-in-attributes-finalizer" class="level-3">@finalizer</a></li><li id="pre-conditions-for-macros-built-in-attributes-if-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-if-link" href="#pre-conditions-for-macros-built-in-attributes-if" class="level-3">@if</a></li><li id="pre-conditions-for-macros-built-in-attributes-init-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-init-link" href="#pre-conditions-for-macros-built-in-attributes-init" class="level-3">@init</a></li><li id="pre-conditions-for-macros-built-in-attributes-inline-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-inline-link" href="#pre-conditions-for-macros-built-in-attributes-inline" class="level-3">@inline</a></li><li id="pre-conditions-for-macros-built-in-attributes-littleendian-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-littleendian-link" href="#pre-conditions-for-macros-built-in-attributes-littleendian" class="level-3">@littleendian</a></li><li id="pre-conditions-for-macros-built-in-attributes-local-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-local-link" href="#pre-conditions-for-macros-built-in-attributes-local" class="level-3">@local</a></li><li id="pre-conditions-for-macros-built-in-attributes-maydiscard-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-maydiscard-link" href="#pre-conditions-for-macros-built-in-attributes-maydiscard" class="level-3">@maydiscard</a></li><li id="pre-conditions-for-macros-built-in-attributes-naked-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-naked-link" href="#pre-conditions-for-macros-built-in-attributes-naked" class="level-3">@naked</a></li><li id="pre-conditions-for-macros-built-in-attributes-nodiscard-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-nodiscard-link" href="#pre-conditions-for-macros-built-in-attributes-nodiscard" class="level-3">@nodiscard</a></li><li id="pre-conditions-for-macros-built-in-attributes-noinit-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-noinit-link" href="#pre-conditions-for-macros-built-in-attributes-noinit" class="level-3">@noinit</a></li><li id="pre-conditions-for-macros-built-in-attributes-norecurse-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-norecurse-link" href="#pre-conditions-for-macros-built-in-attributes-norecurse" class="level-3">@norecurse</a></li><li id="pre-conditions-for-macros-built-in-attributes-noreturn-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-noreturn-link" href="#pre-conditions-for-macros-built-in-attributes-noreturn" class="level-3">@noreturn</a></li><li id="pre-conditions-for-macros-built-in-attributes-nostrip-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-nostrip-link" href="#pre-conditions-for-macros-built-in-attributes-nostrip" class="level-3">@nostrip</a></li><li id="pre-conditions-for-macros-built-in-attributes-obfuscate-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-obfuscate-link" href="#pre-conditions-for-macros-built-in-attributes-obfuscate" class="level-3">@obfuscate</a></li><li id="pre-conditions-for-macros-built-in-attributes-operator-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-operator-link" href="#pre-conditions-for-macros-built-in-attributes-operator" class="level-3">@operator</a></li><li id="pre-conditions-for-macros-built-in-attributes-overlap-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-overlap-link" href="#pre-conditions-for-macros-built-in-attributes-overlap" class="level-3">@overlap</a></li><li id="pre-conditions-for-macros-built-in-attributes-packed-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-packed-link" href="#pre-conditions-for-macros-built-in-attributes-packed" class="level-3">@packed</a></li><li id="pre-conditions-for-macros-built-in-attributes-private-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-private-link" href="#pre-conditions-for-macros-built-in-attributes-private" class="level-3">@private</a></li><li id="pre-conditions-for-macros-built-in-attributes-pure-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-pure-link" href="#pre-conditions-for-macros-built-in-attributes-pure" class="level-3">@pure</a></li><li id="pre-conditions-for-macros-built-in-attributes-packed-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-packed-link" href="#pre-conditions-for-macros-built-in-attributes-packed" class="level-3">@packed</a></li><li id="pre-conditions-for-macros-built-in-attributes-reflect-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-reflect-link" href="#pre-conditions-for-macros-built-in-attributes-reflect" class="level-3">@reflect</a></li><li id="pre-conditions-for-macros-built-in-attributes-sectionname-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-sectionname-link" href="#pre-conditions-for-macros-built-in-attributes-sectionname" class="level-3">@section(name)</a></li><li id="pre-conditions-for-macros-built-in-attributes-test-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-test-link" href="#pre-conditions-for-macros-built-in-attributes-test" class="level-3">@test</a></li><li id="pre-conditions-for-macros-built-in-attributes-unused-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-unused-link" href="#pre-conditions-for-macros-built-in-attributes-unused" class="level-3">@unused</a></li><li id="pre-conditions-for-macros-built-in-attributes-used-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-used-link" href="#pre-conditions-for-macros-built-in-attributes-used" class="level-3">@used</a></li><li id="pre-conditions-for-macros-built-in-attributes-weak-item" class="level-3"><a id="pre-conditions-for-macros-built-in-attributes-weak-link" href="#pre-conditions-for-macros-built-in-attributes-weak" class="level-3">@weak</a></li></ul></li><li id="pre-conditions-for-macros-user-defined-attributes-item" class="level-2"><a id="pre-conditions-for-macros-user-defined-attributes-link" href="#pre-conditions-for-macros-user-defined-attributes" class="level-2">User defined attributes</a></li><li id="pre-conditions-for-macros-linking-static-and-dynamic-libraries-item" class="level-2"><a id="pre-conditions-for-macros-linking-static-and-dynamic-libraries-link" href="#pre-conditions-for-macros-linking-static-and-dynamic-libraries" class="level-2">Linking static and dynamic libraries</a><ul class="level-3" id="pre-conditions-for-macros-linking-static-and-dynamic-libraries-list"><li id="pre-conditions-for-macros-linking-static-and-dynamic-libraries-gotchas-item" class="level-3"><a id="pre-conditions-for-macros-linking-static-and-dynamic-libraries-gotchas-link" href="#pre-conditions-for-macros-linking-static-and-dynamic-libraries-gotchas" class="level-3">Gotchas</a></li></ul></li><li id="pre-conditions-for-macros-working-with-the-type-of-any-at-runtime-item" class="level-2"><a id="pre-conditions-for-macros-working-with-the-type-of-any-at-runtime-link" href="#pre-conditions-for-macros-working-with-the-type-of-any-at-runtime" class="level-2">Working with the type of any at runtime.</a></li><li id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any-item" class="level-2"><a id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any-link" href="#pre-conditions-for-macros-variable-argument-functions-with-implicit-any" class="level-2">Variable argument functions with implicit any</a><ul class="level-3" id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any-list"><li id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any-explicit-any-vararg-functions-item" class="level-3"><a id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any-explicit-any-vararg-functions-link" href="#pre-conditions-for-macros-variable-argument-functions-with-implicit-any-explicit-any-vararg-functions" class="level-3">Explicit any vararg functions</a></li><li id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any-implicit-any-vararg-functions-item" class="level-3"><a id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any-implicit-any-vararg-functions-link" href="#pre-conditions-for-macros-variable-argument-functions-with-implicit-any-implicit-any-vararg-functions" class="level-3">Implicit any vararg functions</a></li></ul></li><li id="pre-conditions-for-macros-interfaces-item" class="level-2"><a id="pre-conditions-for-macros-interfaces-link" href="#pre-conditions-for-macros-interfaces" class="level-2">Interfaces</a><ul class="level-3" id="pre-conditions-for-macros-interfaces-list"><li id="pre-conditions-for-macros-interfaces-defining-an-interface-item" class="level-3"><a id="pre-conditions-for-macros-interfaces-defining-an-interface-link" href="#pre-conditions-for-macros-interfaces-defining-an-interface" class="level-3">Defining an interface</a></li><li id="pre-conditions-for-macros-interfaces-implementing-the-interface-item" class="level-3"><a id="pre-conditions-for-macros-interfaces-implementing-the-interface-link" href="#pre-conditions-for-macros-interfaces-implementing-the-interface" class="level-3">Implementing the interface</a></li><li id="pre-conditions-for-macros-interfaces-dynamic-methods-item" class="level-3"><a id="pre-conditions-for-macros-interfaces-dynamic-methods-link" href="#pre-conditions-for-macros-interfaces-dynamic-methods" class="level-3">“@dynamic” methods</a></li><li id="pre-conditions-for-macros-interfaces-referring-to-an-interface-by-pointer-item" class="level-3"><a id="pre-conditions-for-macros-interfaces-referring-to-an-interface-by-pointer-link" href="#pre-conditions-for-macros-interfaces-referring-to-an-interface-by-pointer" class="level-3">Referring to an interface by pointer</a></li><li id="pre-conditions-for-macros-interfaces-calling-dynamic-methods-item" class="level-3"><a id="pre-conditions-for-macros-interfaces-calling-dynamic-methods-link" href="#pre-conditions-for-macros-interfaces-calling-dynamic-methods" class="level-3">Calling dynamic methods</a></li><li id="pre-conditions-for-macros-interfaces-reflection-invocation-item" class="level-3"><a id="pre-conditions-for-macros-interfaces-reflection-invocation-link" href="#pre-conditions-for-macros-interfaces-reflection-invocation" class="level-3">Reflection invocation</a></li></ul></li><li id="pre-conditions-for-macros-element-at-operator-item" class="level-2"><a id="pre-conditions-for-macros-element-at-operator-link" href="#pre-conditions-for-macros-element-at-operator" class="level-2">“Element at” operator []</a></li><li id="pre-conditions-for-macros-element-ref-operator-item" class="level-2"><a id="pre-conditions-for-macros-element-ref-operator-link" href="#pre-conditions-for-macros-element-ref-operator" class="level-2">“Element ref” operator &amp;[]</a></li><li id="pre-conditions-for-macros-element-set-operator-item" class="level-2"><a id="pre-conditions-for-macros-element-set-operator-link" href="#pre-conditions-for-macros-element-set-operator" class="level-2">“Element set” operator []=</a></li><li id="pre-conditions-for-macros-len-operator-item" class="level-2"><a id="pre-conditions-for-macros-len-operator-link" href="#pre-conditions-for-macros-len-operator" class="level-2">“len” operator</a></li><li id="pre-conditions-for-macros-enabling-foreach-item" class="level-2"><a id="pre-conditions-for-macros-enabling-foreach-link" href="#pre-conditions-for-macros-enabling-foreach" class="level-2">Enabling ‘foreach’</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-item" class="level-2"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros" class="level-2">A quick comparison of C and C3 macros</a><ul class="level-3" id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-list"><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-conditional-compilation-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-conditional-compilation-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-conditional-compilation" class="level-3">Conditional compilation</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-macros-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-macros-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-macros" class="level-3">Macros</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-dynamic-scoping-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-dynamic-scoping-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-dynamic-scoping" class="level-3">Dynamic scoping</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-expression-arguments-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-expression-arguments-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-expression-arguments" class="level-3">Expression arguments</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-first-class-types-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-first-class-types-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-first-class-types" class="level-3">First class types</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-trailing-blocks-for-macros-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-trailing-blocks-for-macros-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-trailing-blocks-for-macros" class="level-3">Trailing blocks for macros</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-first-class-names-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-first-class-names-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-first-class-names" class="level-3">First class names</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-declaration-attributes-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-declaration-attributes-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-declaration-attributes" class="level-3">Declaration attributes</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-declaration-macros-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-declaration-macros-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-declaration-macros" class="level-3">Declaration macros</a></li><li id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-stringification-item" class="level-3"><a id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-stringification-link" href="#pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-stringification" class="level-3">Stringification</a></li></ul></li><li id="pre-conditions-for-macros-top-level-evaluation-item" class="level-2"><a id="pre-conditions-for-macros-top-level-evaluation-link" href="#pre-conditions-for-macros-top-level-evaluation" class="level-2">Top level evaluation</a></li><li id="pre-conditions-for-macros-macro-declarations-item" class="level-2"><a id="pre-conditions-for-macros-macro-declarations-link" href="#pre-conditions-for-macros-macro-declarations" class="level-2">Macro declarations</a></li><li id="pre-conditions-for-macros-macro-methods-item" class="level-2"><a id="pre-conditions-for-macros-macro-methods-link" href="#pre-conditions-for-macros-macro-methods" class="level-2">Macro methods</a></li><li id="pre-conditions-for-macros-capturing-a-trailing-block-item" class="level-2"><a id="pre-conditions-for-macros-capturing-a-trailing-block-link" href="#pre-conditions-for-macros-capturing-a-trailing-block" class="level-2">Capturing a trailing block</a></li><li id="pre-conditions-for-macros-macros-returning-values-item" class="level-2"><a id="pre-conditions-for-macros-macros-returning-values-link" href="#pre-conditions-for-macros-macros-returning-values" class="level-2">Macros returning values</a></li><li id="pre-conditions-for-macros-calling-macros-item" class="level-2"><a id="pre-conditions-for-macros-calling-macros-link" href="#pre-conditions-for-macros-calling-macros" class="level-2">Calling macros</a></li><li id="pre-conditions-for-macros-macro-vaargs-item" class="level-2"><a id="pre-conditions-for-macros-macro-vaargs-link" href="#pre-conditions-for-macros-macro-vaargs" class="level-2">Macro vaargs</a><ul class="level-3" id="pre-conditions-for-macros-macro-vaargs-list"><li id="pre-conditions-for-macros-macro-vaargs-vacount-item" class="level-3"><a id="pre-conditions-for-macros-macro-vaargs-vacount-link" href="#pre-conditions-for-macros-macro-vaargs-vacount" class="level-3">$vacount</a></li><li id="pre-conditions-for-macros-macro-vaargs-vaarg-item" class="level-3"><a id="pre-conditions-for-macros-macro-vaargs-vaarg-link" href="#pre-conditions-for-macros-macro-vaargs-vaarg" class="level-3">$vaarg</a></li><li id="pre-conditions-for-macros-macro-vaargs-vaconst-item" class="level-3"><a id="pre-conditions-for-macros-macro-vaargs-vaconst-link" href="#pre-conditions-for-macros-macro-vaargs-vaconst" class="level-3">$vaconst</a></li><li id="pre-conditions-for-macros-macro-vaargs-vaexpr-item" class="level-3"><a id="pre-conditions-for-macros-macro-vaargs-vaexpr-link" href="#pre-conditions-for-macros-macro-vaargs-vaexpr" class="level-3">$vaexpr</a></li><li id="pre-conditions-for-macros-macro-vaargs-vatype-item" class="level-3"><a id="pre-conditions-for-macros-macro-vaargs-vatype-link" href="#pre-conditions-for-macros-macro-vaargs-vatype" class="level-3">$vatype</a></li><li id="pre-conditions-for-macros-macro-vaargs-vasplat-item" class="level-3"><a id="pre-conditions-for-macros-macro-vaargs-vasplat-link" href="#pre-conditions-for-macros-macro-vaargs-vasplat" class="level-3">$vasplat</a></li></ul></li><li id="pre-conditions-for-macros-untyped-lists-item" class="level-2"><a id="pre-conditions-for-macros-untyped-lists-link" href="#pre-conditions-for-macros-untyped-lists" class="level-2">Untyped lists</a><ul class="level-3" id="pre-conditions-for-macros-untyped-lists-list"><li id="pre-conditions-for-macros-untyped-lists-compile-time-values-item" class="level-3"><a id="pre-conditions-for-macros-untyped-lists-compile-time-values-link" href="#pre-conditions-for-macros-untyped-lists-compile-time-values" class="level-3">Compile time values</a></li><li id="pre-conditions-for-macros-untyped-lists-if-and-switch-item" class="level-3"><a id="pre-conditions-for-macros-untyped-lists-if-and-switch-link" href="#pre-conditions-for-macros-untyped-lists-if-and-switch" class="level-3">$if and $switch</a></li><li id="pre-conditions-for-macros-untyped-lists-loops-using-foreach-and-for-item" class="level-3"><a id="pre-conditions-for-macros-untyped-lists-loops-using-foreach-and-for-link" href="#pre-conditions-for-macros-untyped-lists-loops-using-foreach-and-for" class="level-3">Loops using $foreach and $for</a></li><li id="pre-conditions-for-macros-untyped-lists-compile-time-macro-execution-item" class="level-3"><a id="pre-conditions-for-macros-untyped-lists-compile-time-macro-execution-link" href="#pre-conditions-for-macros-untyped-lists-compile-time-macro-execution" class="level-3">Compile time macro execution</a></li><li id="pre-conditions-for-macros-untyped-lists-conditional-compilation-at-the-top-level-using-if-item" class="level-3"><a id="pre-conditions-for-macros-untyped-lists-conditional-compilation-at-the-top-level-using-if-link" href="#pre-conditions-for-macros-untyped-lists-conditional-compilation-at-the-top-level-using-if" class="level-3">Conditional compilation at the top level using @if</a></li></ul></li><li id="pre-conditions-for-macros-compile-time-introspection-item" class="level-2"><a id="pre-conditions-for-macros-compile-time-introspection-link" href="#pre-conditions-for-macros-compile-time-introspection" class="level-2">Compile time introspection</a></li><li id="pre-conditions-for-macros-compile-time-functions-item" class="level-2"><a id="pre-conditions-for-macros-compile-time-functions-link" href="#pre-conditions-for-macros-compile-time-functions" class="level-2">Compile time functions</a><ul class="level-3" id="pre-conditions-for-macros-compile-time-functions-list"><li id="pre-conditions-for-macros-compile-time-functions-alignof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-alignof-link" href="#pre-conditions-for-macros-compile-time-functions-alignof" class="level-3">$alignof</a></li><li id="pre-conditions-for-macros-compile-time-functions-append-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-append-link" href="#pre-conditions-for-macros-compile-time-functions-append" class="level-3">$append</a></li><li id="pre-conditions-for-macros-compile-time-functions-assert-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-assert-link" href="#pre-conditions-for-macros-compile-time-functions-assert" class="level-3">$assert</a></li><li id="pre-conditions-for-macros-compile-time-functions-assignable-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-assignable-link" href="#pre-conditions-for-macros-compile-time-functions-assignable" class="level-3">$assignable</a></li><li id="pre-conditions-for-macros-compile-time-functions-defined-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-defined-link" href="#pre-conditions-for-macros-compile-time-functions-defined" class="level-3">$defined</a></li><li id="pre-conditions-for-macros-compile-time-functions-echo-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-echo-link" href="#pre-conditions-for-macros-compile-time-functions-echo" class="level-3">$echo</a></li><li id="pre-conditions-for-macros-compile-time-functions-embed-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-embed-link" href="#pre-conditions-for-macros-compile-time-functions-embed" class="level-3">$embed</a></li><li id="pre-conditions-for-macros-compile-time-functions-error-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-error-link" href="#pre-conditions-for-macros-compile-time-functions-error" class="level-3">$error</a></li><li id="pre-conditions-for-macros-compile-time-functions-eval-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-eval-link" href="#pre-conditions-for-macros-compile-time-functions-eval" class="level-3">$eval</a></li><li id="pre-conditions-for-macros-compile-time-functions-evaltype-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-evaltype-link" href="#pre-conditions-for-macros-compile-time-functions-evaltype" class="level-3">$evaltype</a></li><li id="pre-conditions-for-macros-compile-time-functions-exec-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-exec-link" href="#pre-conditions-for-macros-compile-time-functions-exec" class="level-3">$exec</a></li><li id="pre-conditions-for-macros-compile-time-functions-extnameof-qnameof-and-nameof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-extnameof-qnameof-and-nameof-link" href="#pre-conditions-for-macros-compile-time-functions-extnameof-qnameof-and-nameof" class="level-3">$extnameof, $qnameof and $nameof</a></li><li id="pre-conditions-for-macros-compile-time-functions-feature-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-feature-link" href="#pre-conditions-for-macros-compile-time-functions-feature" class="level-3">$feature</a></li><li id="pre-conditions-for-macros-compile-time-functions-is_const-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-is_const-link" href="#pre-conditions-for-macros-compile-time-functions-is_const" class="level-3">$is_const</a></li><li id="pre-conditions-for-macros-compile-time-functions-nameof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-nameof-link" href="#pre-conditions-for-macros-compile-time-functions-nameof" class="level-3">$nameof</a></li><li id="pre-conditions-for-macros-compile-time-functions-offsetof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-offsetof-link" href="#pre-conditions-for-macros-compile-time-functions-offsetof" class="level-3">$offsetof</a></li><li id="pre-conditions-for-macros-compile-time-functions-qnameof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-qnameof-link" href="#pre-conditions-for-macros-compile-time-functions-qnameof" class="level-3">$qnameof</a></li><li id="pre-conditions-for-macros-compile-time-functions-vacount-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-vacount-link" href="#pre-conditions-for-macros-compile-time-functions-vacount" class="level-3">$vacount</a></li><li id="pre-conditions-for-macros-compile-time-functions-vaconst-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-vaconst-link" href="#pre-conditions-for-macros-compile-time-functions-vaconst" class="level-3">$vaconst</a></li><li id="pre-conditions-for-macros-compile-time-functions-vaexpr-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-vaexpr-link" href="#pre-conditions-for-macros-compile-time-functions-vaexpr" class="level-3">$vaexpr</a></li><li id="pre-conditions-for-macros-compile-time-functions-vasplat-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-vasplat-link" href="#pre-conditions-for-macros-compile-time-functions-vasplat" class="level-3">$vasplat</a></li><li id="pre-conditions-for-macros-compile-time-functions-vatype-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-vatype-link" href="#pre-conditions-for-macros-compile-time-functions-vatype" class="level-3">$vatype</a></li><li id="pre-conditions-for-macros-compile-time-functions-sizeof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-sizeof-link" href="#pre-conditions-for-macros-compile-time-functions-sizeof" class="level-3">$sizeof</a></li><li id="pre-conditions-for-macros-compile-time-functions-stringify-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-stringify-link" href="#pre-conditions-for-macros-compile-time-functions-stringify" class="level-3">$stringify</a></li><li id="pre-conditions-for-macros-compile-time-functions-typeof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-typeof-link" href="#pre-conditions-for-macros-compile-time-functions-typeof" class="level-3">$typeof</a></li><li id="pre-conditions-for-macros-compile-time-functions-typefrom-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-functions-typefrom-link" href="#pre-conditions-for-macros-compile-time-functions-typefrom" class="level-3">$typefrom</a></li></ul></li><li id="pre-conditions-for-macros-compile-time-reflection-item" class="level-2"><a id="pre-conditions-for-macros-compile-time-reflection-link" href="#pre-conditions-for-macros-compile-time-reflection" class="level-2">Compile time reflection</a><ul class="level-3" id="pre-conditions-for-macros-compile-time-reflection-list"><li id="pre-conditions-for-macros-compile-time-reflection-type-properties-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-type-properties-link" href="#pre-conditions-for-macros-compile-time-reflection-type-properties" class="level-3">Type properties</a></li><li id="pre-conditions-for-macros-compile-time-reflection-compile-time-functions-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-compile-time-functions-link" href="#pre-conditions-for-macros-compile-time-reflection-compile-time-functions" class="level-3">Compile time functions</a></li><li id="pre-conditions-for-macros-compile-time-reflection-alignof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-alignof-link" href="#pre-conditions-for-macros-compile-time-reflection-alignof" class="level-3">$alignof</a></li><li id="pre-conditions-for-macros-compile-time-reflection-defined-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-defined-link" href="#pre-conditions-for-macros-compile-time-reflection-defined" class="level-3">$defined</a></li><li id="pre-conditions-for-macros-compile-time-reflection-eval-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-eval-link" href="#pre-conditions-for-macros-compile-time-reflection-eval" class="level-3">$eval</a></li><li id="pre-conditions-for-macros-compile-time-reflection-evaltype-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-evaltype-link" href="#pre-conditions-for-macros-compile-time-reflection-evaltype" class="level-3">$evaltype</a></li><li id="pre-conditions-for-macros-compile-time-reflection-extnameof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-extnameof-link" href="#pre-conditions-for-macros-compile-time-reflection-extnameof" class="level-3">$extnameof</a></li><li id="pre-conditions-for-macros-compile-time-reflection-nameof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-nameof-link" href="#pre-conditions-for-macros-compile-time-reflection-nameof" class="level-3">$nameof</a></li><li id="pre-conditions-for-macros-compile-time-reflection-offsetof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-offsetof-link" href="#pre-conditions-for-macros-compile-time-reflection-offsetof" class="level-3">$offsetof</a></li><li id="pre-conditions-for-macros-compile-time-reflection-qnameof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-qnameof-link" href="#pre-conditions-for-macros-compile-time-reflection-qnameof" class="level-3">$qnameof</a></li><li id="pre-conditions-for-macros-compile-time-reflection-sizeof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-sizeof-link" href="#pre-conditions-for-macros-compile-time-reflection-sizeof" class="level-3">$sizeof</a></li><li id="pre-conditions-for-macros-compile-time-reflection-stringify-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-stringify-link" href="#pre-conditions-for-macros-compile-time-reflection-stringify" class="level-3">$stringify</a></li><li id="pre-conditions-for-macros-compile-time-reflection-typeof-item" class="level-3"><a id="pre-conditions-for-macros-compile-time-reflection-typeof-link" href="#pre-conditions-for-macros-compile-time-reflection-typeof" class="level-3">$typeof</a></li></ul></li><li id="pre-conditions-for-macros-stdcorebuiltin-item" class="level-2"><a id="pre-conditions-for-macros-stdcorebuiltin-link" href="#pre-conditions-for-macros-stdcorebuiltin" class="level-2">std::core::builtin</a><ul class="level-3" id="pre-conditions-for-macros-stdcorebuiltin-list"><li id="pre-conditions-for-macros-stdcorebuiltin-void-panicchar-message-char-file-char-function-uint-line-item" class="level-3"><a id="pre-conditions-for-macros-stdcorebuiltin-void-panicchar-message-char-file-char-function-uint-line-link" href="#pre-conditions-for-macros-stdcorebuiltin-void-panicchar-message-char-file-char-function-uint-line" class="level-3">void panic(char message, char file, char *function, uint line)</a></li><li id="pre-conditions-for-macros-stdcorebuiltin-void-swapa-b-item" class="level-3"><a id="pre-conditions-for-macros-stdcorebuiltin-void-swapa-b-link" href="#pre-conditions-for-macros-stdcorebuiltin-void-swapa-b" class="level-3">void @swap(&amp;a, &amp;b)</a></li><li id="pre-conditions-for-macros-stdcorebuiltin-anycastany-v-type-item" class="level-3"><a id="pre-conditions-for-macros-stdcorebuiltin-anycastany-v-type-link" href="#pre-conditions-for-macros-stdcorebuiltin-anycastany-v-type" class="level-3">anycast(any v, $Type)</a></li><li id="pre-conditions-for-macros-stdcorebuiltin-void-unreachablestring-unreachable-statement-reached-item" class="level-3"><a id="pre-conditions-for-macros-stdcorebuiltin-void-unreachablestring-unreachable-statement-reached-link" href="#pre-conditions-for-macros-stdcorebuiltin-void-unreachablestring-unreachable-statement-reached" class="level-3">void unreachable($string = “Unreachable statement reached.”)</a></li><li id="pre-conditions-for-macros-stdcorebuiltin-bitcastvalue-type-item" class="level-3"><a id="pre-conditions-for-macros-stdcorebuiltin-bitcastvalue-type-link" href="#pre-conditions-for-macros-stdcorebuiltin-bitcastvalue-type" class="level-3">bitcast(value, $Type)</a></li><li id="pre-conditions-for-macros-stdcorebuiltin-enum_by_nametype-enum_name-item" class="level-3"><a id="pre-conditions-for-macros-stdcorebuiltin-enum_by_nametype-enum_name-link" href="#pre-conditions-for-macros-stdcorebuiltin-enum_by_nametype-enum_name" class="level-3">enum_by_name($Type, enum_name)</a></li><li id="pre-conditions-for-macros-stdcorebuiltin-void-scopevariable-body-item" class="level-3"><a id="pre-conditions-for-macros-stdcorebuiltin-void-scopevariable-body-link" href="#pre-conditions-for-macros-stdcorebuiltin-void-scopevariable-body" class="level-3">void @scope(&amp;variable; @body)</a></li><li id="pre-conditions-for-macros-stdcorebuiltin-less-greater-less_eq-greater_eq-equals-item" class="level-3"><a id="pre-conditions-for-macros-stdcorebuiltin-less-greater-less_eq-greater_eq-equals-link" href="#pre-conditions-for-macros-stdcorebuiltin-less-greater-less_eq-greater_eq-equals" class="level-3">less, greater, less_eq, greater_eq, equals</a></li><li id="pre-conditions-for-macros-stdcorebuiltin-faults-item" class="level-3"><a id="pre-conditions-for-macros-stdcorebuiltin-faults-link" href="#pre-conditions-for-macros-stdcorebuiltin-faults" class="level-3">Faults</a></li></ul></li><li id="pre-conditions-for-macros-stdcoreenv-item" class="level-2"><a id="pre-conditions-for-macros-stdcoreenv-link" href="#pre-conditions-for-macros-stdcoreenv" class="level-2">std::core::env</a><ul class="level-3" id="pre-conditions-for-macros-stdcoreenv-list"><li id="pre-conditions-for-macros-stdcoreenv-constants-item" class="level-3"><a id="pre-conditions-for-macros-stdcoreenv-constants-link" href="#pre-conditions-for-macros-stdcoreenv-constants" class="level-3">Constants</a></li></ul></li><li id="pre-conditions-for-macros-stdcoremem-item" class="level-2"><a id="pre-conditions-for-macros-stdcoremem-link" href="#pre-conditions-for-macros-stdcoremem" class="level-2">std::core::mem</a><ul class="level-3" id="pre-conditions-for-macros-stdcoremem-list"><li id="pre-conditions-for-macros-stdcoremem-malloc-malloc_checked-malloc_aligned-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-malloc-malloc_checked-malloc_aligned-link" href="#pre-conditions-for-macros-stdcoremem-malloc-malloc_checked-malloc_aligned" class="level-3">malloc, malloc_checked, malloc_aligned</a></li><li id="pre-conditions-for-macros-stdcoremem-newtype-initializer-new_alignedtype-initializer-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-newtype-initializer-new_alignedtype-initializer-link" href="#pre-conditions-for-macros-stdcoremem-newtype-initializer-new_alignedtype-initializer" class="level-3">new($Type, #initializer), new_aligned($Type, #initializer)</a></li><li id="pre-conditions-for-macros-stdcoremem-alloctype-alloc_alignedtype-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-alloctype-alloc_alignedtype-link" href="#pre-conditions-for-macros-stdcoremem-alloctype-alloc_alignedtype" class="level-3">alloc($Type), alloc_aligned($Type)</a></li><li id="pre-conditions-for-macros-stdcoremem-new_arraytype-usz-elements-new_array_alignedtype-usz-elements-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-new_arraytype-usz-elements-new_array_alignedtype-usz-elements-link" href="#pre-conditions-for-macros-stdcoremem-new_arraytype-usz-elements-new_array_alignedtype-usz-elements" class="level-3">new_array($Type, usz elements), new_array_aligned($Type, usz elements)</a></li><li id="pre-conditions-for-macros-stdcoremem-alloc_arraytype-usz-elements-alloc_array_alignedtype-usz-elements-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-alloc_arraytype-usz-elements-alloc_array_alignedtype-usz-elements-link" href="#pre-conditions-for-macros-stdcoremem-alloc_arraytype-usz-elements-alloc_array_alignedtype-usz-elements" class="level-3">alloc_array($Type, usz elements), alloc_array_aligned($Type, usz elements)</a></li><li id="pre-conditions-for-macros-stdcoremem-calloc-calloc_checked-calloc_aligned-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-calloc-calloc_checked-calloc_aligned-link" href="#pre-conditions-for-macros-stdcoremem-calloc-calloc_checked-calloc_aligned" class="level-3">calloc, calloc_checked, calloc_aligned</a></li><li id="pre-conditions-for-macros-stdcoremem-relloc-relloc_checked-realloc_aligned-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-relloc-relloc_checked-realloc_aligned-link" href="#pre-conditions-for-macros-stdcoremem-relloc-relloc_checked-realloc_aligned" class="level-3">relloc, relloc_checked, realloc_aligned</a></li><li id="pre-conditions-for-macros-stdcoremem-free-free_aligned-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-free-free_aligned-link" href="#pre-conditions-for-macros-stdcoremem-free-free_aligned" class="level-3">free, free_aligned</a></li><li id="pre-conditions-for-macros-stdcoremem-scopedallocator-allocator-body-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-scopedallocator-allocator-body-link" href="#pre-conditions-for-macros-stdcoremem-scopedallocator-allocator-body" class="level-3">@scoped(Allocator* allocator; @body())</a></li><li id="pre-conditions-for-macros-stdcoremem-tscoped-body-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-tscoped-body-link" href="#pre-conditions-for-macros-stdcoremem-tscoped-body" class="level-3">@tscoped(; @body())</a></li><li id="pre-conditions-for-macros-stdcoremem-void-tmallocusz-size-usz-alignment-0-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-void-tmallocusz-size-usz-alignment-0-link" href="#pre-conditions-for-macros-stdcoremem-void-tmallocusz-size-usz-alignment-0" class="level-3">void* tmalloc(usz size, usz alignment = 0)</a></li><li id="pre-conditions-for-macros-stdcoremem-void-tcallocusz-size-usz-alignment-0-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-void-tcallocusz-size-usz-alignment-0-link" href="#pre-conditions-for-macros-stdcoremem-void-tcallocusz-size-usz-alignment-0" class="level-3">void* tcalloc(usz size, usz alignment = 0)</a></li><li id="pre-conditions-for-macros-stdcoremem-void-treallocvoid-ptr-usz-size-usz-alignment-0-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-void-treallocvoid-ptr-usz-size-usz-alignment-0-link" href="#pre-conditions-for-macros-stdcoremem-void-treallocvoid-ptr-usz-size-usz-alignment-0" class="level-3">void trealloc(void ptr, usz size, usz alignment = 0)</a></li><li id="pre-conditions-for-macros-stdcoremem-temp_new-temp_alloc-temp_new_array-temp_alloc_array-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-temp_new-temp_alloc-temp_new_array-temp_alloc_array-link" href="#pre-conditions-for-macros-stdcoremem-temp_new-temp_alloc-temp_new_array-temp_alloc_array" class="level-3">temp_new, temp_alloc, temp_new_array, temp_alloc_array</a></li><li id="pre-conditions-for-macros-stdcoremem-void-poolbody-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-void-poolbody-link" href="#pre-conditions-for-macros-stdcoremem-void-poolbody" class="level-3">void @pool(;@body)</a></li><li id="pre-conditions-for-macros-stdcoremem-volatile_loadx-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-volatile_loadx-link" href="#pre-conditions-for-macros-stdcoremem-volatile_loadx" class="level-3">@volatile_load(&amp;x)</a></li><li id="pre-conditions-for-macros-stdcoremem-volatile_storex-y-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-volatile_storex-y-link" href="#pre-conditions-for-macros-stdcoremem-volatile_storex-y" class="level-3">@volatile_store(&amp;x, y)</a></li><li id="pre-conditions-for-macros-stdcoremem-usz-aligned_offsetusz-offset-usz-alignment-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-usz-aligned_offsetusz-offset-usz-alignment-link" href="#pre-conditions-for-macros-stdcoremem-usz-aligned_offsetusz-offset-usz-alignment" class="level-3">usz aligned_offset(usz offset, usz alignment)</a></li><li id="pre-conditions-for-macros-stdcoremem-usz-aligned_pointervoid-ptr-usz-alignment-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-usz-aligned_pointervoid-ptr-usz-alignment-link" href="#pre-conditions-for-macros-stdcoremem-usz-aligned_pointervoid-ptr-usz-alignment" class="level-3">usz aligned_pointer(void* ptr, usz alignment)</a></li><li id="pre-conditions-for-macros-stdcoremem-bool-ptr_is_alignedvoid-ptr-usz-alignment-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-bool-ptr_is_alignedvoid-ptr-usz-alignment-link" href="#pre-conditions-for-macros-stdcoremem-bool-ptr_is_alignedvoid-ptr-usz-alignment" class="level-3">bool ptr_is_aligned(void* ptr, usz alignment)</a></li><li id="pre-conditions-for-macros-stdcoremem-void-copyvoid-dst-void-src-usz-len-usz-dst_align-0-usz-src_align-0-bool-is_volatile-false-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-void-copyvoid-dst-void-src-usz-len-usz-dst_align-0-usz-src_align-0-bool-is_volatile-false-link" href="#pre-conditions-for-macros-stdcoremem-void-copyvoid-dst-void-src-usz-len-usz-dst_align-0-usz-src_align-0-bool-is_volatile-false" class="level-3">void copy(void dst, void src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)</a></li><li id="pre-conditions-for-macros-stdcoremem-void-setvoid-dst-char-val-usz-len-usz-dst_align-0-bool-is_volatile-false-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-void-setvoid-dst-char-val-usz-len-usz-dst_align-0-bool-is_volatile-false-link" href="#pre-conditions-for-macros-stdcoremem-void-setvoid-dst-char-val-usz-len-usz-dst_align-0-bool-is_volatile-false" class="level-3">void set(void* dst, char val, usz len, usz $dst_align = 0, bool $is_volatile = false)</a></li><li id="pre-conditions-for-macros-stdcoremem-void-clearvoid-dst-usz-len-usz-dst_align-0-bool-is_volatile-false-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-void-clearvoid-dst-usz-len-usz-dst_align-0-bool-is_volatile-false-link" href="#pre-conditions-for-macros-stdcoremem-void-clearvoid-dst-usz-len-usz-dst_align-0-bool-is_volatile-false" class="level-3">void clear(void* dst, usz len, usz $dst_align = 0, bool $is_volatile = false)</a></li><li id="pre-conditions-for-macros-stdcoremem-clonevalue-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-clonevalue-link" href="#pre-conditions-for-macros-stdcoremem-clonevalue" class="level-3">@clone(&amp;value)</a></li><li id="pre-conditions-for-macros-stdcoremem-tclonevalue-item" class="level-3"><a id="pre-conditions-for-macros-stdcoremem-tclonevalue-link" href="#pre-conditions-for-macros-stdcoremem-tclonevalue" class="level-3">@tclone(&amp;value)</a></li></ul></li><li id="pre-conditions-for-macros-stdcoretypes-item" class="level-2"><a id="pre-conditions-for-macros-stdcoretypes-link" href="#pre-conditions-for-macros-stdcoretypes" class="level-2">std::core::types</a><ul class="level-3" id="pre-conditions-for-macros-stdcoretypes-list"><li id="pre-conditions-for-macros-stdcoretypes-bool-is_comparable_valuetype-item" class="level-3"><a id="pre-conditions-for-macros-stdcoretypes-bool-is_comparable_valuetype-link" href="#pre-conditions-for-macros-stdcoretypes-bool-is_comparable_valuetype" class="level-3">bool is_comparable_value($Type)</a></li><li id="pre-conditions-for-macros-stdcoretypes-bool-is_equatable_valuevalue-item" class="level-3"><a id="pre-conditions-for-macros-stdcoretypes-bool-is_equatable_valuevalue-link" href="#pre-conditions-for-macros-stdcoretypes-bool-is_equatable_valuevalue" class="level-3">bool is_equatable_value(value)</a></li><li id="pre-conditions-for-macros-stdcoretypes-bool-is_equatable_valuevalue-item" class="level-3"><a id="pre-conditions-for-macros-stdcoretypes-bool-is_equatable_valuevalue-link" href="#pre-conditions-for-macros-stdcoretypes-bool-is_equatable_valuevalue" class="level-3">bool is_equatable_value(value)</a></li><li id="pre-conditions-for-macros-stdcoretypes-kind_is_inttypekind-kind-item" class="level-3"><a id="pre-conditions-for-macros-stdcoretypes-kind_is_inttypekind-kind-link" href="#pre-conditions-for-macros-stdcoretypes-kind_is_inttypekind-kind" class="level-3">kind_is_int(TypeKind kind)</a></li><li id="pre-conditions-for-macros-stdcoretypes-any_to_intany-v-type-item" class="level-3"><a id="pre-conditions-for-macros-stdcoretypes-any_to_intany-v-type-link" href="#pre-conditions-for-macros-stdcoretypes-any_to_intany-v-type" class="level-3">any_to_int(any* v, $Type)</a></li></ul></li><li id="pre-conditions-for-macros-stdcorestrconv-item" class="level-2"><a id="pre-conditions-for-macros-stdcorestrconv-link" href="#pre-conditions-for-macros-stdcorestrconv" class="level-2">std::core::str::conv</a><ul class="level-3" id="pre-conditions-for-macros-stdcorestrconv-list"><li id="pre-conditions-for-macros-stdcorestrconv-usz-char32_to_utf8char32-c-char-output-usz-available-item" class="level-3"><a id="pre-conditions-for-macros-stdcorestrconv-usz-char32_to_utf8char32-c-char-output-usz-available-link" href="#pre-conditions-for-macros-stdcorestrconv-usz-char32_to_utf8char32-c-char-output-usz-available" class="level-3">usz! char32_to_utf8(Char32 c, char* output, usz available)</a></li><li id="pre-conditions-for-macros-stdcorestrconv-void-char32_to_utf16_unsafechar32-c-char16-output-item" class="level-3"><a id="pre-conditions-for-macros-stdcorestrconv-void-char32_to_utf16_unsafechar32-c-char16-output-link" href="#pre-conditions-for-macros-stdcorestrconv-void-char32_to_utf16_unsafechar32-c-char16-output" class="level-3">void char32_to_utf16_unsafe(Char32 c, Char16** output)</a></li></ul></li><li id="pre-conditions-for-macros-stdio-item" class="level-2"><a id="pre-conditions-for-macros-stdio-link" href="#pre-conditions-for-macros-stdio" class="level-2">std::io</a><ul class="level-3" id="pre-conditions-for-macros-stdio-list"><li id="pre-conditions-for-macros-stdio-string-readlinestream-iostdin-allocator-allocator-allocatorheap-item" class="level-3"><a id="pre-conditions-for-macros-stdio-string-readlinestream-iostdin-allocator-allocator-allocatorheap-link" href="#pre-conditions-for-macros-stdio-string-readlinestream-iostdin-allocator-allocator-allocatorheap" class="level-3">String! readline(stream = io::stdin(), Allocator allocator = allocator::heap())</a></li><li id="pre-conditions-for-macros-stdio-void-printx-void-printnx-item" class="level-3"><a id="pre-conditions-for-macros-stdio-void-printx-void-printnx-link" href="#pre-conditions-for-macros-stdio-void-printx-void-printnx" class="level-3">void print(x), void printn(x = “”)</a></li><li id="pre-conditions-for-macros-stdio-listpushlist-list-type-element-append-item" class="level-3"><a id="pre-conditions-for-macros-stdio-listpushlist-list-type-element-append-link" href="#pre-conditions-for-macros-stdio-listpushlist-list-type-element-append" class="level-3">List.push(List *list, Type element), append(…)</a></li><li id="pre-conditions-for-macros-stdio-type-listpoplist-list-item" class="level-3"><a id="pre-conditions-for-macros-stdio-type-listpoplist-list-link" href="#pre-conditions-for-macros-stdio-type-listpoplist-list" class="level-3">Type List.pop(List* list)</a></li><li id="pre-conditions-for-macros-stdio-type-listpop_firstlist-list-item" class="level-3"><a id="pre-conditions-for-macros-stdio-type-listpop_firstlist-list-link" href="#pre-conditions-for-macros-stdio-type-listpop_firstlist-list" class="level-3">Type List.pop_first(List *list)</a></li><li id="pre-conditions-for-macros-stdio-void-listremove_atlist-list-usz-index-item" class="level-3"><a id="pre-conditions-for-macros-stdio-void-listremove_atlist-list-usz-index-link" href="#pre-conditions-for-macros-stdio-void-listremove_atlist-list-usz-index" class="level-3">void List.remove_at(List *list, usz index)</a></li><li id="pre-conditions-for-macros-stdio-void-listinsert_atlist-list-usz-index-type-type-item" class="level-3"><a id="pre-conditions-for-macros-stdio-void-listinsert_atlist-list-usz-index-type-type-link" href="#pre-conditions-for-macros-stdio-void-listinsert_atlist-list-usz-index-type-type" class="level-3">void List.insert_at(List *list, usz index, Type type)</a></li><li id="pre-conditions-for-macros-stdio-void-listpush_frontlist-list-type-type-item" class="level-3"><a id="pre-conditions-for-macros-stdio-void-listpush_frontlist-list-type-type-link" href="#pre-conditions-for-macros-stdio-void-listpush_frontlist-list-type-type" class="level-3">void List.push_front(List *list, Type type)</a></li><li id="pre-conditions-for-macros-stdio-void-listremove_lastlist-list-item" class="level-3"><a id="pre-conditions-for-macros-stdio-void-listremove_lastlist-list-link" href="#pre-conditions-for-macros-stdio-void-listremove_lastlist-list" class="level-3">void List.remove_last(List* list)</a></li><li id="pre-conditions-for-macros-stdio-void-listremove_firstlist-list-item" class="level-3"><a id="pre-conditions-for-macros-stdio-void-listremove_firstlist-list-link" href="#pre-conditions-for-macros-stdio-void-listremove_firstlist-list" class="level-3">void List.remove_first(List *list)</a></li><li id="pre-conditions-for-macros-stdio-type-listfirstlist-list-item" class="level-3"><a id="pre-conditions-for-macros-stdio-type-listfirstlist-list-link" href="#pre-conditions-for-macros-stdio-type-listfirstlist-list" class="level-3">Type List.first(List list)</a></li><li id="pre-conditions-for-macros-stdio-type-listlastlist-list-item" class="level-3"><a id="pre-conditions-for-macros-stdio-type-listlastlist-list-link" href="#pre-conditions-for-macros-stdio-type-listlastlist-list" class="level-3">Type List.last(List list)</a></li><li id="pre-conditions-for-macros-stdio-listis_emptylist-list-item" class="level-3"><a id="pre-conditions-for-macros-stdio-listis_emptylist-list-link" href="#pre-conditions-for-macros-stdio-listis_emptylist-list" class="level-3">List.is_empty(List *list)</a></li><li id="pre-conditions-for-macros-stdio-usz-listlenlist-list-item" class="level-3"><a id="pre-conditions-for-macros-stdio-usz-listlenlist-list-link" href="#pre-conditions-for-macros-stdio-usz-listlenlist-list" class="level-3">usz List.len(List *list)</a></li><li id="pre-conditions-for-macros-stdio-type-listgetlist-list-usz-index-item" class="level-3"><a id="pre-conditions-for-macros-stdio-type-listgetlist-list-usz-index-link" href="#pre-conditions-for-macros-stdio-type-listgetlist-list-usz-index" class="level-3">Type List.get(List *list, usz index)</a></li><li id="pre-conditions-for-macros-stdio-void-listfreelist-list-item" class="level-3"><a id="pre-conditions-for-macros-stdio-void-listfreelist-list-link" href="#pre-conditions-for-macros-stdio-void-listfreelist-list" class="level-3">void List.free(List *list)</a></li><li id="pre-conditions-for-macros-stdio-void-listswaplist-list-usz-i-usz-j-item" class="level-3"><a id="pre-conditions-for-macros-stdio-void-listswaplist-list-usz-i-usz-j-link" href="#pre-conditions-for-macros-stdio-void-listswaplist-list-usz-i-usz-j" class="level-3">void List.swap(List *list, usz i, usz j)</a></li><li id="pre-conditions-for-macros-stdio-libc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-libc-link" href="#pre-conditions-for-macros-stdio-libc" class="level-3">libc</a></li><li id="pre-conditions-for-macros-stdio-libc-ifenvlibc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-libc-ifenvlibc-link" href="#pre-conditions-for-macros-stdio-libc-ifenvlibc" class="level-3">libc @if(!env::LIBC)</a></li><li id="pre-conditions-for-macros-stdio-libc-ifenvdarwin-item" class="level-3"><a id="pre-conditions-for-macros-stdio-libc-ifenvdarwin-link" href="#pre-conditions-for-macros-stdio-libc-ifenvdarwin" class="level-3">libc @if(env::DARWIN)</a></li><li id="pre-conditions-for-macros-stdio-libc-ifenvlibc-envwin32-envlinux-envdarwin-item" class="level-3"><a id="pre-conditions-for-macros-stdio-libc-ifenvlibc-envwin32-envlinux-envdarwin-link" href="#pre-conditions-for-macros-stdio-libc-ifenvlibc-envwin32-envlinux-envdarwin" class="level-3">libc @if(env::LIBC &amp;&amp; !env::WIN32 &amp;&amp; !env::LINUX &amp;&amp; !env::DARWIN)</a></li><li id="pre-conditions-for-macros-stdio-libc-ifenvlinux-item" class="level-3"><a id="pre-conditions-for-macros-stdio-libc-ifenvlinux-link" href="#pre-conditions-for-macros-stdio-libc-ifenvlinux" class="level-3">libc @if(env::LINUX)</a></li><li id="pre-conditions-for-macros-stdio-libc-ifenvposix-item" class="level-3"><a id="pre-conditions-for-macros-stdio-libc-ifenvposix-link" href="#pre-conditions-for-macros-stdio-libc-ifenvposix" class="level-3">libc @if(env::POSIX)</a></li><li id="pre-conditions-for-macros-stdio-libc-ifenvwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-libc-ifenvwin32-link" href="#pre-conditions-for-macros-stdio-libc-ifenvwin32" class="level-3">libc @if(env::WIN32)</a></li><li id="pre-conditions-for-macros-stdio-libcos-item" class="level-3"><a id="pre-conditions-for-macros-stdio-libcos-link" href="#pre-conditions-for-macros-stdio-libcos" class="level-3">libc::os</a></li><li id="pre-conditions-for-macros-stdio-stdascii-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdascii-link" href="#pre-conditions-for-macros-stdio-stdascii" class="level-3">std::ascii</a></li><li id="pre-conditions-for-macros-stdio-stdatomic-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdatomic-link" href="#pre-conditions-for-macros-stdio-stdatomic" class="level-3">std::atomic</a></li><li id="pre-conditions-for-macros-stdio-stdatomictypestype-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdatomictypestype-link" href="#pre-conditions-for-macros-stdio-stdatomictypestype" class="level-3">std::atomic::types(<type>)</type></a></li><li id="pre-conditions-for-macros-stdio-stdbits-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdbits-link" href="#pre-conditions-for-macros-stdio-stdbits" class="level-3">std::bits</a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsanylist-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsanylist-link" href="#pre-conditions-for-macros-stdio-stdcollectionsanylist" class="level-3">std::collections::anylist</a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsbitsetsize-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsbitsetsize-link" href="#pre-conditions-for-macros-stdio-stdcollectionsbitsetsize" class="level-3">std::collections::bitset(<size>)</size></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsenummapenum-valuetype-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsenummapenum-valuetype-link" href="#pre-conditions-for-macros-stdio-stdcollectionsenummapenum-valuetype" class="level-3">std::collections::enummap(<enum, valuetype="">)</enum,></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsenumsetenum-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsenumsetenum-link" href="#pre-conditions-for-macros-stdio-stdcollectionsenumsetenum" class="level-3">std::collections::enumset(<enum>)</enum></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsenumsetprivate-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsenumsetprivate-link" href="#pre-conditions-for-macros-stdio-stdcollectionsenumsetprivate" class="level-3">std::collections::enumset::private</a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsgrowablebitsettype-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsgrowablebitsettype-link" href="#pre-conditions-for-macros-stdio-stdcollectionsgrowablebitsettype" class="level-3">std::collections::growablebitset(<type>)</type></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionslinkedlisttype-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionslinkedlisttype-link" href="#pre-conditions-for-macros-stdio-stdcollectionslinkedlisttype" class="level-3">std::collections::linkedlist(<type>)</type></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionslisttype-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionslisttype-link" href="#pre-conditions-for-macros-stdio-stdcollectionslisttype" class="level-3">std::collections::list(<type>)</type></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsmapkey-value-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsmapkey-value-link" href="#pre-conditions-for-macros-stdio-stdcollectionsmapkey-value" class="level-3">std::collections::map(<key, value="">)</key,></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsmaybetype-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsmaybetype-link" href="#pre-conditions-for-macros-stdio-stdcollectionsmaybetype" class="level-3">std::collections::maybe(<type>)</type></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsobject-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsobject-link" href="#pre-conditions-for-macros-stdio-stdcollectionsobject" class="level-3">std::collections::object</a></li><li id="pre-conditions-for-macros-stdio-stdcollectionspriorityqueuetype-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionspriorityqueuetype-link" href="#pre-conditions-for-macros-stdio-stdcollectionspriorityqueuetype" class="level-3">std::collections::priorityqueue(<type>)</type></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionspriorityqueueprivatetype-max-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionspriorityqueueprivatetype-max-link" href="#pre-conditions-for-macros-stdio-stdcollectionspriorityqueueprivatetype-max" class="level-3">std::collections::priorityqueue::private(<type, max="">)</type,></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsrangetype-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsrangetype-link" href="#pre-conditions-for-macros-stdio-stdcollectionsrangetype" class="level-3">std::collections::range(<type>)</type></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionsringbuffertype-size-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionsringbuffertype-size-link" href="#pre-conditions-for-macros-stdio-stdcollectionsringbuffertype-size" class="level-3">std::collections::ringbuffer(<type, size="">)</type,></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionstripletype1-type2-type3-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionstripletype1-type2-type3-link" href="#pre-conditions-for-macros-stdio-stdcollectionstripletype1-type2-type3" class="level-3">std::collections::triple(<type1, type2,="" type3="">)</type1,></a></li><li id="pre-conditions-for-macros-stdio-stdcollectionstupletype1-type2-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcollectionstupletype1-type2-link" href="#pre-conditions-for-macros-stdio-stdcollectionstupletype1-type2" class="level-3">std::collections::tuple(<type1, type2="">)</type1,></a></li><li id="pre-conditions-for-macros-stdio-stdcorearray-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorearray-link" href="#pre-conditions-for-macros-stdio-stdcorearray" class="level-3">std::core::array</a></li><li id="pre-conditions-for-macros-stdio-stdcorearrayslicetype-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorearrayslicetype-link" href="#pre-conditions-for-macros-stdio-stdcorearrayslicetype" class="level-3">std::core::array::slice(<type>)</type></a></li><li id="pre-conditions-for-macros-stdio-stdcorebitorder-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorebitorder-link" href="#pre-conditions-for-macros-stdio-stdcorebitorder" class="level-3">std::core::bitorder</a></li><li id="pre-conditions-for-macros-stdio-stdcorebuiltin-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorebuiltin-link" href="#pre-conditions-for-macros-stdio-stdcorebuiltin" class="level-3">std::core::builtin</a></li><li id="pre-conditions-for-macros-stdio-stdcorebuiltin-ifenvlinux-envdarwin-envcompiler_safe_mode-envdebug_symbols-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorebuiltin-ifenvlinux-envdarwin-envcompiler_safe_mode-envdebug_symbols-link" href="#pre-conditions-for-macros-stdio-stdcorebuiltin-ifenvlinux-envdarwin-envcompiler_safe_mode-envdebug_symbols" class="level-3">std::core::builtin @if((env::LINUX || env::DARWIN) &amp;&amp; env::COMPILER_SAFE_MODE &amp;&amp; env::DEBUG_SYMBOLS)</a></li><li id="pre-conditions-for-macros-stdio-stdcoredstring-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcoredstring-link" href="#pre-conditions-for-macros-stdio-stdcoredstring" class="level-3">std::core::dstring</a></li><li id="pre-conditions-for-macros-stdio-stdcoreenv-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcoreenv-link" href="#pre-conditions-for-macros-stdio-stdcoreenv" class="level-3">std::core::env</a></li><li id="pre-conditions-for-macros-stdio-stdcoremem-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcoremem-link" href="#pre-conditions-for-macros-stdio-stdcoremem" class="level-3">std::core::mem</a></li><li id="pre-conditions-for-macros-stdio-stdcorememallocator-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorememallocator-link" href="#pre-conditions-for-macros-stdio-stdcorememallocator" class="level-3">std::core::mem::allocator</a></li><li id="pre-conditions-for-macros-stdio-stdcorememallocator-ifenvwin32-envposix-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorememallocator-ifenvwin32-envposix-link" href="#pre-conditions-for-macros-stdio-stdcorememallocator-ifenvwin32-envposix" class="level-3">std::core::mem::allocator @if(!env::WIN32 &amp;&amp; !env::POSIX)</a></li><li id="pre-conditions-for-macros-stdio-stdcorememallocator-ifenvposix-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorememallocator-ifenvposix-link" href="#pre-conditions-for-macros-stdio-stdcorememallocator-ifenvposix" class="level-3">std::core::mem::allocator @if(env::POSIX)</a></li><li id="pre-conditions-for-macros-stdio-stdcorememallocator-ifenvwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorememallocator-ifenvwin32-link" href="#pre-conditions-for-macros-stdio-stdcorememallocator-ifenvwin32" class="level-3">std::core::mem::allocator @if(env::WIN32)</a></li><li id="pre-conditions-for-macros-stdio-stdcoreruntime-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcoreruntime-link" href="#pre-conditions-for-macros-stdio-stdcoreruntime" class="level-3">std::core::runtime</a></li><li id="pre-conditions-for-macros-stdio-stdcoreruntime-ifwasm_nolibc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcoreruntime-ifwasm_nolibc-link" href="#pre-conditions-for-macros-stdio-stdcoreruntime-ifwasm_nolibc" class="level-3">std::core::runtime @if(WASM_NOLIBC)</a></li><li id="pre-conditions-for-macros-stdio-stdcorestring-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorestring-link" href="#pre-conditions-for-macros-stdio-stdcorestring" class="level-3">std::core::string</a></li><li id="pre-conditions-for-macros-stdio-stdcorestringconv-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorestringconv-link" href="#pre-conditions-for-macros-stdio-stdcorestringconv" class="level-3">std::core::string::conv</a></li><li id="pre-conditions-for-macros-stdio-stdcorestringiterator-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorestringiterator-link" href="#pre-conditions-for-macros-stdio-stdcorestringiterator" class="level-3">std::core::string::iterator</a></li><li id="pre-conditions-for-macros-stdio-stdcoretypes-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcoretypes-link" href="#pre-conditions-for-macros-stdio-stdcoretypes" class="level-3">std::core::types</a></li><li id="pre-conditions-for-macros-stdio-stdcorevalues-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcorevalues-link" href="#pre-conditions-for-macros-stdio-stdcorevalues" class="level-3">std::core::values</a></li><li id="pre-conditions-for-macros-stdio-stdcryptorc4-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdcryptorc4-link" href="#pre-conditions-for-macros-stdio-stdcryptorc4" class="level-3">std::crypto::rc4</a></li><li id="pre-conditions-for-macros-stdio-stdencodingbase64-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdencodingbase64-link" href="#pre-conditions-for-macros-stdio-stdencodingbase64" class="level-3">std::encoding::base64</a></li><li id="pre-conditions-for-macros-stdio-stdencodingcsv-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdencodingcsv-link" href="#pre-conditions-for-macros-stdio-stdencodingcsv" class="level-3">std::encoding::csv</a></li><li id="pre-conditions-for-macros-stdio-stdencodingjson-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdencodingjson-link" href="#pre-conditions-for-macros-stdio-stdencodingjson" class="level-3">std::encoding::json</a></li><li id="pre-conditions-for-macros-stdio-stdhashadler32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdhashadler32-link" href="#pre-conditions-for-macros-stdio-stdhashadler32" class="level-3">std::hash::adler32</a></li><li id="pre-conditions-for-macros-stdio-stdhashcrc32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdhashcrc32-link" href="#pre-conditions-for-macros-stdio-stdhashcrc32" class="level-3">std::hash::crc32</a></li><li id="pre-conditions-for-macros-stdio-stdhashcrc64-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdhashcrc64-link" href="#pre-conditions-for-macros-stdio-stdhashcrc64" class="level-3">std::hash::crc64</a></li><li id="pre-conditions-for-macros-stdio-stdhashfnv32a-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdhashfnv32a-link" href="#pre-conditions-for-macros-stdio-stdhashfnv32a" class="level-3">std::hash::fnv32a</a></li><li id="pre-conditions-for-macros-stdio-stdhashfnv64a-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdhashfnv64a-link" href="#pre-conditions-for-macros-stdio-stdhashfnv64a" class="level-3">std::hash::fnv64a</a></li><li id="pre-conditions-for-macros-stdio-stdhashsha1-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdhashsha1-link" href="#pre-conditions-for-macros-stdio-stdhashsha1" class="level-3">std::hash::sha1</a></li><li id="pre-conditions-for-macros-stdio-stdio-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdio-link" href="#pre-conditions-for-macros-stdio-stdio" class="level-3">std::io</a></li><li id="pre-conditions-for-macros-stdio-stdio-if-envlibc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdio-if-envlibc-link" href="#pre-conditions-for-macros-stdio-stdio-if-envlibc" class="level-3">std::io @if (env::LIBC)</a></li><li id="pre-conditions-for-macros-stdio-stdio-ifenvlibc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdio-ifenvlibc-link" href="#pre-conditions-for-macros-stdio-stdio-ifenvlibc" class="level-3">std::io @if(!env::LIBC)</a></li><li id="pre-conditions-for-macros-stdio-stdiofile-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdiofile-link" href="#pre-conditions-for-macros-stdio-stdiofile" class="level-3">std::io::file</a></li><li id="pre-conditions-for-macros-stdio-stdioos-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdioos-link" href="#pre-conditions-for-macros-stdio-stdioos" class="level-3">std::io::os</a></li><li id="pre-conditions-for-macros-stdio-stdioos-ifenvlibc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdioos-ifenvlibc-link" href="#pre-conditions-for-macros-stdio-stdioos-ifenvlibc" class="level-3">std::io::os @if(env::LIBC)</a></li><li id="pre-conditions-for-macros-stdio-stdioos-ifenvno_libc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdioos-ifenvno_libc-link" href="#pre-conditions-for-macros-stdio-stdioos-ifenvno_libc" class="level-3">std::io::os @if(env::NO_LIBC)</a></li><li id="pre-conditions-for-macros-stdio-stdioos-ifenvposix-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdioos-ifenvposix-link" href="#pre-conditions-for-macros-stdio-stdioos-ifenvposix" class="level-3">std::io::os @if(env::POSIX)</a></li><li id="pre-conditions-for-macros-stdio-stdioos-ifenvwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdioos-ifenvwin32-link" href="#pre-conditions-for-macros-stdio-stdioos-ifenvwin32" class="level-3">std::io::os @if(env::WIN32)</a></li><li id="pre-conditions-for-macros-stdio-stdiopath-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdiopath-link" href="#pre-conditions-for-macros-stdio-stdiopath" class="level-3">std::io::path</a></li><li id="pre-conditions-for-macros-stdio-stdmath-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdmath-link" href="#pre-conditions-for-macros-stdio-stdmath" class="level-3">std::math</a></li><li id="pre-conditions-for-macros-stdio-stdmathcomplexreal-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdmathcomplexreal-link" href="#pre-conditions-for-macros-stdio-stdmathcomplexreal" class="level-3">std::math::complex(<real>)</real></a></li><li id="pre-conditions-for-macros-stdio-stdmatheasing-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdmatheasing-link" href="#pre-conditions-for-macros-stdio-stdmatheasing" class="level-3">std::math::easing</a></li><li id="pre-conditions-for-macros-stdio-stdmathmatrixreal-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdmathmatrixreal-link" href="#pre-conditions-for-macros-stdio-stdmathmatrixreal" class="level-3">std::math::matrix(<real>)</real></a></li><li id="pre-conditions-for-macros-stdio-stdmathnolibc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdmathnolibc-link" href="#pre-conditions-for-macros-stdio-stdmathnolibc" class="level-3">std::math::nolibc</a></li><li id="pre-conditions-for-macros-stdio-stdmathnolibc-ifenvno_libc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdmathnolibc-ifenvno_libc-link" href="#pre-conditions-for-macros-stdio-stdmathnolibc-ifenvno_libc" class="level-3">std::math::nolibc @if(env::NO_LIBC)</a></li><li id="pre-conditions-for-macros-stdio-stdmathquaternionreal-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdmathquaternionreal-link" href="#pre-conditions-for-macros-stdio-stdmathquaternionreal" class="level-3">std::math::quaternion(<real>)</real></a></li><li id="pre-conditions-for-macros-stdio-stdmathrandom-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdmathrandom-link" href="#pre-conditions-for-macros-stdio-stdmathrandom" class="level-3">std::math::random</a></li><li id="pre-conditions-for-macros-stdio-stdmathvector-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdmathvector-link" href="#pre-conditions-for-macros-stdio-stdmathvector" class="level-3">std::math::vector</a></li><li id="pre-conditions-for-macros-stdio-stdnet-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdnet-link" href="#pre-conditions-for-macros-stdio-stdnet" class="level-3">std::net</a></li><li id="pre-conditions-for-macros-stdio-stdnet-ifossupports_inet-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdnet-ifossupports_inet-link" href="#pre-conditions-for-macros-stdio-stdnet-ifossupports_inet" class="level-3">std::net @if(os::SUPPORTS_INET)</a></li><li id="pre-conditions-for-macros-stdio-stdnetos-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdnetos-link" href="#pre-conditions-for-macros-stdio-stdnetos" class="level-3">std::net::os</a></li><li id="pre-conditions-for-macros-stdio-stdnetos-ifenvposix-supports_inet-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdnetos-ifenvposix-supports_inet-link" href="#pre-conditions-for-macros-stdio-stdnetos-ifenvposix-supports_inet" class="level-3">std::net::os @if(env::POSIX &amp;&amp; SUPPORTS_INET)</a></li><li id="pre-conditions-for-macros-stdio-stdnetos-ifenvwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdnetos-ifenvwin32-link" href="#pre-conditions-for-macros-stdio-stdnetos-ifenvwin32" class="level-3">std::net::os @if(env::WIN32)</a></li><li id="pre-conditions-for-macros-stdio-stdnettcp-ifossupports_inet-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdnettcp-ifossupports_inet-link" href="#pre-conditions-for-macros-stdio-stdnettcp-ifossupports_inet" class="level-3">std::net::tcp @if(os::SUPPORTS_INET)</a></li><li id="pre-conditions-for-macros-stdio-stdnetudp-ifossupports_inet-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdnetudp-ifossupports_inet-link" href="#pre-conditions-for-macros-stdio-stdnetudp-ifossupports_inet" class="level-3">std::net::udp @if(os::SUPPORTS_INET)</a></li><li id="pre-conditions-for-macros-stdio-stdos-ifenvdarwin-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdos-ifenvdarwin-link" href="#pre-conditions-for-macros-stdio-stdos-ifenvdarwin" class="level-3">std::os @if(env::DARWIN)</a></li><li id="pre-conditions-for-macros-stdio-stdos-ifenvlinux-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdos-ifenvlinux-link" href="#pre-conditions-for-macros-stdio-stdos-ifenvlinux" class="level-3">std::os @if(env::LINUX)</a></li><li id="pre-conditions-for-macros-stdio-stdos-ifenvwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdos-ifenvwin32-link" href="#pre-conditions-for-macros-stdio-stdos-ifenvwin32" class="level-3">std::os @if(env::WIN32)</a></li><li id="pre-conditions-for-macros-stdio-stdosbacktrace-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdosbacktrace-link" href="#pre-conditions-for-macros-stdio-stdosbacktrace" class="level-3">std::os::backtrace</a></li><li id="pre-conditions-for-macros-stdio-stdosdarwin-ifenvdarwin-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdosdarwin-ifenvdarwin-link" href="#pre-conditions-for-macros-stdio-stdosdarwin-ifenvdarwin" class="level-3">std::os::darwin @if(env::DARWIN)</a></li><li id="pre-conditions-for-macros-stdio-stdosenv-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdosenv-link" href="#pre-conditions-for-macros-stdio-stdosenv" class="level-3">std::os::env</a></li><li id="pre-conditions-for-macros-stdio-stdoslinux-ifenvlinux-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdoslinux-ifenvlinux-link" href="#pre-conditions-for-macros-stdio-stdoslinux-ifenvlinux" class="level-3">std::os::linux @if(env::LINUX)</a></li><li id="pre-conditions-for-macros-stdio-stdosmacoscf-ifenvdarwin-linkenvdarwin-corefoundationframework-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdosmacoscf-ifenvdarwin-linkenvdarwin-corefoundationframework-link" href="#pre-conditions-for-macros-stdio-stdosmacoscf-ifenvdarwin-linkenvdarwin-corefoundationframework" class="level-3">std::os::macos::cf @if(env::DARWIN) @link(env::DARWIN, “CoreFoundation.framework”)</a></li><li id="pre-conditions-for-macros-stdio-stdosmacosobjc-ifenvdarwin-linkenvdarwin-corefoundationframework-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdosmacosobjc-ifenvdarwin-linkenvdarwin-corefoundationframework-link" href="#pre-conditions-for-macros-stdio-stdosmacosobjc-ifenvdarwin-linkenvdarwin-corefoundationframework" class="level-3">std::os::macos::objc @if(env::DARWIN) @link(env::DARWIN, “CoreFoundation.framework”)</a></li><li id="pre-conditions-for-macros-stdio-stdosposix-ifenvposix-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdosposix-ifenvposix-link" href="#pre-conditions-for-macros-stdio-stdosposix-ifenvposix" class="level-3">std::os::posix @if(env::POSIX)</a></li><li id="pre-conditions-for-macros-stdio-stdosprocess-ifenvwin32-envposix-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdosprocess-ifenvwin32-envposix-link" href="#pre-conditions-for-macros-stdio-stdosprocess-ifenvwin32-envposix" class="level-3">std::os::process @if(env::WIN32 || env::POSIX)</a></li><li id="pre-conditions-for-macros-stdio-stdoswin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdoswin32-link" href="#pre-conditions-for-macros-stdio-stdoswin32" class="level-3">std::os::win32</a></li><li id="pre-conditions-for-macros-stdio-stdoswin32-ifenvwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdoswin32-ifenvwin32-link" href="#pre-conditions-for-macros-stdio-stdoswin32-ifenvwin32" class="level-3">std::os::win32 @if(env::WIN32)</a></li><li id="pre-conditions-for-macros-stdio-stdsort-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdsort-link" href="#pre-conditions-for-macros-stdio-stdsort" class="level-3">std::sort</a></li><li id="pre-conditions-for-macros-stdio-stdsortqstype-comparer-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdsortqstype-comparer-link" href="#pre-conditions-for-macros-stdio-stdsortqstype-comparer" class="level-3">std::sort::qs(<type, comparer="">)</type,></a></li><li id="pre-conditions-for-macros-stdio-stdthread-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthread-link" href="#pre-conditions-for-macros-stdio-stdthread" class="level-3">std::thread</a></li><li id="pre-conditions-for-macros-stdio-stdthreadcpu-ifenvdarwin-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthreadcpu-ifenvdarwin-link" href="#pre-conditions-for-macros-stdio-stdthreadcpu-ifenvdarwin" class="level-3">std::thread::cpu @if(env::DARWIN)</a></li><li id="pre-conditions-for-macros-stdio-stdthreadcpu-ifenvlinux-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthreadcpu-ifenvlinux-link" href="#pre-conditions-for-macros-stdio-stdthreadcpu-ifenvlinux" class="level-3">std::thread::cpu @if(env::LINUX)</a></li><li id="pre-conditions-for-macros-stdio-stdthreadcpu-ifenvwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthreadcpu-ifenvwin32-link" href="#pre-conditions-for-macros-stdio-stdthreadcpu-ifenvwin32" class="level-3">std::thread::cpu @if(env::WIN32)</a></li><li id="pre-conditions-for-macros-stdio-stdthreados-if-envposix-envwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthreados-if-envposix-envwin32-link" href="#pre-conditions-for-macros-stdio-stdthreados-if-envposix-envwin32" class="level-3">std::thread::os @if (!env::POSIX &amp;&amp; !env::WIN32)</a></li><li id="pre-conditions-for-macros-stdio-stdthreados-ifenvlinux-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthreados-ifenvlinux-link" href="#pre-conditions-for-macros-stdio-stdthreados-ifenvlinux" class="level-3">std::thread::os @if(env::LINUX)</a></li><li id="pre-conditions-for-macros-stdio-stdthreados-ifenvposix-envlinux-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthreados-ifenvposix-envlinux-link" href="#pre-conditions-for-macros-stdio-stdthreados-ifenvposix-envlinux" class="level-3">std::thread::os @if(env::POSIX &amp;&amp; !env::LINUX)</a></li><li id="pre-conditions-for-macros-stdio-stdthreados-ifenvposix-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthreados-ifenvposix-link" href="#pre-conditions-for-macros-stdio-stdthreados-ifenvposix" class="level-3">std::thread::os @if(env::POSIX)</a></li><li id="pre-conditions-for-macros-stdio-stdthreados-ifenvwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthreados-ifenvwin32-link" href="#pre-conditions-for-macros-stdio-stdthreados-ifenvwin32" class="level-3">std::thread::os @if(env::WIN32)</a></li><li id="pre-conditions-for-macros-stdio-stdthreadpoolsize-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdthreadpoolsize-link" href="#pre-conditions-for-macros-stdio-stdthreadpoolsize" class="level-3">std::thread::pool(<size>)</size></a></li><li id="pre-conditions-for-macros-stdio-stdtime-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdtime-link" href="#pre-conditions-for-macros-stdio-stdtime" class="level-3">std::time</a></li><li id="pre-conditions-for-macros-stdio-stdtimeclock-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdtimeclock-link" href="#pre-conditions-for-macros-stdio-stdtimeclock" class="level-3">std::time::clock</a></li><li id="pre-conditions-for-macros-stdio-stdtimedatetime-ifenvlibc-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdtimedatetime-ifenvlibc-link" href="#pre-conditions-for-macros-stdio-stdtimedatetime-ifenvlibc" class="level-3">std::time::datetime @if(env::LIBC)</a></li><li id="pre-conditions-for-macros-stdio-stdtimeos-ifenvdarwin-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdtimeos-ifenvdarwin-link" href="#pre-conditions-for-macros-stdio-stdtimeos-ifenvdarwin" class="level-3">std::time::os @if(env::DARWIN)</a></li><li id="pre-conditions-for-macros-stdio-stdtimeos-ifenvposix-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdtimeos-ifenvposix-link" href="#pre-conditions-for-macros-stdio-stdtimeos-ifenvposix" class="level-3">std::time::os @if(env::POSIX)</a></li><li id="pre-conditions-for-macros-stdio-stdtimeos-ifenvwin32-item" class="level-3"><a id="pre-conditions-for-macros-stdio-stdtimeos-ifenvwin32-link" href="#pre-conditions-for-macros-stdio-stdtimeos-ifenvwin32" class="level-3">std::time::os @if(env::WIN32)</a></li></ul></li><li id="pre-conditions-for-macros-conversion-rules-for-c3-item" class="level-2"><a id="pre-conditions-for-macros-conversion-rules-for-c3-link" href="#pre-conditions-for-macros-conversion-rules-for-c3" class="level-2">Conversion Rules For C3</a><ul class="level-3" id="pre-conditions-for-macros-conversion-rules-for-c3-list"><li id="pre-conditions-for-macros-conversion-rules-for-c3-target-type-item" class="level-3"><a id="pre-conditions-for-macros-conversion-rules-for-c3-target-type-link" href="#pre-conditions-for-macros-conversion-rules-for-c3-target-type" class="level-3">Target type</a></li><li id="pre-conditions-for-macros-conversion-rules-for-c3-common-arithmetic-promotion-item" class="level-3"><a id="pre-conditions-for-macros-conversion-rules-for-c3-common-arithmetic-promotion-link" href="#pre-conditions-for-macros-conversion-rules-for-c3-common-arithmetic-promotion" class="level-3">Common arithmetic promotion</a></li><li id="pre-conditions-for-macros-conversion-rules-for-c3-implicit-narrowing-item" class="level-3"><a id="pre-conditions-for-macros-conversion-rules-for-c3-implicit-narrowing-link" href="#pre-conditions-for-macros-conversion-rules-for-c3-implicit-narrowing" class="level-3">Implicit narrowing</a></li><li id="pre-conditions-for-macros-conversion-rules-for-c3-implicit-widening-item" class="level-3"><a id="pre-conditions-for-macros-conversion-rules-for-c3-implicit-widening-link" href="#pre-conditions-for-macros-conversion-rules-for-c3-implicit-widening" class="level-3">Implicit widening</a></li><li id="pre-conditions-for-macros-conversion-rules-for-c3-maximum-type-item" class="level-3"><a id="pre-conditions-for-macros-conversion-rules-for-c3-maximum-type-link" href="#pre-conditions-for-macros-conversion-rules-for-c3-maximum-type" class="level-3">Maximum type</a></li><li id="pre-conditions-for-macros-conversion-rules-for-c3-substruct-conversions-item" class="level-3"><a id="pre-conditions-for-macros-conversion-rules-for-c3-substruct-conversions-link" href="#pre-conditions-for-macros-conversion-rules-for-c3-substruct-conversions" class="level-3">Substruct conversions</a></li><li id="pre-conditions-for-macros-conversion-rules-for-c3-pointer-conversions-item" class="level-3"><a id="pre-conditions-for-macros-conversion-rules-for-c3-pointer-conversions-link" href="#pre-conditions-for-macros-conversion-rules-for-c3-pointer-conversions" class="level-3">Pointer conversions</a></li><li id="pre-conditions-for-macros-conversion-rules-for-c3-vector-conversions-item" class="level-3"><a id="pre-conditions-for-macros-conversion-rules-for-c3-vector-conversions-link" href="#pre-conditions-for-macros-conversion-rules-for-c3-vector-conversions" class="level-3">Vector conversions</a></li></ul></li><li id="pre-conditions-for-macros-binary-conversions-item" class="level-2"><a id="pre-conditions-for-macros-binary-conversions-link" href="#pre-conditions-for-macros-binary-conversions" class="level-2">Binary conversions</a></li><li id="pre-conditions-for-macros-unary-conversions-item" class="level-2"><a id="pre-conditions-for-macros-unary-conversions-link" href="#pre-conditions-for-macros-unary-conversions" class="level-2">Unary conversions</a></li><li id="pre-conditions-for-macros-base-expressions-item" class="level-2"><a id="pre-conditions-for-macros-base-expressions-link" href="#pre-conditions-for-macros-base-expressions" class="level-2">Base expressions</a></li><li id="pre-conditions-for-macros-list-of-undefined-behaviours-item" class="level-2"><a id="pre-conditions-for-macros-list-of-undefined-behaviours-link" href="#pre-conditions-for-macros-list-of-undefined-behaviours" class="level-2">List of undefined behaviours</a></li><li id="pre-conditions-for-macros-list-of-implementation-dependent-behaviours-item" class="level-2"><a id="pre-conditions-for-macros-list-of-implementation-dependent-behaviours-link" href="#pre-conditions-for-macros-list-of-implementation-dependent-behaviours" class="level-2">List of implementation dependent behaviours</a></li><li id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-item" class="level-2"><a id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-link" href="#pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3" class="level-2">List of undefined behaviour in C, which is defined in C3</a><ul class="level-3" id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-list"><li id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-signed-integer-overflow-item" class="level-3"><a id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-signed-integer-overflow-link" href="#pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-signed-integer-overflow" class="level-3">Signed Integer Overflow</a></li><li id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-modifying-the-intermediate-results-of-an-expression-item" class="level-3"><a id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-modifying-the-intermediate-results-of-an-expression-link" href="#pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-modifying-the-intermediate-results-of-an-expression" class="level-3">Modifying the intermediate results of an expression</a></li></ul></li><li id="pre-conditions-for-macros-builtin-constants-item" class="level-2"><a id="pre-conditions-for-macros-builtin-constants-link" href="#pre-conditions-for-macros-builtin-constants" class="level-2">Builtin constants</a></li><li id="pre-conditions-for-macros-compiler-builtin-functions-item" class="level-2"><a id="pre-conditions-for-macros-compiler-builtin-functions-link" href="#pre-conditions-for-macros-compiler-builtin-functions" class="level-2">Compiler builtin functions</a><ul class="level-3" id="pre-conditions-for-macros-compiler-builtin-functions-list"><li id="pre-conditions-for-macros-compiler-builtin-functions-math-functions-item" class="level-3"><a id="pre-conditions-for-macros-compiler-builtin-functions-math-functions-link" href="#pre-conditions-for-macros-compiler-builtin-functions-math-functions" class="level-3">Math functions</a></li><li id="pre-conditions-for-macros-compiler-builtin-functions-bit-functions-item" class="level-3"><a id="pre-conditions-for-macros-compiler-builtin-functions-bit-functions-link" href="#pre-conditions-for-macros-compiler-builtin-functions-bit-functions" class="level-3">Bit functions</a></li><li id="pre-conditions-for-macros-compiler-builtin-functions-vector-functions-item" class="level-3"><a id="pre-conditions-for-macros-compiler-builtin-functions-vector-functions-link" href="#pre-conditions-for-macros-compiler-builtin-functions-vector-functions" class="level-3">Vector functions</a></li></ul></li><li id="pre-conditions-for-macros-how-it-works-item" class="level-2"><a id="pre-conditions-for-macros-how-it-works-link" href="#pre-conditions-for-macros-how-it-works" class="level-2">How it works</a><ul class="level-3" id="pre-conditions-for-macros-how-it-works-list"><li id="pre-conditions-for-macros-how-it-works-the-specification-item" class="level-3"><a id="pre-conditions-for-macros-how-it-works-the-specification-link" href="#pre-conditions-for-macros-how-it-works-the-specification" class="level-3">The specification</a></li><li id="pre-conditions-for-macros-how-it-works-source-code-item" class="level-3"><a id="pre-conditions-for-macros-how-it-works-source-code-link" href="#pre-conditions-for-macros-how-it-works-source-code" class="level-3">Source code</a></li><li id="pre-conditions-for-macros-how-it-works-additional-actions-item" class="level-3"><a id="pre-conditions-for-macros-how-it-works-additional-actions-link" href="#pre-conditions-for-macros-how-it-works-additional-actions" class="level-3">Additional actions</a></li></ul></li><li id="pre-conditions-for-macros-how-to-automatically-export-libraries-item" class="level-2"><a id="pre-conditions-for-macros-how-to-automatically-export-libraries-link" href="#pre-conditions-for-macros-how-to-automatically-export-libraries" class="level-2">How to – automatically – export libraries</a></li><li id="pre-conditions-for-macros-asm-strings-item" class="level-2"><a id="pre-conditions-for-macros-asm-strings-link" href="#pre-conditions-for-macros-asm-strings" class="level-2">Asm strings</a></li><li id="pre-conditions-for-macros-asm-block-item" class="level-2"><a id="pre-conditions-for-macros-asm-block-link" href="#pre-conditions-for-macros-asm-block" class="level-2">Asm block</a></li><li id="pre-conditions-for-macros-compile-individual-files-item" class="level-2"><a id="pre-conditions-for-macros-compile-individual-files-link" href="#pre-conditions-for-macros-compile-individual-files" class="level-2">Compile Individual Files</a></li><li id="pre-conditions-for-macros-run-item" class="level-2"><a id="pre-conditions-for-macros-run-link" href="#pre-conditions-for-macros-run" class="level-2">Run</a></li><li id="pre-conditions-for-macros-common-additional-parameters-item" class="level-2"><a id="pre-conditions-for-macros-common-additional-parameters-link" href="#pre-conditions-for-macros-common-additional-parameters" class="level-2">Common additional parameters</a></li><li id="pre-conditions-for-macros-init-a-new-project-item" class="level-2"><a id="pre-conditions-for-macros-init-a-new-project-link" href="#pre-conditions-for-macros-init-a-new-project" class="level-2">Init a new project</a></li><li id="pre-conditions-for-macros-test-item" class="level-2"><a id="pre-conditions-for-macros-test-link" href="#pre-conditions-for-macros-test" class="level-2">Test</a></li><li id="pre-conditions-for-macros-build-item" class="level-2"><a id="pre-conditions-for-macros-build-link" href="#pre-conditions-for-macros-build" class="level-2">Build</a></li><li id="pre-conditions-for-macros-clean-item" class="level-2"><a id="pre-conditions-for-macros-clean-link" href="#pre-conditions-for-macros-clean" class="level-2">Clean</a></li><li id="pre-conditions-for-macros-build-and-run-item" class="level-2"><a id="pre-conditions-for-macros-build-and-run-link" href="#pre-conditions-for-macros-build-and-run" class="level-2">Build and Run</a></li><li id="pre-conditions-for-macros-clean-and-run-item" class="level-2"><a id="pre-conditions-for-macros-clean-and-run-link" href="#pre-conditions-for-macros-clean-and-run" class="level-2">Clean and Run</a></li><li id="pre-conditions-for-macros-dist-item" class="level-2"><a id="pre-conditions-for-macros-dist-link" href="#pre-conditions-for-macros-dist" class="level-2">Dist</a></li><li id="pre-conditions-for-macros-docs-item" class="level-2"><a id="pre-conditions-for-macros-docs-link" href="#pre-conditions-for-macros-docs" class="level-2">Docs</a></li><li id="pre-conditions-for-macros-bench-item" class="level-2"><a id="pre-conditions-for-macros-bench-link" href="#pre-conditions-for-macros-bench" class="level-2">Bench</a></li></ul></li><li id="customizing-a-project-item" class="level-1"><a id="customizing-a-project-link" href="#customizing-a-project" class="level-1">Customizing A Project</a><ul class="level-2" id="customizing-a-project-list"><li id="customizing-a-project-compilation-options-item" class="level-2"><a id="customizing-a-project-compilation-options-link" href="#customizing-a-project-compilation-options" class="level-2">Compilation options</a></li><li id="customizing-a-project-target-options-item" class="level-2"><a id="customizing-a-project-target-options-link" href="#customizing-a-project-target-options" class="level-2">Target options</a></li><li id="customizing-a-project-using-environment-variables-item" class="level-2"><a id="customizing-a-project-using-environment-variables-link" href="#customizing-a-project-using-environment-variables" class="level-2">Using environment variables</a></li><li id="customizing-a-project-standard-library-item" class="level-2"><a id="customizing-a-project-standard-library-link" href="#customizing-a-project-standard-library" class="level-2">Standard library</a></li><li id="customizing-a-project-language-features-item" class="level-2"><a id="customizing-a-project-language-features-link" href="#customizing-a-project-language-features" class="level-2">Language features</a></li><li id="customizing-a-project-memory-management-item" class="level-2"><a id="customizing-a-project-memory-management-link" href="#customizing-a-project-memory-management" class="level-2">Memory management</a></li><li id="customizing-a-project-interfacing-with-c-code-item" class="level-2"><a id="customizing-a-project-interfacing-with-c-code-link" href="#customizing-a-project-interfacing-with-c-code" class="level-2">Interfacing with C code</a></li><li id="customizing-a-project-patterns-item" class="level-2"><a id="customizing-a-project-patterns-link" href="#customizing-a-project-patterns" class="level-2">Patterns</a></li><li id="customizing-a-project-platform-support-item" class="level-2"><a id="customizing-a-project-platform-support-link" href="#customizing-a-project-platform-support" class="level-2">Platform support</a></li><li id="customizing-a-project-syntax-language-design-item" class="level-2"><a id="customizing-a-project-syntax-language-design-link" href="#customizing-a-project-syntax-language-design" class="level-2">Syntax &amp; Language design</a></li><li id="customizing-a-project-symbols-and-literals-item" class="level-2"><a id="customizing-a-project-symbols-and-literals-link" href="#customizing-a-project-symbols-and-literals" class="level-2">Symbols and literals</a><ul class="level-3" id="customizing-a-project-symbols-and-literals-list"><li id="customizing-a-project-symbols-and-literals-added-item" class="level-3"><a id="customizing-a-project-symbols-and-literals-added-link" href="#customizing-a-project-symbols-and-literals-added" class="level-3">Added</a></li><li id="customizing-a-project-symbols-and-literals-removed-item" class="level-3"><a id="customizing-a-project-symbols-and-literals-removed-link" href="#customizing-a-project-symbols-and-literals-removed" class="level-3">Removed</a></li></ul></li><li id="customizing-a-project-built-in-types-item" class="level-2"><a id="customizing-a-project-built-in-types-link" href="#customizing-a-project-built-in-types" class="level-2">Built-in types</a><ul class="level-3" id="customizing-a-project-built-in-types-list"><li id="customizing-a-project-built-in-types-added-item" class="level-3"><a id="customizing-a-project-built-in-types-added-link" href="#customizing-a-project-built-in-types-added" class="level-3">Added</a></li><li id="customizing-a-project-built-in-types-changed-item" class="level-3"><a id="customizing-a-project-built-in-types-changed-link" href="#customizing-a-project-built-in-types-changed" class="level-3">Changed</a></li><li id="customizing-a-project-built-in-types-removed-item" class="level-3"><a id="customizing-a-project-built-in-types-removed-link" href="#customizing-a-project-built-in-types-removed" class="level-3">Removed</a></li></ul></li><li id="customizing-a-project-types-item" class="level-2"><a id="customizing-a-project-types-link" href="#customizing-a-project-types" class="level-2">Types</a><ul class="level-3" id="customizing-a-project-types-list"><li id="customizing-a-project-types-added-item" class="level-3"><a id="customizing-a-project-types-added-link" href="#customizing-a-project-types-added" class="level-3">Added</a></li><li id="customizing-a-project-types-changed-item" class="level-3"><a id="customizing-a-project-types-changed-link" href="#customizing-a-project-types-changed" class="level-3">Changed</a></li><li id="customizing-a-project-types-removed-item" class="level-3"><a id="customizing-a-project-types-removed-link" href="#customizing-a-project-types-removed" class="level-3">Removed</a></li><li id="customizing-a-project-types-introspection-item" class="level-3"><a id="customizing-a-project-types-introspection-link" href="#customizing-a-project-types-introspection" class="level-3">Introspection</a></li></ul></li><li id="customizing-a-project-expressions-item" class="level-2"><a id="customizing-a-project-expressions-link" href="#customizing-a-project-expressions" class="level-2">Expressions</a><ul class="level-3" id="customizing-a-project-expressions-list"><li id="customizing-a-project-expressions-added-item" class="level-3"><a id="customizing-a-project-expressions-added-link" href="#customizing-a-project-expressions-added" class="level-3">Added</a></li><li id="customizing-a-project-expressions-changed-item" class="level-3"><a id="customizing-a-project-expressions-changed-link" href="#customizing-a-project-expressions-changed" class="level-3">Changed</a></li><li id="customizing-a-project-expressions-removed-item" class="level-3"><a id="customizing-a-project-expressions-removed-link" href="#customizing-a-project-expressions-removed" class="level-3">Removed</a></li><li id="customizing-a-project-expressions-cast-changes-item" class="level-3"><a id="customizing-a-project-expressions-cast-changes-link" href="#customizing-a-project-expressions-cast-changes" class="level-3">Cast changes</a></li></ul></li><li id="customizing-a-project-functions-item" class="level-2"><a id="customizing-a-project-functions-link" href="#customizing-a-project-functions" class="level-2">Functions</a><ul class="level-3" id="customizing-a-project-functions-list"><li id="customizing-a-project-functions-added-item" class="level-3"><a id="customizing-a-project-functions-added-link" href="#customizing-a-project-functions-added" class="level-3">Added</a></li><li id="customizing-a-project-functions-changed-item" class="level-3"><a id="customizing-a-project-functions-changed-link" href="#customizing-a-project-functions-changed" class="level-3">Changed</a></li><li id="customizing-a-project-functions-removed-item" class="level-3"><a id="customizing-a-project-functions-removed-link" href="#customizing-a-project-functions-removed" class="level-3">Removed</a></li></ul></li><li id="customizing-a-project-attributes-item" class="level-2"><a id="customizing-a-project-attributes-link" href="#customizing-a-project-attributes" class="level-2">Attributes</a></li><li id="customizing-a-project-declarations-item" class="level-2"><a id="customizing-a-project-declarations-link" href="#customizing-a-project-declarations" class="level-2">Declarations</a><ul class="level-3" id="customizing-a-project-declarations-list"><li id="customizing-a-project-declarations-added-item" class="level-3"><a id="customizing-a-project-declarations-added-link" href="#customizing-a-project-declarations-added" class="level-3">Added</a></li><li id="customizing-a-project-declarations-changed-item" class="level-3"><a id="customizing-a-project-declarations-changed-link" href="#customizing-a-project-declarations-changed" class="level-3">Changed</a></li><li id="customizing-a-project-declarations-removed-item" class="level-3"><a id="customizing-a-project-declarations-removed-link" href="#customizing-a-project-declarations-removed" class="level-3">Removed</a></li></ul></li><li id="customizing-a-project-statements-item" class="level-2"><a id="customizing-a-project-statements-link" href="#customizing-a-project-statements" class="level-2">Statements</a><ul class="level-3" id="customizing-a-project-statements-list"><li id="customizing-a-project-statements-added-item" class="level-3"><a id="customizing-a-project-statements-added-link" href="#customizing-a-project-statements-added" class="level-3">Added</a></li><li id="customizing-a-project-statements-changed-item" class="level-3"><a id="customizing-a-project-statements-changed-link" href="#customizing-a-project-statements-changed" class="level-3">Changed</a></li><li id="customizing-a-project-statements-removed-item" class="level-3"><a id="customizing-a-project-statements-removed-link" href="#customizing-a-project-statements-removed" class="level-3">Removed</a></li></ul></li><li id="customizing-a-project-compile-time-evaluation-item" class="level-2"><a id="customizing-a-project-compile-time-evaluation-link" href="#customizing-a-project-compile-time-evaluation" class="level-2">Compile time evaluation</a><ul class="level-3" id="customizing-a-project-compile-time-evaluation-list"><li id="customizing-a-project-compile-time-evaluation-added-item" class="level-3"><a id="customizing-a-project-compile-time-evaluation-added-link" href="#customizing-a-project-compile-time-evaluation-added" class="level-3">Added</a></li><li id="customizing-a-project-compile-time-evaluation-changed-item" class="level-3"><a id="customizing-a-project-compile-time-evaluation-changed-link" href="#customizing-a-project-compile-time-evaluation-changed" class="level-3">Changed</a></li><li id="customizing-a-project-compile-time-evaluation-removed-item" class="level-3"><a id="customizing-a-project-compile-time-evaluation-removed-link" href="#customizing-a-project-compile-time-evaluation-removed" class="level-3">Removed</a></li></ul></li><li id="customizing-a-project-macros-item" class="level-2"><a id="customizing-a-project-macros-link" href="#customizing-a-project-macros" class="level-2">Macros</a><ul class="level-3" id="customizing-a-project-macros-list"><li id="customizing-a-project-macros-added-item" class="level-3"><a id="customizing-a-project-macros-added-link" href="#customizing-a-project-macros-added" class="level-3">Added</a></li><li id="customizing-a-project-macros-removed-item" class="level-3"><a id="customizing-a-project-macros-removed-link" href="#customizing-a-project-macros-removed" class="level-3">Removed</a></li></ul></li><li id="customizing-a-project-features-provided-by-builtins-item" class="level-2"><a id="customizing-a-project-features-provided-by-builtins-link" href="#customizing-a-project-features-provided-by-builtins" class="level-2">Features provided by builtins</a></li><li id="customizing-a-project-modules-item" class="level-2"><a id="customizing-a-project-modules-link" href="#customizing-a-project-modules" class="level-2">Modules</a></li><li id="customizing-a-project-contracts-item" class="level-2"><a id="customizing-a-project-contracts-link" href="#customizing-a-project-contracts" class="level-2">Contracts</a></li><li id="customizing-a-project-benchmarking-item" class="level-2"><a id="customizing-a-project-benchmarking-link" href="#customizing-a-project-benchmarking" class="level-2">Benchmarking</a></li><li id="customizing-a-project-testing-item" class="level-2"><a id="customizing-a-project-testing-link" href="#customizing-a-project-testing" class="level-2">Testing</a></li><li id="customizing-a-project-safe-fast-item" class="level-2"><a id="customizing-a-project-safe-fast-link" href="#customizing-a-project-safe-fast" class="level-2">Safe / fast</a></li><li id="customizing-a-project-c-item" class="level-2"><a id="customizing-a-project-c-link" href="#customizing-a-project-c" class="level-2">C</a></li><li id="customizing-a-project-c-item" class="level-2"><a id="customizing-a-project-c-link" href="#customizing-a-project-c" class="level-2">C++</a></li><li id="customizing-a-project-rust-item" class="level-2"><a id="customizing-a-project-rust-link" href="#customizing-a-project-rust" class="level-2">Rust</a></li><li id="customizing-a-project-zig-item" class="level-2"><a id="customizing-a-project-zig-link" href="#customizing-a-project-zig" class="level-2">Zig</a></li><li id="customizing-a-project-jai-item" class="level-2"><a id="customizing-a-project-jai-link" href="#customizing-a-project-jai" class="level-2">Jai</a></li><li id="customizing-a-project-odin-item" class="level-2"><a id="customizing-a-project-odin-link" href="#customizing-a-project-odin" class="level-2">Odin</a></li><li id="customizing-a-project-d-item" class="level-2"><a id="customizing-a-project-d-link" href="#customizing-a-project-d" class="level-2">D</a><ul class="level-3" id="customizing-a-project-d-list"><li id="customizing-a-project-d-constructors-and-destructors-item" class="level-3"><a id="customizing-a-project-d-constructors-and-destructors-link" href="#customizing-a-project-d-constructors-and-destructors" class="level-3">Constructors and destructors</a></li><li id="customizing-a-project-d-unicode-identifiers-item" class="level-3"><a id="customizing-a-project-d-unicode-identifiers-link" href="#customizing-a-project-d-unicode-identifiers" class="level-3">Unicode identifiers</a></li></ul></li><li id="customizing-a-project-keywords-item" class="level-2"><a id="customizing-a-project-keywords-link" href="#customizing-a-project-keywords" class="level-2">Keywords</a></li><li id="customizing-a-project-yacc-grammar-item" class="level-2"><a id="customizing-a-project-yacc-grammar-link" href="#customizing-a-project-yacc-grammar" class="level-2">Yacc grammar</a></li><li id="customizing-a-project-notation-item" class="level-2"><a id="customizing-a-project-notation-link" href="#customizing-a-project-notation" class="level-2">Notation</a></li><li id="customizing-a-project-source-code-representation-item" class="level-2"><a id="customizing-a-project-source-code-representation-link" href="#customizing-a-project-source-code-representation" class="level-2">Source code representation</a><ul class="level-3" id="customizing-a-project-source-code-representation-list"><li id="customizing-a-project-source-code-representation-lexical-translations-item" class="level-3"><a id="customizing-a-project-source-code-representation-lexical-translations-link" href="#customizing-a-project-source-code-representation-lexical-translations" class="level-3">Lexical Translations</a></li><li id="customizing-a-project-source-code-representation-line-terminators-item" class="level-3"><a id="customizing-a-project-source-code-representation-line-terminators-link" href="#customizing-a-project-source-code-representation-line-terminators" class="level-3">Line Terminators</a></li><li id="customizing-a-project-source-code-representation-input-elements-and-tokens-item" class="level-3"><a id="customizing-a-project-source-code-representation-input-elements-and-tokens-link" href="#customizing-a-project-source-code-representation-input-elements-and-tokens" class="level-3">Input Elements and Tokens</a></li><li id="customizing-a-project-source-code-representation-white-space-item" class="level-3"><a id="customizing-a-project-source-code-representation-white-space-link" href="#customizing-a-project-source-code-representation-white-space" class="level-3">White Space</a></li><li id="customizing-a-project-source-code-representation-letters-and-digits-item" class="level-3"><a id="customizing-a-project-source-code-representation-letters-and-digits-link" href="#customizing-a-project-source-code-representation-letters-and-digits" class="level-3">Letters and digits</a></li><li id="customizing-a-project-source-code-representation-comments-item" class="level-3"><a id="customizing-a-project-source-code-representation-comments-link" href="#customizing-a-project-source-code-representation-comments" class="level-3">Comments</a></li><li id="customizing-a-project-source-code-representation-doc-contract-item" class="level-3"><a id="customizing-a-project-source-code-representation-doc-contract-link" href="#customizing-a-project-source-code-representation-doc-contract" class="level-3">Doc contract</a></li><li id="customizing-a-project-source-code-representation-identifiers-item" class="level-3"><a id="customizing-a-project-source-code-representation-identifiers-link" href="#customizing-a-project-source-code-representation-identifiers" class="level-3">Identifiers</a></li><li id="customizing-a-project-source-code-representation-keywords-item" class="level-3"><a id="customizing-a-project-source-code-representation-keywords-link" href="#customizing-a-project-source-code-representation-keywords" class="level-3">Keywords</a></li><li id="customizing-a-project-source-code-representation-operators-and-punctuation-item" class="level-3"><a id="customizing-a-project-source-code-representation-operators-and-punctuation-link" href="#customizing-a-project-source-code-representation-operators-and-punctuation" class="level-3">Operators and punctuation</a></li><li id="customizing-a-project-source-code-representation-integer-literals-item" class="level-3"><a id="customizing-a-project-source-code-representation-integer-literals-link" href="#customizing-a-project-source-code-representation-integer-literals" class="level-3">Integer literals</a></li><li id="customizing-a-project-source-code-representation-floating-point-literals-item" class="level-3"><a id="customizing-a-project-source-code-representation-floating-point-literals-link" href="#customizing-a-project-source-code-representation-floating-point-literals" class="level-3">Floating point literals</a></li><li id="customizing-a-project-source-code-representation-characters-item" class="level-3"><a id="customizing-a-project-source-code-representation-characters-link" href="#customizing-a-project-source-code-representation-characters" class="level-3">Characters</a></li><li id="customizing-a-project-source-code-representation-backslash-escapes-item" class="level-3"><a id="customizing-a-project-source-code-representation-backslash-escapes-link" href="#customizing-a-project-source-code-representation-backslash-escapes" class="level-3">Backslash escapes</a></li><li id="customizing-a-project-source-code-representation-string-literals-item" class="level-3"><a id="customizing-a-project-source-code-representation-string-literals-link" href="#customizing-a-project-source-code-representation-string-literals" class="level-3">String literals</a></li><li id="customizing-a-project-source-code-representation-raw-string-literals-item" class="level-3"><a id="customizing-a-project-source-code-representation-raw-string-literals-link" href="#customizing-a-project-source-code-representation-raw-string-literals" class="level-3">Raw string literals</a></li><li id="customizing-a-project-source-code-representation-character-literals-item" class="level-3"><a id="customizing-a-project-source-code-representation-character-literals-link" href="#customizing-a-project-source-code-representation-character-literals" class="level-3">Character literals</a></li></ul></li><li id="customizing-a-project-types-item" class="level-2"><a id="customizing-a-project-types-link" href="#customizing-a-project-types" class="level-2">Types</a><ul class="level-3" id="customizing-a-project-types-list"><li id="customizing-a-project-types-boolean-types-item" class="level-3"><a id="customizing-a-project-types-boolean-types-link" href="#customizing-a-project-types-boolean-types" class="level-3">Boolean types</a></li><li id="customizing-a-project-types-integer-types-item" class="level-3"><a id="customizing-a-project-types-integer-types-link" href="#customizing-a-project-types-integer-types" class="level-3">Integer types</a></li><li id="customizing-a-project-types-floating-point-types-item" class="level-3"><a id="customizing-a-project-types-floating-point-types-link" href="#customizing-a-project-types-floating-point-types" class="level-3">Floating point types</a></li><li id="customizing-a-project-types-vector-types-item" class="level-3"><a id="customizing-a-project-types-vector-types-link" href="#customizing-a-project-types-vector-types" class="level-3">Vector types</a></li><li id="customizing-a-project-types-array-types-item" class="level-3"><a id="customizing-a-project-types-array-types-link" href="#customizing-a-project-types-array-types" class="level-3">Array types</a></li><li id="customizing-a-project-types-slice-types-item" class="level-3"><a id="customizing-a-project-types-slice-types-link" href="#customizing-a-project-types-slice-types" class="level-3">Slice types</a></li><li id="customizing-a-project-types-pointer-types-item" class="level-3"><a id="customizing-a-project-types-pointer-types-link" href="#customizing-a-project-types-pointer-types" class="level-3">Pointer types</a></li><li id="customizing-a-project-types--item" class="level-3"><a id="customizing-a-project-types--link" href="#customizing-a-project-types-" class="level-3">#</a></li><li id="customizing-a-project-types-struct-types-item" class="level-3"><a id="customizing-a-project-types-struct-types-link" href="#customizing-a-project-types-struct-types" class="level-3">Struct types</a></li><li id="customizing-a-project-types-union-types-item" class="level-3"><a id="customizing-a-project-types-union-types-link" href="#customizing-a-project-types-union-types" class="level-3">Union types</a></li><li id="customizing-a-project-types-fault-types-item" class="level-3"><a id="customizing-a-project-types-fault-types-link" href="#customizing-a-project-types-fault-types" class="level-3">Fault types</a></li><li id="customizing-a-project-types-enum-types-item" class="level-3"><a id="customizing-a-project-types-enum-types-link" href="#customizing-a-project-types-enum-types" class="level-3">Enum types</a></li><li id="customizing-a-project-types-function-types-item" class="level-3"><a id="customizing-a-project-types-function-types-link" href="#customizing-a-project-types-function-types" class="level-3">Function types</a></li><li id="customizing-a-project-types-typeid-type-item" class="level-3"><a id="customizing-a-project-types-typeid-type-link" href="#customizing-a-project-types-typeid-type" class="level-3">Typeid type</a></li><li id="customizing-a-project-types-any-type-item" class="level-3"><a id="customizing-a-project-types-any-type-link" href="#customizing-a-project-types-any-type" class="level-3">Any type</a></li><li id="customizing-a-project-types-anyfault-type-item" class="level-3"><a id="customizing-a-project-types-anyfault-type-link" href="#customizing-a-project-types-anyfault-type" class="level-3">Anyfault type</a></li></ul></li><li id="customizing-a-project-declarations-and-scope-item" class="level-2"><a id="customizing-a-project-declarations-and-scope-link" href="#customizing-a-project-declarations-and-scope" class="level-2">Declarations and scope</a></li><li id="customizing-a-project-expressions-item" class="level-2"><a id="customizing-a-project-expressions-link" href="#customizing-a-project-expressions" class="level-2">Expressions</a><ul class="level-3" id="customizing-a-project-expressions-list"><li id="customizing-a-project-expressions-assignment-expression-item" class="level-3"><a id="customizing-a-project-expressions-assignment-expression-link" href="#customizing-a-project-expressions-assignment-expression" class="level-3">Assignment expression</a></li><li id="customizing-a-project-expressions-ternary-elvis-and-or-else-expressions-item" class="level-3"><a id="customizing-a-project-expressions-ternary-elvis-and-or-else-expressions-link" href="#customizing-a-project-expressions-ternary-elvis-and-or-else-expressions" class="level-3">Ternary, elvis and or-else expressions</a></li><li id="customizing-a-project-expressions-suffix-expression-item" class="level-3"><a id="customizing-a-project-expressions-suffix-expression-link" href="#customizing-a-project-expressions-suffix-expression" class="level-3">Suffix expression</a></li><li id="customizing-a-project-expressions-rethrow-expression-item" class="level-3"><a id="customizing-a-project-expressions-rethrow-expression-link" href="#customizing-a-project-expressions-rethrow-expression" class="level-3">Rethrow expression</a></li><li id="customizing-a-project-expressions-relational-expression-item" class="level-3"><a id="customizing-a-project-expressions-relational-expression-link" href="#customizing-a-project-expressions-relational-expression" class="level-3">Relational expression</a></li><li id="customizing-a-project-expressions-and-expression-item" class="level-3"><a id="customizing-a-project-expressions-and-expression-link" href="#customizing-a-project-expressions-and-expression" class="level-3">And expression</a></li><li id="customizing-a-project-expressions-or-expression-item" class="level-3"><a id="customizing-a-project-expressions-or-expression-link" href="#customizing-a-project-expressions-or-expression" class="level-3">Or expression</a></li><li id="customizing-a-project-expressions-casts-item" class="level-3"><a id="customizing-a-project-expressions-casts-link" href="#customizing-a-project-expressions-casts" class="level-3">Casts</a></li><li id="customizing-a-project-expressions-pointer-casts-item" class="level-3"><a id="customizing-a-project-expressions-pointer-casts-link" href="#customizing-a-project-expressions-pointer-casts" class="level-3">Pointer casts</a></li><li id="customizing-a-project-expressions-subscript-operator-item" class="level-3"><a id="customizing-a-project-expressions-subscript-operator-link" href="#customizing-a-project-expressions-subscript-operator" class="level-3">Subscript operator</a></li><li id="customizing-a-project-expressions-operands-item" class="level-3"><a id="customizing-a-project-expressions-operands-link" href="#customizing-a-project-expressions-operands" class="level-3">Operands</a></li><li id="customizing-a-project-expressions-compound-literals-item" class="level-3"><a id="customizing-a-project-expressions-compound-literals-link" href="#customizing-a-project-expressions-compound-literals" class="level-3">Compound Literals</a></li><li id="customizing-a-project-expressions-function-calls-item" class="level-3"><a id="customizing-a-project-expressions-function-calls-link" href="#customizing-a-project-expressions-function-calls" class="level-3">Function calls</a></li></ul></li><li id="customizing-a-project-statements-item" class="level-2"><a id="customizing-a-project-statements-link" href="#customizing-a-project-statements" class="level-2">Statements</a><ul class="level-3" id="customizing-a-project-statements-list"><li id="customizing-a-project-statements-asm-block-statement-item" class="level-3"><a id="customizing-a-project-statements-asm-block-statement-link" href="#customizing-a-project-statements-asm-block-statement" class="level-3">Asm block statement</a></li><li id="customizing-a-project-statements-assert-statement-item" class="level-3"><a id="customizing-a-project-statements-assert-statement-link" href="#customizing-a-project-statements-assert-statement" class="level-3">Assert statement</a></li><li id="customizing-a-project-statements-break-statement-item" class="level-3"><a id="customizing-a-project-statements-break-statement-link" href="#customizing-a-project-statements-break-statement" class="level-3">Break statement</a></li><li id="customizing-a-project-statements-compile-time-echo-statement-item" class="level-3"><a id="customizing-a-project-statements-compile-time-echo-statement-link" href="#customizing-a-project-statements-compile-time-echo-statement" class="level-3">Compile time echo statement</a></li><li id="customizing-a-project-statements-compile-time-assert-statement-item" class="level-3"><a id="customizing-a-project-statements-compile-time-assert-statement-link" href="#customizing-a-project-statements-compile-time-assert-statement" class="level-3">Compile time assert statement</a></li><li id="customizing-a-project-statements-compile-time-error-statement-item" class="level-3"><a id="customizing-a-project-statements-compile-time-error-statement-link" href="#customizing-a-project-statements-compile-time-error-statement" class="level-3">Compile time error statement</a></li><li id="customizing-a-project-statements-compile-time-if-statement-item" class="level-3"><a id="customizing-a-project-statements-compile-time-if-statement-link" href="#customizing-a-project-statements-compile-time-if-statement" class="level-3">Compile time if statement</a></li><li id="customizing-a-project-statements-compile-time-switch-statement-item" class="level-3"><a id="customizing-a-project-statements-compile-time-switch-statement-link" href="#customizing-a-project-statements-compile-time-switch-statement" class="level-3">Compile time switch statement</a></li><li id="customizing-a-project-statements-continue-statement-item" class="level-3"><a id="customizing-a-project-statements-continue-statement-link" href="#customizing-a-project-statements-continue-statement" class="level-3">Continue statement</a></li><li id="customizing-a-project-statements-declaration-statement-item" class="level-3"><a id="customizing-a-project-statements-declaration-statement-link" href="#customizing-a-project-statements-declaration-statement" class="level-3">Declaration statement</a></li><li id="customizing-a-project-statements-defer-statement-item" class="level-3"><a id="customizing-a-project-statements-defer-statement-link" href="#customizing-a-project-statements-defer-statement" class="level-3">Defer statement</a></li><li id="customizing-a-project-statements-expr-statement-item" class="level-3"><a id="customizing-a-project-statements-expr-statement-link" href="#customizing-a-project-statements-expr-statement" class="level-3">Expr statement</a></li><li id="customizing-a-project-statements-if-statement-item" class="level-3"><a id="customizing-a-project-statements-if-statement-link" href="#customizing-a-project-statements-if-statement" class="level-3">If statement</a></li><li id="customizing-a-project-statements-nextcase-statement-item" class="level-3"><a id="customizing-a-project-statements-nextcase-statement-link" href="#customizing-a-project-statements-nextcase-statement" class="level-3">Nextcase statement</a></li><li id="customizing-a-project-statements-switch-statement-item" class="level-3"><a id="customizing-a-project-statements-switch-statement-link" href="#customizing-a-project-statements-switch-statement" class="level-3">Switch statement</a></li><li id="customizing-a-project-statements-for-statement-item" class="level-3"><a id="customizing-a-project-statements-for-statement-link" href="#customizing-a-project-statements-for-statement" class="level-3">For statement</a></li><li id="customizing-a-project-statements-foreach-and-foreach_r-statements-item" class="level-3"><a id="customizing-a-project-statements-foreach-and-foreach_r-statements-link" href="#customizing-a-project-statements-foreach-and-foreach_r-statements" class="level-3">Foreach and foreach_r statements</a></li><li id="customizing-a-project-statements-return-statement-item" class="level-3"><a id="customizing-a-project-statements-return-statement-link" href="#customizing-a-project-statements-return-statement" class="level-3">Return statement</a></li><li id="customizing-a-project-statements-while-statement-item" class="level-3"><a id="customizing-a-project-statements-while-statement-link" href="#customizing-a-project-statements-while-statement" class="level-3">While statement</a></li><li id="customizing-a-project-statements-var-statement-item" class="level-3"><a id="customizing-a-project-statements-var-statement-link" href="#customizing-a-project-statements-var-statement" class="level-3">Var statement</a></li></ul></li><li id="customizing-a-project-attributes-item" class="level-2"><a id="customizing-a-project-attributes-link" href="#customizing-a-project-attributes" class="level-2">Attributes</a><ul class="level-3" id="customizing-a-project-attributes-list"><li id="customizing-a-project-attributes-user-defined-attributes-item" class="level-3"><a id="customizing-a-project-attributes-user-defined-attributes-link" href="#customizing-a-project-attributes-user-defined-attributes" class="level-3">User defined attributes</a></li></ul></li><li id="customizing-a-project-methods-item" class="level-2"><a id="customizing-a-project-methods-link" href="#customizing-a-project-methods" class="level-2">Methods</a></li><li id="customizing-a-project-modules-item" class="level-2"><a id="customizing-a-project-modules-link" href="#customizing-a-project-modules" class="level-2">Modules</a></li><li id="customizing-a-project-thank-you-item" class="level-2"><a id="customizing-a-project-thank-you-link" href="#customizing-a-project-thank-you" class="level-2">Thank You</a></li><li id="customizing-a-project-special-mentions-item" class="level-2"><a id="customizing-a-project-special-mentions-link" href="#customizing-a-project-special-mentions" class="level-2">Special Mentions</a></li></ul></li></ul></li></ul></div>
    </div>
    <div role="flatdoc-content" class="content"><hr><p>title: What Is C3?
description: A guide to the C3 Programming Language
sidebar:</p><h2 id="-order-1">  order: 1</h2><p>:::note[Want To Download C3?]
<a href="https://waveproc.github.io/getting-started/prebuilt-binaries/">Download C3</a>, available on Mac, Windows and Linux.
:::</p><h2 id="-c3-programming-language">C3 Programming Language</h2><p>C3 is an evolution of C and a minimalist systems programming language.</p><h3 id="-c3-programming-language-ergonomics-and-safety">🦺 Ergonomics <strong>and</strong> Safety</h3><ul>
<li>Optionals to safely and quickly handle errors and null.</li>
<li>Defer to clean up resources.</li>
<li>Slices and foreach for safe iteration.</li>
<li>Contracts in comments, to add constraints to your code. </li>
</ul><h3 id="-c3-programming-language-performance-by-default">⚡ Performance <strong>by</strong> default</h3><ul>
<li>Write SIMD vectors to program the hardware directly.</li>
<li>Access to different memory allocators to fine tune performance.</li>
<li>Zero overhead errors.</li>
<li>Fast compilation times.</li>
<li>LLVM backend for industrial strength optimisations.</li>
<li>Easy to use inline assembly.</li>
</ul><h3 id="-c3-programming-language-batteries-included-standard-library">🔋Batteries <strong>included</strong> standard library</h3><ul>
<li>Dynamic containers and strings.</li>
<li>Cross-platform abstractions for ease of use.</li>
<li>Access to the native platform when you need it.</li>
</ul><h3 id="-c3-programming-language-leverage-existing-c-or-c-libraries">🔧 Leverage <strong>existing</strong> C or C++ libraries</h3><ul>
<li>Full C ABI compatibility.</li>
<li>C3 can link C code, C can link C3 code.</li>
</ul><h3 id="-c3-programming-language-modules-are-simple">📦 Modules <strong>are</strong> simple</h3><ul>
<li>Modules namespace code.</li>
<li>Modules make encapsulation simple with explicit control.</li>
<li>Interfaces define shared behaviour to write robust libraries.</li>
<li>Generic modules make extending code easier.</li>
<li>Simple struct composition and reuse with struct subtyping.</li>
</ul><h3 id="-c3-programming-language-macros-without-a-phd">🎓 Macros <strong>without</strong> a PhD</h3><ul>
<li>Macros can be similar to normal functions.</li>
<li>Or write code that understands the types in your code.</li>
</ul><hr><p>title: Design Goals &amp; Background
description: Design Goals &amp; Background
sidebar:</p><h2 id="-order-2">  order: 2</h2><p>:::note[Want To Download C3?]
<a href="https://waveproc.github.io/getting-started/prebuilt-binaries/">Download C3</a>, available on Mac, Windows and Linux.
:::</p><h2 id="-design-goals">Design goals</h2><ul>
<li>Procedural language, with a pragmatic ethos to get work done.</li>
<li>Minimalistic, no feature should be unnecessary or redundant.</li>
<li>Stay close to C - only change where there is a significant need.</li>
<li>Learning C3 should be easy for a C programmer.</li>
<li>Seamless C integration.</li>
<li>Ergonomic common patterns.</li>
<li>Data is inert.</li>
<li>Zero Is Initialization (ZII).<sup>*</sup></li>
<li>Avoid “big ideas”.</li>
</ul><p><sup><em></em></sup><em> </em>“Zero Is Initialization” is an idiom where types and code
are written so that the zero value is a meaningful, initialized
state.*</p><h2 id="-features">Features</h2><ul>
<li><a href="https://waveproc.github.io/language-common/cinterop/">Full C ABI compatibility</a></li>
<li><a href="https://waveproc.github.io/language-fundamentals/modules/">Module system</a> </li>
<li><a href="https://waveproc.github.io/generic-programming/generics/">Generic modules</a></li>
<li><a href="https://waveproc.github.io/language-common/contracts/">Design by contract</a></li>
<li><a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">Zero overhead errors</a></li>
<li><a href="https://waveproc.github.io/generic-programming/macros/">Semantic macro system</a></li>
<li><a href="https://waveproc.github.io/language-common/vectors/">First-class SIMD vector types</a></li>
<li><a href="https://waveproc.github.io/language-overview/types/#struct-subtyping">Struct subtyping</a></li>
<li><a href="https://waveproc.github.io/language-common/arrays/#slice">Safe array access using slices</a></li>
<li><a href="https://waveproc.github.io/language-common/arrays/#iteration-over-arrays">Safe array iteration using foreach</a></li>
<li><a href="https://waveproc.github.io/misc-advanced/asm/">Easy to use inline assembly</a></li>
<li><a href="https://waveproc.github.io/standard-library/">Cross-platform standard library which includes dynamic containers and strings</a></li>
<li>LLVM backend</li>
</ul><h2 id="-c3-background">C3 Background</h2><p>C3 is an evolution of C, a minimalistic language designed for systems 
programming, enabling the same paradigms and retaining the same syntax 
as far as possible.</p><p>C3 started as an experimental fork of the <a href="http://www.c2lang.org/">C2 language</a> 
by <a href="https://github.com/bvdberg">Bas van den Berg</a>. 
It has evolved significantly, not just in syntax but also 
in regard to error handling, macros, generics and strings.</p><hr><p>title: Roadmap For C3
description: Roadmap For C3
sidebar:</p><h2 id="-order-3">  order: 3</h2><p>:::note[Want To Download C3?]
<a href="https://waveproc.github.io/getting-started/prebuilt-binaries/">Download C3</a>, available on Mac, Windows and Linux.
:::</p><h2 id="-c3-roadmap">C3 Roadmap</h2><h3 id="-c3-roadmap-c3-is-feature-stable">C3 Is Feature Stable</h3><p>The C3 <code>0.6.x</code> series can be run in production with the same general caveats for using any pre-<code>1.0</code> software.</p><p>While we strive to have zero bug count, there are still bugs being 
found. This means that anyone using it in production would need to stay
 updated with the latest fixes.</p><p>The focus of <code>0.7</code>–<code>0.9</code> will be fleshing out the cross-platform standard 
library and make sure the syntax and semantics are solid. Also, the 
toolchain will expand and improve. <a href="https://github.com/c3lang/c3c/issues/1456">Please refer to this issue for what’s 
left in terms of features for <code>1.0</code></a>.</p><p>The intended roadmap has one major <code>0.1</code> release per year:
| Date       |  Release  |
|——————|—————-|
| 2025-04-01 |    0.7    |
| 2026-04-01 |    0.8    |
| 2027-04-01 |    0.9    |
| 2028-04-01 |    1.0    |</p><h3 id="-c3-roadmap-compatibility">Compatibility</h3><p>Minor releases in the same major release series are compatible. </p><p>For example <code>0.6.0</code>, <code>0.6.1</code>, … <code>0.6.x</code> are compatible and <code>0.7.0</code>, <code>0.7.1</code>, … <code>0.7.x</code> are compatible.</p><h3 id="-c3-roadmap-standard-library">Standard library</h3><p>The standard library is less mature than the compiler. It needs more 
functionality and more tests. The compiler reaching a <code>1.0</code> release only 
means a language freeze, the standard library will continue to evolve 
past the <code>1.0</code> release.</p><hr><p>title: Install C3 Compiler Binary
description: Installing C3 Compiler Binary
sidebar:</p><h2 id="-order-20">  order: 20</h2><h1 id="prebuilt-binaries">Prebuilt binaries</h1><ul>
<li><a href="#installing-on-windows">Installing on Windows</a></li>
<li><a href="#installing-on-mac-arm64">Installing on Mac Arm64</a></li>
<li><a href="#installing-on-ubuntu">Installing on Ubuntu</a></li>
<li><a href="#installing-on-debian">Installing on Debian</a> </li>
<li><a href="#installing-on-arch-linux">Installing on Arch</a> </li>
</ul><h2 id="prebuilt-binaries-installing-on-windows">Installing on Windows</h2><ol>
<li><a href="https://github.com/c3lang/c3c/releases/download/latest/c3-windows.zip">Download the C3 compiler</a>. Or the <a href="https://github.com/c3lang/c3c/releases/download/latest/c3-windows-debug.zip">debug build</a></li>
<li>Unzip it into a folder</li>
<li>Either Visual Studio 17 or follow the next two steps.</li>
<li>Run the <code>msvc_build_libraries.py</code> Python script which will download the necessary files to compile on Windows.</li>
</ol><p>:::note[Running the Python script]</p><p>If you don’t have Python installed, you can download it from <a href="https://www.python.org/downloads/">the Python Website</a>.
or get it from the <a href="https://www.microsoft.com/en-us/p/python-39/9p7qfqmjrfp7">the Microsoft Store</a></p><p>Afterwards you can double click the <code>msvc_build_libraries.py</code> file and pick “python” from the list of programs in the “Select an app to open this .py file” window.
<img src="C3_files/windows_setup.png" alt="Python"></p><p>:::</p><h3 id="prebuilt-binaries-installing-on-windows-optional-set-c3c-as-a-global-environment-variable">Optional: set c3c as a global environment variable</h3><ol>
<li>copy the folder</li>
<li>navigate to <code>C:\Program Files</code></li>
<li>paste the folder here</li>
<li>navigate inside the folder you’ve pasted</li>
<li>copy the path of the folder</li>
<li>search for “edit the system environment variables” on your computer</li>
<li>click on the “environment variables” button on the bottom right</li>
<li>under “user variables” double click on “path”</li>
<li>click on “new” and paste the path to the folder</li>
<li>run <code>c3c</code> on anywhere in your computer!<pre><code class="lang-bash">c<span class="number">3</span>c compile ./hello.c<span class="number">3</span></code></pre>
</li>
</ol><h2 id="prebuilt-binaries-installing-on-mac-arm64">Installing on Mac Arm64</h2><ol>
<li>Make sure you have XCode with command line tools installed.</li>
<li><a href="https://github.com/c3lang/c3c/releases/download/latest/c3-macos.zip">Download the zip file</a>
(debug version <a href="https://github.com/c3lang/c3c/releases/download/latest/c3-macos-debug.zip">here</a>)</li>
<li>Unzip executable and standard lib.</li>
<li>Run <code>./c3c</code>.</li>
</ol><h2 id="prebuilt-binaries-installing-on-ubuntu">Installing on Ubuntu</h2><ol>
<li><a href="https://github.com/c3lang/c3c/releases/download/latest/c3-ubuntu-20.tar.gz">Download tar file</a>
(debug version <a href="https://github.com/c3lang/c3c/releases/download/latest/c3-ubuntu-20-debug.tar.gz">here</a>)</li>
<li>Unpack executable and standard lib.</li>
<li>Run <code>./c3c</code>.</li>
</ol><h2 id="prebuilt-binaries-installing-on-debian">Installing on Debian</h2><ol>
<li><a href="https://github.com/c3lang/c3c/releases/download/latest/c3-linux.tar.gz">Download tar file</a>
(debug version <a href="https://github.com/c3lang/c3c/releases/download/latest/c3-linux-debug.tar.gz">here</a>)</li>
<li>Unpack executable and standard lib.</li>
<li>Run <code>./c3c</code>.</li>
</ol><h2 id="prebuilt-binaries-installing-on-arch-linux">Installing on Arch Linux</h2><p>There is an AUR package for the c3c compiler : <a href="https://aur.archlinux.org/packages/c3c-git">c3c-git</a>.</p><p>Due
 to some issues with the LLVM packaged for Arch Linux, the AUR package 
will download and use LLVM 16 from Ubuntu-23.04 to compile the c3c 
compiler.</p><p>You can use your AUR package manager:</p><pre><code class="lang-bash">paru -S c<span class="number">3</span>c-git
<span class="comment"># or yay -S c<span class="number">3</span>c-git</span>
<span class="comment"># or aura -A c<span class="number">3</span>c-git</span></code></pre><p>Or clone it manually:</p><pre><code class="lang-bash">git clone https:<span class="comment">//aur.archlinux.org/c<span class="number">3</span>c-git.git</span>
cd c<span class="number">3</span>c-git
makepkg -si</code></pre><hr><p>title: Build C3 From Source
description: Build C3 From Source
sidebar:</p><h2 id="prebuilt-binaries-order-21">  order: 21</h2><p>:::note[Want To Download Pre-Built C3 Binaries?]
<a href="https://waveproc.github.io/getting-started/prebuilt-binaries/">Download C3</a>, available on Mac, Windows and Linux.
:::</p><p>For other platforms it should be possible to compile it on any platform LLVM can compile to. You will need <code>git</code> and <code>CMake</code> installed.</p><h2 id="prebuilt-binaries-1-install-llvm">1. Install LLVM</h2><p>See LLVM the <a href="https://llvm.org/docs/GettingStarted.html">LLVM documentation</a> on how to set up LLVM for development. 
- On MacOS, installing through Homebrew or MacPorts works fine.
- Using apt-get on Linux should work fine as well. 
- For Windows you can download suitable pre-compiled LLVM binaries from <a href="https://github.com/c3lang/win-llvm">https://github.com/c3lang/win-llvm</a></p><h2 id="prebuilt-binaries-2-clone-the-c3-compiler-source-code-from-github">2. Clone the C3 compiler source code from Github</h2><p>This should be as simple as doing:</p><pre><code class="lang-bash">git clone https:<span class="comment">//github.com/c<span class="number">3</span>lang/c<span class="number">3</span>c.git</span></code></pre><p>… from the command line.</p><h2 id="prebuilt-binaries-3-build-the-compiler">3. Build the compiler</h2><p>Create the build directory:</p><pre><code class="lang-bash">MyMachine:c<span class="number">3</span>c$ mkdir build
MyMachine:c<span class="number">3</span>c$ cd build/</code></pre><p>Use CMake to set up:</p><pre><code class="lang-bash">MyMachine:c<span class="number">3</span>c/build$ cmake ../</code></pre><p>Build the compiler:</p><pre><code class="lang-bash">MyMachine:c<span class="number">3</span>c/build$ make</code></pre><h2 id="prebuilt-binaries-4-test-it-out">4. Test it out</h2><pre><code class="lang-bash">MyMachine:c<span class="number">3</span>c/build$ ./c<span class="number">3</span>c compile-run ../resources/testfragments/helloworld.c<span class="number">3</span></code></pre><h1 id="building-via-docker">Building via Docker</h1><p>You can build <code>c3c</code> using either an Ubuntu 18.04 or 20.04 container:</p><pre><code class="lang-bash">./build-with-docker.sh <span class="number">18</span></code></pre><p>Replace <code>18</code> with <code>20</code> to build through Ubuntu 20.04.</p><p>For a release build specify:</p><pre><code class="lang-bash">./build-with-docker.sh <span class="number">20</span> Release</code></pre><p>A <code>c3c</code> executable will be found under <code>bin/</code>.</p><h1 id="building-on-mac-using-homebrew">Building on Mac using Homebrew</h1><ol>
<li>Install CMake: <code>brew install cmake</code></li>
<li>Install LLVM 17+: <code>brew install llvm</code></li>
<li>Clone the C3C github repository: <code>git clone https://github.com/c3lang/c3c.git</code></li>
<li>Enter the C3C directory <code>cd c3c</code>.</li>
<li>Create a build directory <code>mkdir build</code></li>
<li>Change directory to the build directory <code>cd build</code></li>
<li>Set up CMake build for debug: <code>cmake ..</code></li>
<li>Build: <code>cmake --build .</code></li>
</ol><h1 id="building-on-mac-using-macports">Building on Mac using MacPorts</h1><p><code>c3c</code> may be built on Mac systems not supported by Homebrew
using the <strong><a href="https://ports.macports.org/port/cmake">cmake</a></strong>, <strong><a href="https://ports.macports.org/port/llvm-17">llvm-17</a></strong> and <strong><a href="https://ports.macports.org/port/clang-17">clang-17</a></strong>
ports from <strong><a href="https://ports.macports.org/">MacPorts</a></strong>.</p><ol>
<li>Install CMake: <code>sudo port install cmake</code></li>
<li>Install LLVM 17: <code>sudo port install llvm-17</code></li>
<li>Install clang 17: <code>sudo port install clang-17</code></li>
<li>Clone the C3C github repository: <code>git clone https://github.com/c3lang/c3c.git</code></li>
<li>Enter the C3C directory <code>cd c3c</code>.</li>
<li>Create a build directory <code>mkdir build</code></li>
<li>Change directory to the build directory <code>cd build</code></li>
<li>❗️Important before you run cmake❗️<br>
Set <strong>LLVM_DIR</strong> to the directory with the llvm-17 macport .cmake files<br>
<code>export LLVM_DIR=/opt/local/libexec/llvm-17/lib/cmake/llvm</code> </li>
<li>Set up CMake build for debug: <code>cmake ..</code></li>
<li>Build: <code>cmake --build .</code></li>
</ol><p>See also discussion <a href="https://github.com/c3lang/c3c/discussions/1701">#1701</a></p><hr><p>title: Hello World
description: Learn to write hello world
sidebar:</p><h2 id="building-on-mac-using-macports-order-30">  order: 30</h2><p>:::note[Not installed the C3 compiler yet?]
<a href="https://waveproc.github.io/getting-started/prebuilt-binaries">Download C3</a>, available on Mac, Windows and Linux.
:::</p><h2 id="building-on-mac-using-macports-hello-world">👋 Hello world</h2><p>Let’s start with the traditional first program, Hello World in C3:</p><pre><code class="lang-c3">import std::io;

fn void main()
{
    io::printn(<span class="string">"Hello, World!"</span>);
}</code></pre><p>The <a href="https://waveproc.github.io/language-fundamentals/modules/#importing-modules"><code>import</code></a> statement imports other modules, and we want <code>printn</code> which
is in <code>std::io</code>.</p><p>Next we define a <a href="https://waveproc.github.io/language-fundamentals/functions/">function</a> which starts with the <code>fn</code> keyword followed by the return type. We don’t need to return anything, so return <code>void</code>. The function name <code>main</code> then follows, followed by the function’s parameter list, which is empty.</p><pre><code class="lang-c3">fn void main() {}</code></pre><p>:::note
The function named <code>main</code> is a bit special, as it is where the program starts, or the entry point of the program.</p><p>For Unix-like OSes there are a few different variants, for example we might declare it as <code>fn void main(String[] args)</code>. In that case the parameter “args” contains a <a href="https://waveproc.github.io/language-common/arrays/#slice">slice</a> of strings, of the program’s command line arguments, starting with the name of the program, itself.
:::</p><h3 id="building-on-mac-using-macports-hello-world-function-scope">🔭 Function scope</h3><p><code>{</code> and <code>}</code> signifies the start and end of the function respectively, 
we call this the function’s scope. Inside the function scope we have a single function 
call to <code>printn</code> inside <code>std::io</code>. We use the last part of the path “io” in front of
the function to identify what module it belongs to.</p><h3 id="building-on-mac-using-macports-hello-world-imports-can-use-a-shorthand">📏 Imports can use a shorthand</h3><p>We could have used the original longer path: <code>std::io::printn</code>
if we wanted, but we <em>can</em> shorten it to just the lowest level module like <code>io::printn</code>. This is the <em>convention</em> in C3 and is is known as “path-shortening”, it avoids writing long import paths that can make code harder to read.</p><p>```diff lang=”cpp”
- std::io::printn(“Hello, World!”);
+ io::printn(“Hello, World!”);</p><pre><code>
The `io::printn` function takes a single argument and prints it, followed by a newline, then the function ends and the program terminates.


## 🔧 Compiling the program

Let's take the above program and put it in a file called `hello_world.c3`.

We can then compile it with:

```bash 
c3c compile hello_world.c3</code></pre><p>And run it:</p><pre><code class="lang-bash">./hello_world</code></pre><p>It should print <code>Hello, World!</code> and return back to the command line prompt. 
If you are on Windows, you will have <code>hello_world.exe</code> instead. Call it in the same way.</p><h3 id="building-on-mac-using-macports-hello-world-compiling-and-running">🏃 Compiling and running</h3><p>When we start out it can be useful to compile and then have the compiler start the
program immediately. We can do that with <code>compile-run</code>:</p><p>```bash {4}
$ c3c compile-run hello_world.c3</p><blockquote>
<p>Program linked to executable ‘hello_world’.
Launching hello_world…
Hello, World
```</p>
</blockquote><p>Want more options when compiling? <a href="https://waveproc.github.io/build-your-project/build-commands/">Check the c3c compiler build options</a>.</p><h3 id="building-on-mac-using-macports-hello-world-successfully-working">🎉 Successfully working?</h3><p>Congratulations! You’re now up and running with C3.</p><h3 id="building-on-mac-using-macports-hello-world-need-help">❓ Need help?</h3><p>We’re happy to help on the <a href="https://discord.gg/qN76R87">C3 Discord</a>.</p><hr><p>title: Projects
description: Learn to create C3 projects
sidebar:</p><h2 id="building-on-mac-using-macports-order-31">  order: 31</h2><p>import { FileTree } from ‘@astrojs/starlight/components’;</p><p>:::note[Not installed the C3 compiler yet?]
<a href="https://waveproc.github.io/getting-started/prebuilt-binaries/">Download C3</a>, available on Mac, Windows and Linux.
:::</p><h2 id="building-on-mac-using-macports-projects-in-c3">Projects in C3</h2><p>Projects are <em>optional</em>, but are a good way to manage compiling code when there
 are a lot of files and modules.
They also allow you to specify libraries to link, and define how your project should be built for specific targets.</p><h3 id="building-on-mac-using-macports-projects-in-c3-creating-a-new-project">💡 Creating a new project</h3><p>The <code>c3c init</code> command will create a new directory containing your project structure.
It requires a name of the project, we will use <code>myc3project</code> in its place.</p><pre><code class="lang-bash">c<span class="number">3</span>c init myc<span class="number">3</span>project</code></pre><p>You can also customize the path where the project will be created or specify a <em>template</em>. For more information check the <a href="https://waveproc.github.io/build-your-project/build-commands/#init-a-new-project">init command reference</a>.</p><h3 id="building-on-mac-using-macports-projects-in-c3-project-structure">📁 Project structure</h3><p>If
 you check the directory that was created you might find it a bit 
confusing with a bunch of different directories, but worry not because 
if you expand them you will realise that most of them are actually 
empty!</p><filetree>
- build/
- docs/
- lib/
- resources/
- scripts/
- src/
  - main.c3
- test/
- LICENSE
- project.json
- README.md
</filetree><h4>Directory Overview</h4><table>
<thead>
<tr>
<th>Directory</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>./build</code></td>
<td>Where your temporary files and build results will go.</td>
</tr>
<tr>
<td><code>./docs</code></td>
<td>Code Documentation</td>
</tr>
<tr>
<td><code>./lib</code></td>
<td>C3 libraries (with the .c3l suffix)</td>
</tr>
<tr>
<td><code>./resources</code></td>
<td>Non-code resources like images, sound effects etc.</td>
</tr>
<tr>
<td><code>./scripts</code></td>
<td>Scripts, including .c3 scripts that generate code at compile time.</td>
</tr>
<tr>
<td><code>./src</code></td>
<td>Storing our code, by default contains <code>main.c3</code> with “Hello World”.</td>
</tr>
<tr>
<td><code>project.json</code></td>
<td>Record project information, similar to <code>package.json</code> in NodeJS.</td>
</tr>
<tr>
<td><code>LICENSE</code></td>
<td>Project license.</td>
</tr>
<tr>
<td><code>README.md</code></td>
<td>Help others understand and use your code.</td>
</tr>
</tbody>
</table><h3 id="building-on-mac-using-macports-projects-in-c3-building-the-project">🔧 Building the project</h3><p>Assuming you have successfully initialized a project as seen above, we can now look at how to compile it.</p><h4>🏃 Build &amp; run</h4><p>C3 has a simple command to build &amp; run our project.</p><p>```bash {4}
c3c run</p><blockquote>
<p>Program linked to executable ‘build/myc3project’.
Launching ./build/myc3project…
Hello, World
```</p>
</blockquote><p>You can also specify the target to build &amp; run.</p><pre><code class="lang-bash">c<span class="number">3</span>c run myc<span class="number">3</span>project</code></pre><h4>🔧 Build</h4><p>If you only want to build the project, you can use the <code>build</code> command:</p><pre><code class="lang-bash">c<span class="number">3</span>c build</code></pre><p>This command builds the project targets defined in our <code>project.json</code> file.</p><p>:::note
If you want to build a specific target, you can do so by specifying its name.
The default target is created with the name of the project, such as <code>myc3project</code>.</p><pre><code class="lang-bash">c<span class="number">3</span>c build myc<span class="number">3</span>project</code></pre><p>:::</p><p>We will now have a binary in <code>build</code>, which we can run:</p><pre><code class="lang-bash">./build/myc<span class="number">3</span>project</code></pre><p>It should print <code>Hello, World!</code> and return back to the command line prompt. 
If you are on Windows, you will have <code>myc3project.exe</code> instead. Call it in the same way.</p><p>If you need more detail later on check <a href="https://waveproc.github.io/build-your-project/build-commands/">C3 project build commands</a> and <a href="https://waveproc.github.io/build-your-project/project-config/">C3 project configuration</a> to learn more.</p><hr><p>title: Community &amp; Contribute
description: Info regarding the development of C3
sidebar:</p><pre><code>order: 10</code></pre><hr><h2 id="building-on-mac-using-macports-contributions-welcome">Contributions Welcome!</h2><p>The C3 language is still in its <em>development</em> phase, which means 
functionality and specification are subject to change. That also means 
that any contribution right now will have a big impact on the language. 
So if you find the project interesting, here’s what you can do to help:</p><h3 id="building-on-mac-using-macports-contributions-welcome-discuss-the-language">💬 Discuss The Language</h3><ul>
<li>Join us on <a href="https://discord.gg/qN76R87">C3 Discord</a>. </li>
<li>Open a thread on <a href="https://c3lang.discourse.group/">Discourse</a>.</li>
</ul><h3 id="building-on-mac-using-macports-contributions-welcome-suggest-improvements">💡 Suggest Improvements</h3><ul>
<li>Found a bug? <a href="https://github.com/c3lang/c3c/issues/new">File an issue for C3 compiler</a></li>
<li>Spotted a typo or broken link? <a href="https://github.com/c3lang/c3-web/issues/new">File an issue for the website</a></li>
</ul><h3 id="building-on-mac-using-macports-contributions-welcome-contribute">💪 Contribute</h3><p>Now the compiler is stable, what is needed now are the <em>non-essentials</em>, such as a docs generator, editor plugins, LSP etc. </p><ul>
<li><a href="https://github.com/c3lang/c3c/issues/1456">A list of what’s needed is on Github</a>.</li>
<li><a href="https://github.com/c3lang/c3c">Help on the compiler</a>. </li>
<li><a href="https://github.com/c3lang/c3-web">Help on the docs</a>. </li>
</ul><hr><p>title: Basic Types and Values
description: Get an overview of C3’s basic types and values
sidebar:</p><h2 id="building-on-mac-using-macports-order-33">  order: 33</h2><p>C3 provides a similar set of fundamental data types as C: integers, floats, arrays and pointers. On top of this it 
expands on this set by adding slices and vectors, as well as the <code>any</code> and <code>typeid</code> types for advanced use. </p><h2 id="building-on-mac-using-macports-integers">Integers</h2><p>C3 has signed and unsigned integer types. The built-in signed integer types are <code>ichar</code>, <code>short</code>, <code>int</code>, <code>long</code>,
<code>int128</code>, <code>iptr</code> and <code>isz</code>. <code>ichar</code> to <code>int128</code> have all well-defined power-of-two bit sizes, whereas <code>iptr</code>
has the same number of bits as a <code>void*</code> and <code>isz</code> has the same number of bits as the maximum difference 
between two pointers. For each signed integer type there is a corresponding unsigned integer type: <code>char</code>, 
<code>ushort</code>, <code>uint</code>, <code>ulong</code>, <code>uint128</code>, <code>uptr</code> and <code>usz</code>.</p><table>
<thead>
<tr>
<th>type</th>
<th>signed?</th>
<th>min</th>
<th>max</th>
<th>bits</th>
</tr>
</thead>
<tbody>
<tr>
<td>ichar</td>
<td>yes</td>
<td>-128</td>
<td>127</td>
<td>8</td>
</tr>
<tr>
<td>short</td>
<td>yes</td>
<td>-32768</td>
<td>32767</td>
<td>16</td>
</tr>
<tr>
<td>int</td>
<td>yes</td>
<td>-2^31</td>
<td>2^31 - 1</td>
<td>32</td>
</tr>
<tr>
<td>long</td>
<td>yes</td>
<td>-2^63</td>
<td>2^63 - 1</td>
<td>64</td>
</tr>
<tr>
<td>int128</td>
<td>yes</td>
<td>-2^127</td>
<td>2^127 - 1</td>
<td>128</td>
</tr>
<tr>
<td>iptr</td>
<td>yes</td>
<td>varies</td>
<td>varies</td>
<td>varies</td>
</tr>
<tr>
<td>isz</td>
<td>yes</td>
<td>varies</td>
<td>varies</td>
<td>varies</td>
</tr>
<tr>
<td>char</td>
<td>no</td>
<td>0</td>
<td>255</td>
<td>8</td>
</tr>
<tr>
<td>ushort</td>
<td>no</td>
<td>0</td>
<td>65535</td>
<td>16</td>
</tr>
<tr>
<td>uint</td>
<td>no</td>
<td>0</td>
<td>2^32 - 1</td>
<td>32</td>
</tr>
<tr>
<td>ulong</td>
<td>no</td>
<td>0</td>
<td>2^64 - 1</td>
<td>64</td>
</tr>
<tr>
<td>uint128</td>
<td>no</td>
<td>0</td>
<td>2^128 - 1</td>
<td>128</td>
</tr>
<tr>
<td>uptr</td>
<td>no</td>
<td>0</td>
<td>varies</td>
<td>varies</td>
</tr>
<tr>
<td>usz</td>
<td>no</td>
<td>0</td>
<td>varies</td>
<td>varies</td>
</tr>
</tbody>
</table><p>On 64-bit machines <code>iptr</code>/<code>uptr</code> and <code>isz</code>/<code>usz</code> are usually 64-bits, like <code>long</code>/<code>ulong</code>. 
On 32-bit machines on the other hand they are generally <code>int</code>/<code>uint</code>.</p><h3 id="building-on-mac-using-macports-integers-integer-constants">Integer constants</h3><p>Numeric constants typically use decimal, e.g. <code>234</code>, but may also use hexadecimal (base 16) numbers by prefixing
the number with <code>0x</code> or <code>0X</code>, e.g. <code>int a = 0x42edaa02;</code>. There is also octal (base 8) using the 
<code>0o</code> or <code>0O</code> prefix, and <code>0b</code> for binary (base 2) numbers:</p><p>Numbers may also insert underscore <code>_</code> between digits to improve readability, e.g. <code>1_000_000</code>.</p><pre><code class="lang-c3">a = -<span class="number">2</span>_<span class="number">000</span>;
b = <span class="number">0</span>o<span class="number">770</span>;
c = <span class="number">0</span>x<span class="number">7</span>f<span class="number">7</span>f<span class="number">7</span>f;</code></pre><p>For decimal numbers, the value is assumed to be a signed <code>int</code>, unless the number doesn’t fit in an
<code>int</code>, in which case it is assumed to be the smallest signed type it <em>does</em> fit in (<code>long</code> or <code>int128</code>).</p><p>For hexadecimal, octal and binary, the type is assumed to be unsigned.</p><p>A integer literal can <em>implicitly</em> convert to a floating point literal, or an integer of 
a different type provided the number fits in the type.</p><h3 id="building-on-mac-using-macports-integers-constant-suffixes">Constant suffixes</h3><p>If you want to ensure that a constant is of a certain type, you can either add an explicit cast 
like: <code>(ushort)345</code>, or use an integer suffix: <code>345u16</code>.</p><p>The following integer suffixes are available:</p><table>
<thead>
<tr>
<th>suffix</th>
<th align="right">type</th>
</tr>
</thead>
<tbody>
<tr>
<td>i8</td>
<td align="right">ichar</td>
</tr>
<tr>
<td>i16</td>
<td align="right">short</td>
</tr>
<tr>
<td>i32</td>
<td align="right">int</td>
</tr>
<tr>
<td>i64</td>
<td align="right">long</td>
</tr>
<tr>
<td>i128</td>
<td align="right">int128</td>
</tr>
<tr>
<td>u8</td>
<td align="right">char</td>
</tr>
<tr>
<td>u16</td>
<td align="right">ushort</td>
</tr>
<tr>
<td>u32</td>
<td align="right">uint</td>
</tr>
<tr>
<td>u</td>
<td align="right">uint</td>
</tr>
<tr>
<td>u64</td>
<td align="right">ulong</td>
</tr>
<tr>
<td>u128</td>
<td align="right">uint128</td>
</tr>
</tbody>
</table><p>Note how <code>uint</code> also has the <code>u</code> suffix.</p><h2 id="building-on-mac-using-macports-booleans">Booleans</h2><p>A <code>bool</code> will be either <code>true</code> or <code>false</code>. Although a bool is only a single bit of data, 
it should be noted that it is stored in a byte.</p><pre><code class="lang-c">bool b = true;
bool f = false;</code></pre><h3 id="building-on-mac-using-macports-booleans-character-literals">Character literals</h3><p>A character literal is a value enclosed in <code>''</code>. Its value is interpreted as being its 
ASCII value for a single character. </p><p>It is also possible to use 2, 4 or 8 character wide character literals. Such are interpreted
as <code>ushort</code>, <code>uint</code> and <code>ulong</code> respectively and are laid out in memory from left to right.
This means that the actual value depends on the <a href="https://en.wikipedia.org/wiki/Endianness">endianness</a>
of the target.</p><ul>
<li>2 character literals, e.g. <code>'C3'</code>, would convert to an ushort.</li>
<li>4 character literals, e.g. <code>'TEST'</code>, converts to an uint.</li>
<li>8 character literals, e.g. <code>'FOOBAR11'</code> converts to an ulong.</li>
</ul><p>The 4 character literals correspond to the layout of <a href="https://en.wikipedia.org/wiki/FourCC">FourCC</a>
codes. It will also correctly arrange unicode characters in memory. E.g. <code>Char32 smiley = '\u1F603'</code></p><h2 id="building-on-mac-using-macports-floating-point-types">Floating point types</h2><p>As is common, C3 has two floating point types: <code>float</code> and <code>double</code>. <code>float</code> is the 32 bit floating
point type and <code>double</code> is 64 bits. </p><h3 id="building-on-mac-using-macports-floating-point-types-floating-point-constants">Floating point constants</h3><p>Floating point constants will <em>at least</em> use 64 bit precision. 
Just like for integer constants, it is possible to use <code>_</code> to improve
readability, but it may not occur immediately before or after a dot or an exponential.</p><p>C3 supports floating points values either written in decimal or hexadecimal formats. 
For decimal, the exponential symbol is e (or E, both are acceptable), 
for hexadecimal p (or P) is used: <code>-2.22e-21</code> <code>-0x21.93p-10</code></p><p>While floating point numbers default to <code>double</code> it is possible to type a 
floating point by adding a suffix:</p><table>
<thead>
<tr>
<th>Suffix</th>
<th align="right">type</th>
</tr>
</thead>
<tbody>
<tr>
<td>f32 <em>or</em> f</td>
<td align="right">float</td>
</tr>
<tr>
<td>f64</td>
<td align="right">double</td>
</tr>
</tbody>
</table><h2 id="building-on-mac-using-macports-arrays">Arrays</h2><p><a href="https://waveproc.github.io/language-common/arrays/">Arrays</a> have the format <code>Type[size]</code>, so for example: <code>int[4]</code>. An array is a type consisting
of the same element repeated a number of times. Our <code>int[4]</code> is essentially four <code>int</code> values
packed together.</p><p>For initialization it’s sometimes convenient to use the wildcard <code>Type[*]</code> declaration, which
infers the length from the number of elements:</p><pre><code class="lang-c3">int[<span class="number">3</span>] abc = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }; <span class="comment">// Explicit int[<span class="number">3</span>]</span>
int[*] bcd = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }; <span class="comment">// Implicit int[<span class="number">3</span>]</span></code></pre><h2 id="building-on-mac-using-macports-slices">Slices</h2><p><a href="https://waveproc.github.io/language-common/arrays/#slice">Slices</a> have the format <code>Type[]</code>. Unlike the array, a slice does not hold the values themselves
but instead presents a view of some underlying array or vector.</p><p>Slices have two properties: <code>.ptr</code>, which retrieves the array it points to, and <code>.len</code> which
is the length of the slice - that is, the number of elements it is possible to index into.</p><p>Usually we can get a slice by taking the address of an array:</p><pre><code class="lang-c3">int[<span class="number">3</span>] abc = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }; 
int[] slice = &amp;abc;       <span class="comment">// A slice pointing to abc with length <span class="number">3</span></span></code></pre><p>Because indexing into slices is range checked in safe mode, slices are vastly more safe
providing pointer + length separately.</p><h2 id="building-on-mac-using-macports-vectors">Vectors</h2><p><a href="https://waveproc.github.io/language-common/vectors/">Vectors</a> similar to arrays, use the format 
<code>Type[&lt;size&gt;]</code>, with the restriction that vectors may only form out
of integers, floats and booleans. Similar to arrays, wildcard can be 
used to infer the size of a vector: </p><pre><code class="lang-c3">int[&lt;*&gt;] a = { <span class="number">1</span>, <span class="number">2</span> };</code></pre><p>Vectors are based on hardware SIMD vectors, and supports many different operations that work
on all elements in parallel, including arithmetics:</p><pre><code class="lang-c3">int[&lt;<span class="number">2</span>&gt;] b = { <span class="number">3</span>, <span class="number">8</span> };
int[&lt;<span class="number">2</span>&gt;] c = { <span class="number">7</span>, <span class="number">2</span> };
int[&lt;<span class="number">2</span>&gt;] d = b * c;    <span class="comment">// d is { <span class="number">21</span>, <span class="number">16</span> }</span></code></pre><p>Vector initialization and literals work the same way as arrays, using <code>{ ... }</code></p><h2 id="building-on-mac-using-macports-string-literals">String literals</h2><p>String literals are special and can convert to several different types: 
<code>String</code>, <code>char</code> and <code>ichar</code> arrays and slices and finally <code>ichar*</code> and <code>char*</code>.</p><p>String literals are text enclosed in <code>" "</code> just like in C. These support
escape sequences like <code>\n</code> for line break and need to use <code>\"</code> for any <code>"</code> inside of the
string.</p><p>C3 also offers <em>raw strings</em> which are enclosed in <code>` ` </code>. 
A raw string may span multiple lines.
Inside of a raw string, no escapes are available, and to write a <code>` </code>, simply double the character:</p><pre><code class="lang-c3"><span class="comment">// Note: String is a distinct inline char[]</span>
String three_lines = 
`multi
line
string`;

String foo = `C:\foo\bar.dll`;
String bar = `<span class="string">"Say ``hello``"</span>`;
<span class="comment">// Same as</span>
String foo = <span class="string">"C:\\foo\\bar.dll"</span>;
String bar = <span class="string">"\"</span>Say `hello`\<span class="string">""</span>;</code></pre><p><code>String</code> is a 
<a href="https://waveproc.github.io/language-common/define/#distinct-inline">distinct inline</a> <code>char[]</code>, which can implicitly convert to <code>char[]</code> when required. </p><p><code>ZString</code> is a <a href="https://waveproc.github.io/language-common/define/#distinct-inline">distinct inline</a> <code>char*</code>.<code>ZString</code> is a C compatible null terminated string, which can implicitly convert to <code>char*</code> when required.</p><h2 id="building-on-mac-using-macports-base64-and-hex-data-literals">Base64 and hex data literals</h2><p>Base64 literals are strings prefixed with <code>b64</code> to containing
<a href="https://en.wikipedia.org/wiki/Base64">Base64 encoded</a> data, which
is converted into a char array at compile time:</p><pre><code class="lang-c3"><span class="comment">// The array below contains the characters <span class="string">"Hello World!"</span></span>
char[*] hello_world_base<span class="number">64</span> = b<span class="number">64</span><span class="string">"SGVsbG<span class="number">8</span>gV<span class="number">29</span>ybGQh"</span>;</code></pre><p>The corresponding hex data literals convert a hexadecimal string rather than Base64:</p><pre><code class="lang-c3"><span class="comment">// The array below contains the characters <span class="string">"Hello World!"</span></span>
char[*] hello_world_hex = x<span class="string">"<span class="number">4865</span> <span class="number">6</span>c<span class="number">6</span>c <span class="number">6</span>f<span class="number">20</span> <span class="number">776</span>f <span class="number">726</span>c <span class="number">6421</span>"</span>;</code></pre><h2 id="building-on-mac-using-macports-pointer-types">Pointer types</h2><p>Pointers have the syntax <code>Type*</code>. A pointer is a memory address where one or possibly more
elements of the underlying address are stored. Pointers can be stacked: <code>Foo*</code> is a pointer to a <code>Foo</code>
while <code>Foo**</code> is a pointer to a pointer to <code>Foo</code>.</p><p>The pointer type has a special literal called <code>null</code>, which is an invalid, empty pointer.</p><h3 id="building-on-mac-using-macports-pointer-types-void"><code>void*</code></h3><p>The <code>void*</code> type is a special pointer which implicitly converts to any other pointer. It is not “a pointer to void”,
but rather a wildcard pointer which matches any other pointer.</p><h2 id="building-on-mac-using-macports-printing-values">Printing values</h2><p>Printing values can be done using <code>io::print</code>, <code>io::printn</code>, <code>io::printf</code> and <code>io::printfn</code>. This requires
importing the module <code>std::io</code>. </p><p>:::note
The <code>n</code> variants of the print functions will add a newline after printing, which is what we’ll often 
use in the examples, but <code>print</code> and <code>printf</code> work the same way.</p><p>:::</p><pre><code class="lang-c3">import std::io; <span class="comment">// Get the io functions.</span>

fn void main()
{
    int a = <span class="number">1234</span>;
    ulong b = <span class="number">0</span>xFFAABBCCDDEEFF;
    double d = <span class="number"><span class="number">13</span>.<span class="number">03</span></span>e-<span class="number">04</span>;
    char[*] hex = x<span class="string">"<span class="number">4865</span> <span class="number">6</span>c<span class="number">6</span>c <span class="number">6</span>f<span class="number">20</span> <span class="number">776</span>f <span class="number">726</span>c <span class="number">6421</span>"</span>;
    io::printn(a);
    io::printn(b);
    io::printn(d);
    io::printn(hex);
}</code></pre><p>If you run this program you will get:</p><pre><code>1234
71963842633920255
0.001303
[72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33]</code></pre><p>To get more control we can format the output using <code>printf</code> and <code>printfn</code>:</p><pre><code class="lang-c3">import std::io;
fn void main()
{
    int a = <span class="number">1234</span>;
    ulong b = <span class="number">0</span>xFFAABBCCDDEEFF;
    double d = <span class="number"><span class="number">13</span>.<span class="number">03</span></span>e-<span class="number">04</span>;
    char[*] hex = x<span class="string">"<span class="number">4865</span> <span class="number">6</span>c<span class="number">6</span>c <span class="number">6</span>f<span class="number">20</span> <span class="number">776</span>f <span class="number">726</span>c <span class="number">6421</span>"</span>;
    io::printfn(<span class="string">"a was:                        %d"</span>, a);
    io::printfn(<span class="string">"b in hex was:                 %x"</span>, b);
    io::printfn(<span class="string">"d in scientific notation was: %e"</span>, d);
    io::printfn(<span class="string">"Bytes as string:              %s"</span>, (String)&amp;hex);
}</code></pre><p>We can apply the <a href="https://en.cppreference.com/w/c/io/fprintf">standard printf formatting rules</a>, but 
unlike in C/C++ there is no need to indicate the type when using <code>%d</code> - it will print unsigned and 
signed up to <code>int128</code>, in fact there is no support for <code>%u</code>, <code>%lld</code> etc in <code>io::printf</code>. Furthermore,
<code>%s</code> works not just on strings but on any type:</p><pre><code class="lang-c3">import std::io;

enum Foo
{
    ABC,
    BCD,
    EFG,
}
fn void main()
{
    int a = <span class="number">1234</span>;
    uint<span class="number">128</span> b = <span class="number">0</span>xFFEEDDCC_BBAA<span class="number">9988</span>_<span class="number">77665544</span>_<span class="number">33221100</span>;
    Foo foo = BCD;
    io::printfn(<span class="string">"a: %s, b: %d, foo: %s"</span>, a, b, foo);
}</code></pre><p>This prints:</p><pre><code>a: 1234, b: 340193404210632335760508365704335069440, foo: BCD</code></pre><hr><p>title: Comments &amp; Documentation
description: Comments &amp; Documentation
sidebar:</p><pre><code>order: 40</code></pre><hr><p>C3 uses three distinct comment types:</p><ol>
<li>The normal <code>//</code> single line comment.</li>
<li>The classic <code>/* ... */</code> multi-line C style comment, but unlike in C they are allowed to nest.</li>
<li>Documentation comments <code>&lt;* ... *&gt;</code> the text within these comments will be parsed as documentation and optional <a href="https://waveproc.github.io/language-common/contracts/">Contracts</a> on the following code.</li>
</ol><h2 id="building-on-mac-using-macports-doc-contracts">Doc contracts</h2><p>Documentation contracts start with <code>&lt;*</code> and must be terminated using <code>*&gt;</code>.
Any initial text up until the first <code>@</code>-directive on a new line will be interpreted as
free text documentation.</p><p>For example:</p><pre><code class="lang-c3">&lt;*
 Here are some docs.
 @param num_foo `The number of foos.`
 @require num_foo &gt; <span class="number">4</span> 
 @deprecated
 @mycustom <span class="number">2</span>
*&gt;
void bar(int num_foo)
{
    io::printfn(<span class="string">"%d"</span>, num_foo);
}</code></pre><h3 id="building-on-mac-using-macports-doc-contracts-doc-contracts-are-parsed">Doc Contracts Are Parsed</h3><p>The following was extracted:
- The function description: <em>“Here are some docs.”</em>
- The <code>num_foo</code> parameter has the description: <em>“The number of foos”</em>.
- A <a href="https://waveproc.github.io/language-common/contracts/">Contract</a> annotation for the compiler: <code>@require num_foo &gt; 4</code> which tells the compiler and a user of the function that a precondition is that <code>num_foo</code> must be greater than 4.
- A function <a href="https://waveproc.github.io/language-common/attributes/">Attribute</a> marking it as <code>@deprecated</code>, which displays warnings.
- A custom function <a href="https://waveproc.github.io/language-common/attributes/">Attribute</a> <code>@mycustom</code>.
 The compiler is free to silently ignore custom Attributes, they can be 
used to optionally emit warnings, but are otherwise ignored.</p><h3 id="building-on-mac-using-macports-doc-contracts-available-annotations">Available annotations</h3><table>
<thead>
<tr>
<th>Name</th>
<th align="right">format</th>
</tr>
</thead>
<tbody>
<tr>
<td>@param</td>
<td align="right"><code>@param &lt;param&gt; &lt;description&gt;</code></td>
</tr>
<tr>
<td>@return</td>
<td align="right"><code>@return &lt;description&gt;</code></td>
</tr>
<tr>
<td>@return!</td>
<td align="right"><code>@return! &lt;fault1&gt;, &lt;fault2&gt;, ...</code></td>
</tr>
<tr>
<td>@deprecated</td>
<td align="right"><code>@deprecated &lt;optional description&gt;</code></td>
</tr>
<tr>
<td>@require</td>
<td align="right"><code>@require &lt;expr1&gt;, &lt;expr2&gt;, ...</code></td>
</tr>
<tr>
<td>@ensure</td>
<td align="right"><code>@ensure &lt;expre1&gt;, &lt;expr2&gt;, ...</code></td>
</tr>
<tr>
<td>@pure</td>
<td align="right"><code>@pure</code></td>
</tr>
</tbody>
</table><p>See <a href="https://waveproc.github.io/language-common/contracts/">Contracts</a> for information regarding <code>@require</code>, <code>@ensure</code>, <code>@const</code>, <code>@pure</code>, <code>@checked</code>.</p><hr><p>title: Naming Rules
description: Naming Rules
sidebar:</p><pre><code>order: 41</code></pre><hr><p>C3 introduces fairly rigid naming rules to reduce ambiguity and make the language easy to parse for tools. </p><p>As a basic rule, all identifiers are limited to a-z, A-Z, 0-9 and <code>_</code>. The initial character can not be a number. Furthermore, all identifiers are limited to 31 character.</p><h3 id="building-on-mac-using-macports-doc-contracts-structs-unions-enums-and-faults">Structs, unions, enums and faults</h3><p>All user defined types must start with A-Z after any optional initial <code>_</code> and include at least 1 lower case letter. <code>Bar</code>, <code>_T_i12</code> and <code>TTi</code> are all valid names. <code>_1</code>, <code>bAR</code> and <code>BAR</code> are not. For C-compatibility it’s possible to alias the type to a external name using the attribute “extern”.</p><pre><code class="lang-c3">struct Foo @extern(<span class="string">"foo"</span>)
{
    int x;
    Bar bar;
}

union Bar 
{
    int i;
    double d;
}

enum Baz 
{
    VALUE_<span class="number">1</span>,
    VALUE_<span class="number">2</span>
}

fault Err 
{
    OOPS,
    LOTS_OF_OOPS
}</code></pre><h3 id="building-on-mac-using-macports-doc-contracts-variables-and-parameters">Variables and parameters</h3><p>All variables and parameters <em>except for</em> global constant variables must start with a-z after any optional initial <code>_</code>. <code>___a</code> <code>fooBar</code> and <code>_test_</code> are all valid variable / parameter names. <code>_</code>, <code>_Bar</code>, <code>X</code> are not.</p><pre><code class="lang-c3">int theGlobal = <span class="number">1</span>;

fn void foo(int x)
{
    Foo foo = getFoo(x);    
    theGlobal++;
}</code></pre><h3 id="building-on-mac-using-macports-doc-contracts-global-constants">Global constants</h3><p>Global constants must start with A-Z after any optional initial <code>_</code>. <code>_FOO2</code>, <code>BAR_FOO</code>, <code>X</code> are all valid global constants, <code>_</code>, <code>_bar</code>, <code>x</code> are not. </p><pre><code class="lang-c3">const int A_VALUE = <span class="number">12</span>;</code></pre><h3 id="building-on-mac-using-macports-doc-contracts-enum-fault-values">Enum / Fault values</h3><p>Enum and fault values follow the same naming standard as global constants.</p><pre><code class="lang-c3">enum Baz 
{
    VALUE_<span class="number">1</span>,
    VALUE_<span class="number">2</span>
}

fault Err 
{
    OOPS,
    LOTS_OF_OOPS
}</code></pre><h3 id="building-on-mac-using-macports-doc-contracts-struct-union-members">Struct / union members</h3><p>Struct and union members follow the same naming rules as variables.</p><h3 id="building-on-mac-using-macports-doc-contracts-modules">Modules</h3><p>Module names may contain a-z, 0-9 and <code>_</code>, no upper case characters are allowed.</p><pre><code>module foo;</code></pre><h3 id="building-on-mac-using-macports-doc-contracts-functions-and-macros">Functions and macros</h3><p>Functions and macros must start with a-z after any optional initial <code>_</code>.</p><pre><code class="lang-c3">fn void theMostAmazingFunction() 
{ 
    return;
}

macro justDoIt(x) 
{
    justDo(x);
}</code></pre><hr><p>title: Variables
description: Variables
sidebar:</p><pre><code>order: 41</code></pre><hr><h3 id="building-on-mac-using-macports-doc-contracts-zero-init-by-default">Zero init by default</h3><p>Unlike C, C3 local variables are zero-initialized by default. To avoid zero initialization, you need to explicitly opt-out.</p><pre><code class="lang-c3">int x;               <span class="comment">// x = <span class="number">0</span></span>
int y @noinit;       <span class="comment">// y is explicitly undefined and must be assigned before use.</span>

AStruct foo;         <span class="comment">// foo is implicitly zeroed</span>
AStruct bar = {};    <span class="comment">// bar is explicitly zeroed</span>
AStruct baz @noinit; <span class="comment">// baz is explicitly undefined</span></code></pre><p>Using a variable that is explicitly undefined before will trap or be initialized to a 
specific value when compiling “safe” and is undefined behaviour in “fast” builds.</p><hr><p>title: Expressions
description: Expressions
sidebar:</p><pre><code>order: 42</code></pre><hr><p>Expressions work like in C, with one exception: it is possible to take the address of a temporary. This uses the operator <code>&amp;&amp;</code> rather than <code>&amp;</code>.</p><p>Consequently, this is valid:</p><pre><code class="lang-c3">fn void test(int* x) { ... }

test(&amp;&amp;<span class="number">1</span>);

<span class="comment">// In C:</span>
<span class="comment">// int x = <span class="number">1</span>;</span>
<span class="comment">// test(&amp;x);</span></code></pre><h2 id="building-on-mac-using-macports-well-defined-evaluation-order">Well-defined evaluation order</h2><p>Expressions have a well-defined evaluation order:</p><ol>
<li>Binary expressions are evaluated from left to right.</li>
<li>Assignment occurs right to left, so <code>a = a++</code> would result in <code>a</code> being unchanged.</li>
<li>Call arguments are evaluated in parameter order.</li>
</ol><h2 id="building-on-mac-using-macports-compound-literals">Compound literals</h2><p>C3 has C’s compound literals, but unlike C’s cast style syntax <code>(MyStruct) { 1, 2 }</code>, 
it uses C++ syntax: <code>MyStruct { 1, 2 }</code>.</p><pre><code class="lang-c3">struct Foo
{
    int a;
    double b;
}

fn void test<span class="number">1</span>(Foo x) { ... }

... 

test<span class="number">1</span>(Foo { <span class="number">1</span>, <span class="number"><span class="number">2</span>.<span class="number">0</span></span> });</code></pre><p>Arrays follow the same syntax:</p><pre><code class="lang-c3">fn void test<span class="number">2</span>(int[<span class="number">3</span>] x) { ... }

...

test<span class="number">2</span>(int[<span class="number">3</span>] { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });</code></pre><p>Note that when it’s possible, inferring the type is allowed, so we have for the above examples:</p><pre><code class="lang-c3">test<span class="number">1</span>({ <span class="number">1</span>, <span class="number"><span class="number">2</span>.<span class="number">0</span></span> });
test<span class="number">2</span>({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });</code></pre><p>One may take the address of temporaries, using <code>&amp;&amp;</code> (rather than <code>&amp;</code> for normal variables). This allows the following:</p><p>Passing a <a href="https://waveproc.github.io/language-common/arrays/#slice">slice</a></p><pre><code class="lang-c3">fn void test(int[] y) { ... }

<span class="comment">// Using &amp;&amp;</span>
test(&amp;&amp;int[<span class="number">3</span>]{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });

<span class="comment">// Explicitly slicing:</span>
test(int[<span class="number">3</span>]{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> }[..]);

<span class="comment">// Using a slice directly as a temporary:</span>
test(int[]{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });

<span class="comment">// Same as above but with inferred type:</span>
test({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });</code></pre><p>Passing the pointer to an <a href="https://waveproc.github.io/language-common/arrays">array</a></p><pre><code class="lang-c3">fn void test<span class="number">1</span>(int[<span class="number">3</span>]* z) { ... }
fn void test<span class="number">2</span>(int* z) { ... }

test<span class="number">1</span>(&amp;&amp;int[<span class="number">3</span>]{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });
test<span class="number">2</span>(&amp;&amp;int[<span class="number">3</span>]{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });</code></pre><h2 id="building-on-mac-using-macports-constant-expressions">Constant expressions</h2><p>In C3 all <em>constant expressions</em> are guaranteed to be calculated at compile time. The following are considered constant expressions:</p><ol>
<li>The <code>null</code> literal.</li>
<li>Boolean, floating point and integer literals.</li>
<li>The result of arithmetics on constant expressions.</li>
<li>Compile time variables (prefixed with <code>$</code>)</li>
<li>Global constant variables with initializers that are constant expressions.</li>
<li>The result of macros that does not generate code and only uses constant expressions.</li>
<li>The result of a cast if the value is cast to a boolean, floating 
point or integer type and the value that is converted is a constant 
expression.</li>
<li>String literals.</li>
<li>Initializer lists containing constant values.</li>
</ol><p>Some things that are <em>not</em> constant expressions:</p><ol>
<li>Any pointer that isn’t the <code>null</code> literal, even if it’s derived from a constant expression.</li>
<li>The result of a cast except for casts of constant expressions to a numeric type.</li>
<li>Compound literals - even when values are constant expressions.</li>
</ol><h2 id="building-on-mac-using-macports-including-binary-data">Including binary data</h2><p>The <code>$embed(...)</code> function includes the contents of a file into the compilation as a
constant array of bytes:</p><pre><code class="lang-c3">char[*] my_image = $embed(<span class="string">"my_image.png"</span>);</code></pre><p>The result of an embed work similar to a string literal and can implicitly convert to a <code>char*</code>, 
<code>void*</code>, <code>char[]</code>, <code>char[*]</code> and <code>String</code>.</p><h5>Limiting length</h5><p>It’s possible to limit the length of included with the optional second parameter.</p><pre><code class="lang-c3">char[<span class="number">4</span>] my_data = $embed(<span class="string">"foo.txt"</span>, <span class="number">4</span>);</code></pre><h5>Failure to load at compile time and defaults</h5><p>Usually it’s a compile time error if the file can’t be included, but sometimes it’s useful to only optionally include it. 
If this is desired, declare the left hand side an <a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">Optional</a>:</p><pre><code class="lang-c3">char[]! my_image = $embed(<span class="string">"my_image.png"</span>);</code></pre><p><code>my_image</code> with be an optional <code>IoError.FILE_NOT_FOUND?</code> if the image is missing.</p><p>This also allows us to pass a <a href="https://waveproc.github.io/language-common/optionals-advanced/#return-a-default-value-if-optional-is-empty">default value using <code>??</code></a>:</p><pre><code class="lang-c3">char[] my_image = $embed(<span class="string">"my_image.png"</span>) ?? DEFAULT_IMAGE_DATA;</code></pre><hr><p>title: Statements
description: Statements
sidebar:</p><pre><code>order: 43</code></pre><hr><p>Statements largely work like in C, but with some additions.</p><h2 id="building-on-mac-using-macports-expression-blocks">Expression blocks</h2><p>Expression blocks (delimited using <code>{| |}</code>) are compound statements that opens their own function scope.
Jumps cannot be done into or out of a function block, and <code>return</code> exits the block, rather than the function as a whole.</p><p>The function below prints <code>World!</code></p><pre><code class="lang-c3">fn void test()
{
    int a = <span class="number">0</span>;
    {|
        if (!a) return;
        io::printf(<span class="string">"Hello "</span>);
        return;
    |};
    io::printf(<span class="string">"World!\n"</span>);
}</code></pre><p>Expression blocks may also return values:</p><pre><code class="lang-c3">fn void test(int x)
{
    int a = {|
        if (x &gt; <span class="number">0</span>) return x * <span class="number">2</span>;
        if (x == <span class="number">0</span>) return <span class="number">100</span>;
        return -x;
    |};            
    io::printfn(<span class="string">"The result was %d"</span>, a);
}</code></pre><h2 id="building-on-mac-using-macports-labelled-break-and-continue">Labelled break and continue</h2><p>Labelled <code>break</code> and <code>continue</code> lets you break out of an outer scope. Labels can be put on <code>if</code>, 
<code>switch</code>, <code>while</code> and <code>do</code> statements.</p><pre><code class="lang-c3">fn void test(int i)
{
    if FOO: (i &gt; <span class="number">0</span>)
    {
        while (<span class="number">1</span>)
        {
            io::printfn(<span class="string">"%d"</span>, i);
            <span class="comment">// Break out of the top if statement.</span>
            if (i++ &gt; <span class="number">10</span>) break FOO;
        }
    }
}</code></pre><h2 id="building-on-mac-using-macports-do-without-while">Do-without-while</h2><p>Do-while statements can skip the ending <code>while</code>. In that case it acts as if the <code>while</code> was <code>while(0)</code>:</p><pre><code class="lang-c3">do 
{
    io::printn(<span class="string">"FOO"</span>);
} while (<span class="number">0</span>);

<span class="comment">// Equivalent to the above.</span>
do 
{
    io::printn(<span class="string">"FOO"</span>);
};</code></pre><h2 id="building-on-mac-using-macports-nextcase-and-labelled-nextcase">Nextcase and labelled nextcase</h2><p>The <code>nextcase</code> statement is used in <code>switch</code> and <code>if-catch</code> to jump to the next statement:</p><pre><code class="lang-c3">switch (i)
{
    case <span class="number">1</span>:
        doSomething();
        nextcase; <span class="comment">// Jumps to case <span class="number">2</span></span>
    case <span class="number">2</span>:
        doSomethingElse();
}</code></pre><p>It’s also possible to use <code>nextcase</code> with an expression, to jump to an arbitrary case:</p><pre><code class="lang-c3">switch (i)
{
    case <span class="number">1</span>:
        doSomething();
        nextcase <span class="number">3</span>; <span class="comment">// Jump to case <span class="number">3</span></span>
    case <span class="number">2</span>:
        doSomethingElse();
    case <span class="number">3</span>:
        nextcase rand(); <span class="comment">// Jump to random case</span>
    default:
        io::printn(<span class="string">"Ended"</span>);
}</code></pre><p>Which can be used as structured <code>goto</code> when creating state machines.</p><h2 id="building-on-mac-using-macports-switch-cases-with-runtime-evaluation">Switch cases with runtime evaluation</h2><p>It’s possible to use <code>switch</code> as an enhanced if-else chain:</p><pre><code class="lang-c3">switch (true)
{
    case x &lt; <span class="number">0</span>:
        xless();
    case x &gt; <span class="number">0</span>:
        xgreater();
    default:
        xequals();
}</code></pre><p>The above would be equivalent to writing:</p><pre><code class="lang-c3">if (x &lt; <span class="number">0</span>)
{
    xless();
}
else if (x &gt; <span class="number">0</span>)
{
    xgreater();
}
else
{
    xequals();
}</code></pre><p>Note that because of this, the first match is always picked. Consider:</p><pre><code class="lang-c3">switch (true)
{
    case x &gt; <span class="number">0</span>:
        foo();
    case x &gt; <span class="number">2</span>:
        bar();
}</code></pre><p>Because of the evaluation order, only <code>foo()</code> will be invoked for x &gt; 0, even when x is greater than 2.</p><p>It’s also possible to omit the conditional after <code>switch</code>. In that case it is implicitly assumed to be same as
writing <code>(true)</code></p><pre><code class="lang-c3">switch
{
    case foo() &gt; <span class="number">0</span>:
        bar();
    case test() == <span class="number">1</span>:
        baz();
}</code></pre><hr><p>title: Functions
description: Functions
sidebar:</p><pre><code>order: 45</code></pre><hr><p>C3 has both regular 
functions and member functions. Member functions are functions 
namespaced using type names, and allows invocations using the dot 
syntax.</p><h2 id="building-on-mac-using-macports-regular-functions">Regular functions</h2><p>Regular functions are the same as C aside from the keyword <code>fn</code>, which is followed by the conventional C declaration of <code>&lt;return type&gt; &lt;name&gt;(&lt;parameter list&gt;)</code>.</p><pre><code class="lang-c3">fn void test(int times)
{
    for (int i = <span class="number">0</span>; i &lt; times; i++)
    {
        io::printfn(<span class="string">"Hello %d"</span>, i);
    }
}</code></pre><h3 id="building-on-mac-using-macports-regular-functions-function-arguments">Function arguments</h3><p>C3 allows use of default arguments as well as named arguments. Note that
any unnamed arguments must appear before any named arguments.</p><pre><code class="lang-c3">fn int test_with_default(int foo = <span class="number">1</span>)
{
    return foo;
}

fn void test()
{
    test_with_default();
    test_with_default(<span class="number">100</span>);
}</code></pre><p>Named arguments</p><pre><code class="lang-c3">fn void test_named(int times, double data)
{
    for (int i = <span class="number">0</span>; i &lt; times; i++)
    {
        io::printf(<span class="string">"Hello %d\n"</span>, i + data);
    }
}

fn void test()
{
    <span class="comment">// Named only</span>
    test_named(times: <span class="number">1</span>, data: <span class="number"><span class="number">3</span>.<span class="number">0</span></span>);

    <span class="comment">// Unnamed only</span>
    test_named(<span class="number">3</span>, <span class="number"><span class="number">4</span>.<span class="number">0</span></span>);

    <span class="comment">// Mixing named and unnamed        </span>
    test_named(<span class="number">15</span>, data: <span class="number"><span class="number">3</span>.<span class="number">141592</span></span>);
}</code></pre><p>Named arguments with defaults:</p><pre><code class="lang-c3">fn void test_named_default(int times = <span class="number">1</span>, double data = <span class="number"><span class="number">3</span>.<span class="number">0</span></span>, bool dummy = false)
{
    for (int i = <span class="number">0</span>; i &lt; times; i++)
    {
        io::printfn(<span class="string">"Hello %f"</span>, i + data);
    }
}

fn void test()
{
    <span class="comment">// Named only</span>
    test_named_default(times: <span class="number">10</span>, data: <span class="number"><span class="number">3</span>.<span class="number">5</span></span>);

    <span class="comment">// Unnamed and named</span>
    test_named_default(<span class="number">3</span>, dummy: false);

    <span class="comment">// Overwriting an unnamed argument with a named argument is an error:</span>
    <span class="comment">// test_named_default(<span class="number">2</span>, times: <span class="number">3</span>); ERROR!</span>

    <span class="comment">// Unnamed may not follow named arguments.</span>
    <span class="comment">// test_named_default(times: <span class="number">3</span>, <span class="number"><span class="number">4</span>.<span class="number">0</span></span>); ERROR!</span>
}</code></pre><h4>Varargs</h4><p>There are four types of varargs: </p><ol>
<li>single typed</li>
<li>explicitly typed any: pass non-any arguments as references</li>
<li>implicitly typed any: arguments are implicitly converted to references (use with care)</li>
<li>untyped C-style</li>
</ol><p>Examples:</p><pre><code class="lang-c3">fn void va_singletyped(int... args)
{
    /* args has type int[] */
}

fn void va_variants_explicit(any*... args)
{
    /* args has type any*[] */
}

fn void va_variants_implicit(args...)
{
    /* args has type any*[] */
}

extern fn void va_untyped(...); <span class="comment">// only used for extern C functions</span>

fn void test()
{
    va_singletyped(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);

    int x = <span class="number">1</span>;
    any* v = &amp;x;
    va_variants_explicit(&amp;&amp;<span class="number">1</span>, &amp;x, v); <span class="comment">// pass references for non-any arguments</span>

    va_variants_implicit(<span class="number">1</span>, x, <span class="string">"foo"</span>); <span class="comment">// arguments are implicitly converted to anys</span>

    va_untyped(<span class="number">1</span>, x, <span class="string">"foo"</span>); <span class="comment">// extern C-function</span>
}</code></pre><p>For typed varargs, we can pass a slice instead of the individual arguments, by using the splat <code>...</code> operator for example:</p><pre><code class="lang-c3">fn void test_splat()
{
   int[] x = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };
   va_singletyped(...x);
}</code></pre><h3 id="building-on-mac-using-macports-regular-functions-splat">Splat</h3><ul>
<li>Splat <code>...</code> unknown size slice ONLY in a typed vaarg slot.</li>
</ul><pre><code class="lang-c3">fn void va_singletyped(int... args) { 
    io::printfn(<span class="string">"%s"</span>, args); 
}
fn void main() 
{
    int[<span class="number">2</span>] arr = {<span class="number">1</span>, <span class="number">2</span>};
    va_singletyped(...arr); <span class="comment">// arr is splatting two arguments</span>
}</code></pre><ul>
<li>Splat <code>...</code> any array anywhere</li>
</ul><pre><code class="lang-c3">fn void foo(int a, int b, int c) 
{ 
    io::printfn(<span class="string">"%s, %s, %s"</span>, a, b, c); 
}
fn void main() 
{
    int[<span class="number">2</span>] arr = {<span class="number">1</span>, <span class="number">2</span>};
    foo(...arr, <span class="number">7</span>); <span class="comment">// arr is splatting two arguments</span>
}</code></pre><ul>
<li>Splat <code>...</code> known size slices anywhere</li>
</ul><pre><code class="lang-c3">fn void foo(int a, int b, int c) 
{ 
    io::printfn(<span class="string">"%s, %s, %s"</span>, a, b, c); 
}
fn void main() 
{
    int[<span class="number">5</span>] arr = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
    foo(...arr[:<span class="number">3</span>]); <span class="comment">// slice is splatting three arguments</span>
}</code></pre><h3 id="building-on-mac-using-macports-regular-functions-named-arguments-and-varargs">Named arguments and varargs</h3><p>Usually, a parameter after varargs would never be assigned to:  </p><pre><code class="lang-c3">fn void testme(int a, double... x, double rate = <span class="number"><span class="number">1</span>.<span class="number">0</span></span>) { /* ... */ }

fn void test()
{
    <span class="comment">// x is { <span class="number"><span class="number">2</span>.<span class="number">0</span></span>, <span class="number"><span class="number">5</span>.<span class="number">0</span></span>, <span class="number"><span class="number">6</span>.<span class="number">0</span></span> } rate would be <span class="number"><span class="number">1</span>.<span class="number">0</span></span></span>
    testme(<span class="number">3</span>, <span class="number"><span class="number">2</span>.<span class="number">0</span></span>, <span class="number"><span class="number">5</span>.<span class="number">0</span></span>, <span class="number"><span class="number">6</span>.<span class="number">0</span></span>); 
}</code></pre><p>However, named arguments can be used to set this value:</p><pre><code class="lang-c3">fn void testme(int a, double... x, double rate = <span class="number"><span class="number">1</span>.<span class="number">0</span></span>) { /* ... */ }

fn void test()
{
    <span class="comment">// x is { <span class="number"><span class="number">2</span>.<span class="number">0</span></span>, <span class="number"><span class="number">5</span>.<span class="number">0</span></span> } rate would be <span class="number"><span class="number">6</span>.<span class="number">0</span></span></span>
    testme(<span class="number">3</span>, <span class="number"><span class="number">2</span>.<span class="number">0</span></span>, <span class="number"><span class="number">5</span>.<span class="number">0</span></span>, rate: <span class="number"><span class="number">6</span>.<span class="number">0</span></span>);
}</code></pre><h3 id="building-on-mac-using-macports-regular-functions-functions-and-optional-returns">Functions and Optional returns</h3><p>Function return values may be <em>Optionals</em> – denoted by <code>&lt;type&gt;!</code> indicating that this 
function might either return an Optional with a result, or an Optional with an Excuse.</p><p>For example this function might return an Excuse of type <code>SomeError</code> or <code>OtherResult</code>.</p><pre><code class="lang-c3">fn double! test_error()
{
    double val = random_value();
    if (val &gt;= <span class="number"><span class="number">0</span>.<span class="number">2</span></span>) return SomeError.BAD_JOSS_ERROR?;
    if (val &gt; <span class="number"><span class="number">0</span>.<span class="number">5</span></span>) return OtherError.BAD_LUCK_ERROR?;
    return val;
}</code></pre><p><em>A function call</em> which is passed one or more <em>Optional</em> arguments will only execute 
if all Optional values contain a <em>result</em>, otherwise the first Excuse found is returned.</p><pre><code class="lang-c3">fn void test()
{
    <span class="comment">// The following line is either prints a value less than <span class="number"><span class="number">0</span>.<span class="number">2</span></span></span>
    <span class="comment">// or does not print at all:</span>
    io::printfn(<span class="string">"%d"</span>, test_error());

    <span class="comment">// ?? sets a default value if an Excuse is found</span>
    double x = (test_error() + test_error()) ?? <span class="number">100</span>;  

    <span class="comment">// This prints either a value less than <span class="number"><span class="number">0</span>.<span class="number">4</span></span> or <span class="number">100</span>:</span>
    io::printfn(<span class="string">"%d"</span>, x);
}</code></pre><p>This allows us to chain functions:</p><pre><code class="lang-c3">fn void print_input_with_explicit_checks()
{
    String! line = io::readline();
    if (try line)
    {
        <span class="comment">// line is a regular <span class="string">"string"</span> here.</span>
        int! val = line.to_int();
        if (try val)
        {
            io::printfn(<span class="string">"You typed the number %d"</span>, val);
            return;
        }
    }
    io::printn(<span class="string">"You didn<span class="string">'t type an integer :/ "</span>);
}

fn void print_input_with_chaining()
{
    if (try int val = io::readline().to_int())
    {
        io::printfn(<span class="string">"You typed the number %d"</span>, val);
        return;
    }
    io::printn(<span class="string">"You didn'</span>t type an integer :/ "</span>);
}</code></pre><h2 id="building-on-mac-using-macports-methods">Methods</h2><p>Methods look exactly like functions, but are prefixed with the type name and is (usually) 
invoked using dot syntax:</p><pre><code class="lang-c3">struct Point
{
    int x;
    int y;
}

fn void Point.add(Point* p, int x) 
{
    p.x += x;
}

fn void example() 
{
    Point p = { <span class="number">1</span>, <span class="number">2</span> };

    <span class="comment">// with struct-functions</span>
    p.add(<span class="number">10</span>);

    <span class="comment">// Also callable as:</span>
    Point.add(&amp;p, <span class="number">10</span>);
}</code></pre><p>The target object may be passed by value or by pointer:</p><pre><code class="lang-c3">enum State
{
    STOPPED,
    RUNNING
}

fn bool State.may_open(State state) 
{
    switch (state)
    {
        case STOPPED: return true;
        case RUNNING: return false;
    }
}</code></pre><h3 id="building-on-mac-using-macports-methods-implicit-first-parameters">Implicit first parameters</h3><p>Because the type of the first argument is known, it may be left out. To indicate a pointer <code>&amp;</code> is used.</p><pre><code class="lang-c3">fn int Foo.test(&amp;self) { /* ... */ }
<span class="comment">// equivalent to</span>
fn int Foo.test(Foo* self) { /* ... */ }
fn int Bar.test(self) { /* ... */ }
<span class="comment">// equivalent to</span>
fn int Bar.test(Bar self) { /* ... */ }</code></pre><p>It is customary to use <code>self</code> as the name of the first parameter, but it is not required.</p><h3 id="building-on-mac-using-macports-methods-restrictions-on-methods">Restrictions on methods</h3><ul>
<li>Methods on a struct/union may not have the same name as a member.</li>
<li>Methods only works on distinct, struct, union and enum types.</li>
<li>When taking a function pointer of a method, use the full name.</li>
<li>Using subtypes, overlapping function names will be shadowed.</li>
</ul><h2 id="building-on-mac-using-macports-contracts">Contracts</h2><p>C3’s
 error handling is not intended to use errors to signal invalid data or 
to check invariants and post conditions. Instead C3’s approach is to add
 annotations to the function, that conditionally will be compiled into 
asserts.</p><p>As an example, the following code:</p><pre><code class="lang-c3">&lt;*
 @param foo `the number of foos`
 @require foo &gt; <span class="number">0</span>, foo &lt; <span class="number">1000</span>
 @return `number of foos x <span class="number">10</span>`
 @ensure return &lt; <span class="number">10000</span>, return &gt; <span class="number">0</span>
*&gt;
fn int test_foo(int foo)
{
    return foo * <span class="number">10</span>;
}</code></pre><p>Will in debug builds be compiled into something like this:</p><pre><code class="lang-c3">fn int test_foo(int foo)
{
    assert(foo &gt; <span class="number">0</span>);
    assert(foo &lt; <span class="number">1000</span>);
    int _return = foo * <span class="number">10</span>;
    assert(_return &lt; <span class="number">10000</span>);
    assert(_return &gt; <span class="number">0</span>);
    return _return;
}</code></pre><p>The compiler is allowed to use the contracts for optimizations. For example this:</p><pre><code class="lang-c3">fn int test_example(int bar)
{
    <span class="comment">// The following is always invalid due to the `@ensure`</span>
    if (test_foo(bar) == <span class="number">0</span>) return -<span class="number">1</span>;
    return <span class="number">1</span>;
}</code></pre><p>May be optimized to:</p><pre><code class="lang-c3">fn int test_example(int bar)
{
    return <span class="number">1</span>;
}</code></pre><p>In this case the compiler can look at the post condition of <code>result &gt; 0</code> to determine that <code>testFoo(foo) == 0</code> must always be false.</p><p>Looking closely at this code, we note that nothing guarantees that <code>bar</code>
 is not violating the preconditions. In Safe builds this will usually be
 checked in runtime, but a sufficiently smart compiler will warn about 
the lack of checks on <code>bar</code>. Execution of code violating pre and post conditions has unspecified behaviour.</p><h2 id="building-on-mac-using-macports-short-function-declaration-syntax">Short function declaration syntax</h2><p>For very short functions, C3 offers a “short declaration” syntax using <code>=&gt;</code>:</p><pre><code class="lang-c3"><span class="comment">// Regular</span>
fn int square(int x)
{
    return x * x;
}
<span class="comment">// Short</span>
fn int square_short(int x) =&gt; x * x;</code></pre><h2 id="building-on-mac-using-macports-lambdas">Lambdas</h2><p>It’s possible to create anonymous functions using the regular <code>fn</code> syntax. Anonymous 
functions are identical to regular functions and do not capture variables from the 
surrounding scope:</p><pre><code class="lang-c3">def IntTransform = fn int(int);
fn void apply(int[] arr, IntTransform t)
{
    foreach (&amp;i : arr) *i = t(*i);
}
fn void main()
{
    int[] x = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span> };
    <span class="comment">// Short syntax with inference:</span>
    apply(x, fn (i) =&gt; i * i);
    <span class="comment">// Regular syntax without inference: </span>
    <span class="comment">// apply(x, fn int(int i) { return i * i; });</span>
    <span class="comment">// Prints [<span class="number">1</span>, <span class="number">4</span>, <span class="number">25</span>]</span>
    io::printfn(<span class="string">"%s"</span>, x);        
}</code></pre><h2 id="building-on-mac-using-macports-static-initializer-and-finalizers">Static initializer and finalizers</h2><p>It is sometimes useful to run code at startup and shutdown. Static initializers and finalizers
are regular functions annotated with <code>@init</code> and <code>@finalizer</code> that are run at startup and shutdown respectively:</p><pre><code class="lang-c3">fn void run_at_startup() @init
{
    <span class="comment">// Run at startup</span>
    some_function.init(<span class="number">512</span>);
} 

fn void run_at_shutdown() @finalizer
{
    some_thing.shutdown();
}</code></pre><p>Note that invoking <code>@finalizer</code> is a best effort attempt by the OS and may not
be called during abnormal shutdown.</p><h3 id="building-on-mac-using-macports-static-initializer-and-finalizers-changing-priority-of-static-initializers-and-finalizers">Changing priority of static initializers and finalizers</h3><p>It is possible to provide an argument to the attributes to set the actual priority. It is recommended
that programs use a priority of 1024 or higher. The higher the value, the later it
will be called. The lowest priority is 65535.</p><pre><code class="lang-c3"><span class="comment">// Print <span class="string">"Hello World"</span> at startup.</span>

fn void start_world() @init(<span class="number">3000</span>)
{
    io::printn(<span class="string">"World"</span>);
}
fn void start_hello() @init(<span class="number">2000</span>)
{
    io::print(<span class="string">"Hello "</span>);
}</code></pre><hr><p>title: Modules
description: Modules
sidebar:</p><pre><code>order: 46</code></pre><hr><p>C3 groups functions,
 types, variables and macros into namespaces called modules. When doing 
builds, any C3 file must start with the <code>module</code> keyword, 
specifying the module. When compiling single files, the module is not 
needed and the module name is assumed to be the file name, converted to 
lower case, with any invalid characters replaced by underscore (<code>_</code>).</p><p>A module can consist of multiple files, e.g.</p><p><code>file_a.c3</code></p><pre><code class="lang-c3">module foo;

/* ... */</code></pre><p><code>file_b.c3</code></p><pre><code class="lang-c3">module foo;

/* ... */</code></pre><p><code>file_c.c3</code></p><pre><code class="lang-c3">module bar;

/* ... */</code></pre><p>Here <code>file_a.c3</code> and <code>file_b.c3</code> belong to the same module, <strong>foo</strong> while <code>file_c.c3</code> belongs to to <strong>bar</strong>.</p><h2 id="building-on-mac-using-macports-details">Details</h2><p>Some details about the C3 module system:</p><ul>
<li>Modules can be arbitrarily nested, e.g. <code>module foo::bar::baz;</code> to create the sub module baz in the sub module <code>bar</code> of the module <code>foo</code>.</li>
<li>Module names must be alphanumeric lower case letters plus the underscore character: <code>_</code>.</li>
<li>Module names are limited to 31 characters.</li>
<li>Modules may be spread across multiple files.</li>
<li>A single file may have multiple module declarations.</li>
<li>Each declaration of a distinct module is called a <em>module section</em>.</li>
</ul><h2 id="building-on-mac-using-macports-importing-modules">Importing Modules</h2><p>Modules are imported using the <code>import</code> statement. Imports always <em>recursively import</em> sub-modules. Any module
will automatically import all other modules with the same parent module.</p><p><code>foo.c3</code></p><pre><code class="lang-c3">module some::foo;
fn void test() {}</code></pre><p><code>bar.c3</code></p><pre><code class="lang-c3">module bar;
import some;
<span class="comment">// import some::foo; &lt;- not needed, as it is a sub module to <span class="string">"some"</span></span>
fn void test()
{
    foo::test();
    <span class="comment">// some::foo::test() also works.</span>
}</code></pre><p>In some cases there may be ambiguities, in which case the full path can be used to resolve the ambiguity:</p><p><code>abc.c3</code></p><pre><code class="lang-c3">module abc;
struct Context
{
    int a;
}</code></pre><p><code>def.c3</code></p><pre><code class="lang-c3">module def;
struct Context
{
    void* ptr;
}</code></pre><p><code>test.c3</code></p><pre><code class="lang-c3">module test<span class="number">1</span>;
import def, abc;
<span class="comment">// Context c = {} &lt;- ambiguous</span>
abc::Context c = {};</code></pre><h2 id="building-on-mac-using-macports-implicit-imports">Implicit Imports</h2><p>The module system will also implicitly import:</p><ol>
<li>The <code>std::core</code> module (and sub modules).</li>
<li>Any other module sharing the same top module. E.g. the module <code>foo::abc</code> will implicitly also import modules <code>foo</code> and <code>foo::cde</code> if they exist.</li>
</ol><h2 id="building-on-mac-using-macports-visibility">Visibility</h2><p>All files in the same module share the same global declaration namespace. By default a symbol is visible to all other modules.
To make a symbol only visible inside the module, use the <code>@private</code> attribute.</p><pre><code class="lang-c3">module foo;

fn void init() { .. }

fn void open() @private { .. }</code></pre><p>In this example, the other
 modules can use the init() function after importing foo, but only files
 in the foo module can use open(), as it is specified as <code>private</code>.</p><p>It’s possible to further restrict visibility: <code>@local</code> works like <code>@private</code> except it’s only visible in the
local context.</p><pre><code class="lang-c3"><span class="comment">// File foo.c<span class="number">3</span></span>
module foo;
fn void abc() @private { ... }
fn void def() @local { ... }

<span class="comment">// File foo<span class="number">2</span>.c<span class="number">3</span></span>
module foo;
fn void test()
{
    abc(); <span class="comment">// Access of private in the same module is ok</span>
    <span class="comment">// def(); &lt;- Error: function is local to foo.c<span class="number">3</span></span>
}</code></pre><h2 id="building-on-mac-using-macports-overriding-symbol-visibility-rules">Overriding Symbol Visibility Rules</h2><p>By using <code>import &lt;module&gt; @public</code>, it’s possible to access another module´s private symbols.
Many other module systems have hierarchal visibility rules, but the <code>import @public</code> feature allows
visibility to be manipulated in a more ad-hoc manner without imposing hard rules.</p><p>For example, you may provide a library with two modules: “mylib::net” and “mylib::file” - which both use functions
and types from a common “mylib::internals” module. The two libraries use <code>import mylib::internals @public</code>
to access this module’s private functions and type. To an external user of the library, the “mylib::internals”
does not seem to exist, but inside of your library you use it as a shared dependency.</p><p>A simple example:</p><pre><code class="lang-c3"><span class="comment">// File a.c<span class="number">3</span></span>
module a;

fn void a_function() @private { ... }

<span class="comment">// File b.c<span class="number">3</span></span>
module b;

fn void b_function() @private { ... }

<span class="comment">// File c.c<span class="number">3</span></span>
module c;
import a;
import b @public;

fn void test()
{
    <span class="comment">// Error! a_function() is private</span>
    a::a_function(); 

    <span class="comment">// Allowed since `import b @public` allowed `b`</span>
    <span class="comment">// to <span class="string">"public"</span> in this context.</span>
    b::b_function(); 
}</code></pre><p><em>Note: <code>@local</code> visibility cannot be overridden using a “@public” import.</em></p><h2 id="building-on-mac-using-macports-changing-the-default-visibility">Changing The Default Visibility</h2><p>In a normal module, global declarations will be public by default. If some other
visibility is desired, it’s possible to declare <code>@private</code> or <code>@local</code> after the module name.
It will affect all declaration in the same section.</p><pre><code class="lang-c3">module foo @private;

fn void ab_private() { ... } <span class="comment">// Private</span>

module foo;

fn void ab_public() { ... } <span class="comment">// Public</span>

module bar;
import foo;

fn void test()
{
    foo::ab_public(); <span class="comment">// Works</span>
    <span class="comment">// foo::ab_private(); &lt;- Error, private method</span>
}</code></pre><p>If the default visibility is <code>@private</code> or <code>@local</code>, using <code>@public</code> sets the visibility to public:</p><pre><code class="lang-c3">module foo @private;

fn void ab_private() { ... }        <span class="comment">// Private</span>
fn void ab_public() @public { ... } <span class="comment">// Public</span></code></pre><h2 id="building-on-mac-using-macports-linker-visibility-and-exports">Linker Visibility and Exports</h2><p>A function or global prefixed <code>extern</code> will be assumed to be linked in later.
An “extern” function may not have a body, and global variables are prohibited
from having an init expression.</p><p>The attribute <code>@export</code> explicitly marks a function as being exported when
creating a (static or dynamic) library. It can also change the linker name of
the function.</p><h2 id="building-on-mac-using-macports-using-functions-and-types-from-other-modules">Using Functions and Types From Other Modules</h2><p>As
 a rule, functions, macros, constants, variables and types in the same 
module do not need any namespace prefix. For imported modules the 
following rules hold:</p><ol>
<li>Functions, macros, constants and variables require <em>at least</em> the (sub-) module name.</li>
<li>Types do not require the module name unless the name is ambiguous.</li>
<li>In case of ambiguity, only so many levels of module names are needed as to make the symbol unambiguous.</li>
</ol><pre><code class="lang-c3"><span class="comment">// File a.c<span class="number">3</span></span>

module a;

struct Foo { ... }
struct Bar { ... }
struct TheAStruct { ... }

fn void anAFunction() { ... }

<span class="comment">// File b.c<span class="number">3</span></span>

module b;

struct Foo { ... }
struct Bar { ... }
struct TheBStruct { ... }

fn void aBFunction() { ... }

<span class="comment">// File c.c<span class="number">3</span></span>
module c;
import a, b;

struct TheCStruct { ... }
struct Bar { ... }

fn void aCFunction() { ... }

fn void test()
{
    TheAStruct stA;
    TheBStruct stB;
    TheCStruct stC;
    <span class="comment">// Name required to avoid ambiguity;</span>
    b::Foo stBFoo;
    <span class="comment">// Will always pick the current module's</span>
    <span class="comment">// name.</span>
    Bar bar;
    <span class="comment">// Namespace required:</span>
    a::aAFunction();
    b::aBFunction();
    <span class="comment">// A local symbol does not require it:</span>
    aCFunction();
}</code></pre><p>This means that the rule for the common case can be summarized as</p><blockquote>
<p>Types are used without prefix; functions, variables, macros and constants are prefixed with the sub module name.</p>
</blockquote><h2 id="building-on-mac-using-macports-module-sections">Module Sections</h2><p>A single file may have multiple module declarations, even for the same module. This allows us to write
for example:</p><pre><code class="lang-c3"><span class="comment">// File foo.c<span class="number">3</span></span>
module foo;
fn int hello_world()
{
    return my_hello_world();
}

module foo @private;
import std::io;         <span class="comment">// The import is only visible in this section.</span>
fn int my_hello_world() <span class="comment">// @private by default</span>
{
    io::printn(<span class="string">"Hello, world\n"</span>);
    return <span class="number">0</span>;
}

module foo @test;
fn void test_hello() <span class="comment">// @test by default</span>
{
    assert(hello_world() == <span class="number">0</span>);
}</code></pre><h2 id="building-on-mac-using-macports-versioning-and-dynamic-inclusion">Versioning and Dynamic Inclusion</h2><p><em>NOTE: This feature may significantly change.</em></p><p>When including <em>dynamic</em> libraries, it is possible to use optional functions and globals. This is done using the
<code>@dynamic</code> attribute.</p><p>An example library could have this:</p><p><code>dynlib.c3i</code></p><pre><code class="lang-c3">module dynlib;
fn void do_something() @dynamic(<span class="number"><span class="number">4</span>.<span class="number">0</span></span>)
fn void do_something_else() @dynamic(<span class="number">0</span>, <span class="number"><span class="number">5</span>.<span class="number">0</span></span>)
fn void do_another_thing() @dynamic(<span class="number">0</span>, <span class="number"><span class="number">2</span>.<span class="number">5</span></span>)</code></pre><p>Importing the dynamic library and setting the base version to 4.5 and minimum version to 3.0, we get the following:</p><p><code>test.c3</code></p><pre><code class="lang-c3">import dynlib;
fn void test()
{
    if (@available(dynlib::do_something))
    {
        dynlib::do_something();
    }
    else
    {
        dynlib::do_someting_else();
    }
}</code></pre><p>In this example the code would run <code>do_something</code> if available 
(that is, when the dynamic library is 4.0 or higher), or
fallback to <code>do_something_else</code> otherwise.</p><p>If we tried to conditionally add something not available in the 
compilation itself, that is a compile time error:</p><pre><code class="lang-c3">if (@available(dynlib::do_another_thing))
{
    <span class="comment">// Error: This function is not available with <span class="number"><span class="number">3</span>.<span class="number">0</span></span></span>
    dynlib::do_another_thing(); 
}</code></pre><p>Versionless dynamic loading is also possible:</p><p><code>maybe_dynlib.c3i</code></p><pre><code class="lang-c3">module maybe_dynlib;
fn void testme() @dynamic;</code></pre><p><code>test2.c3</code></p><pre><code class="lang-c3">import maybe_dynlib;
fn void testme<span class="number">2</span>()
{
    if (@available(maybe_dynlib::testme))
    {
        dynlib::testme();
    }
}</code></pre><p>This allows things like optionally loading dynamic libraries on the 
platforms where this is available.</p><h2 id="building-on-mac-using-macports-textual-includes">Textual Includes</h2><h3 id="building-on-mac-using-macports-textual-includes-include">$include</h3><p>It’s sometimes useful to include an entire file, doing so employs the <code>$include</code> function.
Includes are only valid at the top level.</p><p>File <code>Foo.c3</code></p><pre><code class="lang-c3">module foo;

$include(<span class="string">"Foo.x"</span>);

fn void test()
{
    io::printf(<span class="string">"%d"</span>, testX(<span class="number">2</span>));
}</code></pre><p>File <code>Foo.x</code></p><pre><code class="lang-c3">fn testX(int i)
{
    return i + <span class="number">1</span>;
}</code></pre><p>The result is as if <code>Foo.c3</code> contained the following:</p><pre><code class="lang-c3">module foo;

fn testX(int i)
{
    return i + <span class="number">1</span>;
}

fn void test()
{
    io::printf(<span class="string">"%d"</span>, testX(<span class="number">2</span>));
}</code></pre><p>The include may use an absolute or relative path, the 
relative path is always relative to the source file in which the include
 appears.</p><p>Note that to use it, the <strong>trust level</strong> of the compiler must be set to at least 2 with
the —trust option (i.e. use <code>--trust=include</code> or <code>--trust=full</code> from the command line).</p><h3 id="building-on-mac-using-macports-textual-includes-exec">$exec</h3><p>An alternative to <code>$include</code> is <code>$exec</code> which is similar to include, but instead includes the output of an external
program as the included text.</p><p>An example:</p><pre><code class="lang-c3">import std::io;

<span class="comment">// On Linux or MacOS this will insert <span class="string">'String a = <span class="string">"Hello world!"</span>;'</span></span>
$exec(<span class="string">"echo"</span>, { <span class="string">"String a = \\\"</span>Hello world!\\\<span class="string">"\\;"</span> });

fn void main()
{
    io::printn(a);
}</code></pre><p>Using <code>$exec</code> requires <strong>full trust level</strong>, which is enabled with <code>-trust=full</code> from the command line.</p><p>‘$exec’ will by default run from the <code>/scripts</code> directory for projects, for non-project builds,
the current directory is used as well.</p><h4><code>$exec</code> Scripting</h4><p><code>$exec</code> allows a special scripting mode, where one or more C3 files are compiled on the fly and
run by <code>$exec</code>.</p><pre><code class="lang-c">import std::io;

<span class="comment">// Compile foo.c<span class="number">3</span> and bar.c<span class="number">3</span> in the /scripts directory, invoke the resulting binary</span>
<span class="comment">// with the argument <span class="string">'test'</span></span>
$exec(<span class="string">"foo.c<span class="number">3</span>;bar.c<span class="number">3</span>"</span>, <span class="string">"test"</span>);

fn void main()
{
    ...
}</code></pre><h2 id="building-on-mac-using-macports-non-recursive-imports">Non-Recursive Imports</h2><p>In specific circumstances you only wish to import a module <em>without</em> its submodules.
This can be helpful in certain situations where otherwise unnecessary name-collisions
would occur, but should not be used in the general case.</p><p>The syntax for non-recursive imports is <code>import &lt;module_name&gt; @norecurse;</code> for example:</p><pre><code class="lang-c3"><span class="comment">// Non-recursive import</span>
import mylib @norecurse; 

<span class="comment">// Normal import</span>
import mylib;</code></pre><p>For example only importing “mylib” into “my_code” and not wishing to import “submod”.</p><pre><code class="lang-text">my_code
└── mylib
    └── submod</code></pre><pre><code class="lang-c3">module mylib;
import std::io;
fn void only_want_this()
{
    io::printn(<span class="string">"only_want_this"</span>);
}

module mylib::submod;
import std::io;
fn void undesired_fn()
{
    io::printn(<span class="string">"undesired_fn"</span>);
}

module my_code;
<span class="comment">// Using Non-recursive import undesired_fn not found</span>
import mylib @norecurse; 

<span class="comment">// Using Recursive import undesired_fn is found</span>
<span class="comment">// import mylib;</span>

fn void main()
{
    mylib::only_want_this();
    submod::undesired_fn(); <span class="comment">// This should error</span>
}</code></pre><p>:::note 
You can import multiple modules in one line:</p><pre><code class="lang-c3">import lib<span class="number">1</span>, lib<span class="number">2</span>;</code></pre><p><code>@norecurse</code> can be applied to one of those imports individually:</p><pre><code class="lang-c3">import lib<span class="number">1</span> @norecurse, lib<span class="number">2</span>;</code></pre><p>Here only <code>lib1</code> is imported non-recursively and <code>lib2</code> is imported normally, recursively.
:::</p><hr><p>title: Examples
description: Examples of C3 code
sidebar:</p><pre><code>order: 35</code></pre><hr><h2 id="building-on-mac-using-macports-overview">Overview</h2><p>This is meant for a quick reference, to the learn more of the details, check the relevant sections.</p><h2 id="building-on-mac-using-macports-if-statement">If Statement</h2><pre><code class="lang-c3">fn void if_example(int a) 
{
    if (a &gt; <span class="number">0</span>) 
    {
        <span class="comment">// ..</span>
    } 
    else 
    {
        <span class="comment">// ..</span>
    }
}</code></pre><h2 id="building-on-mac-using-macports-for-loop">For Loop</h2><pre><code class="lang-c3">fn void example_for() 
{
    <span class="comment">// the for-loop is the same as C<span class="number">99</span>. </span>
    for (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) 
    {
        io::printfn(<span class="string">"%d"</span>, i);
    }

    <span class="comment">// also equal</span>
    for (;;) 
    {
        <span class="comment">// ..</span>
    }
}</code></pre><h2 id="building-on-mac-using-macports-foreach-loop">Foreach Loop</h2><pre><code class="lang-c3"><span class="comment">// Prints the values in the slice.</span>
fn void example_foreach(float[] values) 
{
    foreach (index, value : values) 
    {
        io::printfn(<span class="string">"%d: %f"</span>, index, value);
    }
}

<span class="comment">// Updates each value in the slice</span>
<span class="comment">// by multiplying it by <span class="number">2</span>.</span>
fn void example_foreach_by_ref(float[] values) 
{
    foreach (&amp;value : values) 
    {
        *value *= <span class="number">2</span>;
    }
}</code></pre><h2 id="building-on-mac-using-macports-while-loop">While Loop</h2><pre><code class="lang-c3">fn void example_while() 
{
    <span class="comment">// again exactly the same as C</span>
    int a = <span class="number">10</span>;
    while (a &gt; <span class="number">0</span>) 
    {
        a--;
    }

    <span class="comment">// Declaration </span>
    while (Point* p = getPoint()) 
    {
        <span class="comment">// ..</span>
    }
}</code></pre><h2 id="building-on-mac-using-macports-enum-and-switch">Enum And Switch</h2><p>Switches have implicit break and scope. Use “nextcase” to implicitly fallthrough or use comma:</p><pre><code class="lang-c3">enum Height : uint
{
    LOW,
    MEDIUM,
    HIGH,
}

fn void demo_enum(Height h)
{
    switch (h)
    {
        case LOW:
        case MEDIUM:
            io::printn(<span class="string">"Not high"</span>);
            <span class="comment">// Implicit break.</span>
        case HIGH:
            io::printn(<span class="string">"High"</span>);
    }

    <span class="comment">// This also works</span>
    switch (h)
    {
        case LOW:
        case MEDIUM:
            io::printn(<span class="string">"Not high"</span>);
            <span class="comment">// Implicit break.</span>
        case Height.HIGH:
            io::printn(<span class="string">"High"</span>);
    }

    <span class="comment">// Completely empty cases are not allowed.</span>
    switch (h)
    {
        case LOW:
            break; <span class="comment">// Explicit break required, since switches can't be empty.</span>
        case MEDIUM:
            io::printn(<span class="string">"Medium"</span>);
        case HIGH:
            break;
    }

    <span class="comment">// special checking of switching on enum types</span>
    switch (h)
    {
        case LOW:
        case MEDIUM:
        case HIGH:
            break;
        default:    <span class="comment">// warning: default label in switch which covers all enumeration value</span>
            break;
    }

    <span class="comment">// Using <span class="string">"nextcase"</span> will fallthrough to the next case statement,</span>
    <span class="comment">// and each case statement starts its own scope.</span>
    switch (h)
    {
        case LOW:
            int a = <span class="number">1</span>;
            io::printn(<span class="string">"A"</span>);
            nextcase;
        case MEDIUM:
            int a = <span class="number">2</span>;
            io::printn(<span class="string">"B"</span>);
            nextcase;
        case HIGH:
            <span class="comment">// a is not defined here</span>
            io::printn(<span class="string">"C"</span>);
    }
}</code></pre><p>Enums are always namespaced.</p><p>Enum support various reflection properties: <code>.values</code> returns an array with all enums. <code>.len</code> or <code>.elements</code> returns the number
of enum values, <code>.inner</code> returns the storage type. <code>.names</code> returns an array with the names of all enums. <code>.associated</code>
returns an array of the typeids of the associated values for the enum.</p><pre><code class="lang-c3">enum State : uint 
{
    START,
    STOP,
}

State start = State.values[<span class="number">0</span>];
usz enums = State.elements;   <span class="comment">// <span class="number">2</span></span>
String[] names = State.names; <span class="comment">// [ <span class="string">"START"</span>, <span class="string">"STOP"</span> ]</span></code></pre><h2 id="building-on-mac-using-macports-defer">Defer</h2><p>Defer will be invoked on scope exit.</p><pre><code class="lang-c3">fn void test(int x)
{
    defer io::printn();
    defer io::print(<span class="string">"A"</span>);
    if (x == <span class="number">1</span>) return;
    {
        defer io::print(<span class="string">"B"</span>);
        if (x == <span class="number">0</span>) return;
    }
    io::print(<span class="string">"!"</span>);
}

fn void main()
{
    test(<span class="number">1</span>); <span class="comment">// Prints <span class="string">"A"</span></span>
    test(<span class="number">0</span>); <span class="comment">// Prints <span class="string">"BA"</span></span>
    test(<span class="number">10</span>); <span class="comment">// Prints <span class="string">"B!A"</span></span>
}</code></pre><p>Because it’s often relevant to run different defers 
when having an error return there is also a way to create an error 
defer, by using the <code>catch</code> keyword directly after the defer.
Similarly using <code>defer try</code> can be used to only run if the scope exits in a regular way.</p><pre><code class="lang-c3">fn void! test(int x)
{
    defer io::printn(<span class="string">""</span>);
    defer io::print(<span class="string">"A"</span>);
    defer try io::print(<span class="string">"X"</span>);
    defer catch io::print(<span class="string">"B"</span>);
    defer (catch err) io::printf(<span class="string">"%s"</span>, err);
    if (x == <span class="number">1</span>) return SearchResult.MISSING?;
    io::print(<span class="string">"!"</span>);
}

test(<span class="number">0</span>); <span class="comment">// Prints <span class="string">"!XA"</span></span>
test(<span class="number">1</span>); <span class="comment">// Prints <span class="string">"MISSINGBA"</span> and returns a FooError</span></code></pre><h2 id="building-on-mac-using-macports-struct-types">Struct Types</h2><pre><code class="lang-c3">def Callback = fn int(char c);

enum Status : int
{
    IDLE,
    BUSY,
    DONE,
}

struct MyData
{
    char* name;
    Callback open;
    Callback close;
    State status;

    <span class="comment">// named sub-structs (x.other.value)</span>
    struct other 
    {
        int value;
        int status;   <span class="comment">// ok, no name clash with other status</span>
    }

    <span class="comment">// anonymous sub-structs (x.value)</span>
    struct 
    {
        int value;
        int status;   <span class="comment">// error, name clash with other status in MyData</span>
    }

    <span class="comment">// anonymous union (x.person)</span>
    union 
    {
        Person* person;
        Company* company;
    }

    <span class="comment">// named sub-unions (x.either.this)</span>
    union either 
    {
        int this;
        bool  or;
        char* that;
    }
}</code></pre><h2 id="building-on-mac-using-macports-function-pointers">Function Pointers</h2><pre><code class="lang-c3">module demo;

def Callback = fn int(char* text, int value);

fn int my_callback(char* text, int value) 
{
    return <span class="number">0</span>;
}

Callback cb = &amp;my_callback;

fn void example_cb() 
{
    int result = cb(<span class="string">"demo"</span>, <span class="number">123</span>);
    <span class="comment">// ..</span>
}</code></pre><h2 id="building-on-mac-using-macports-error-handling">Error Handling</h2><p>Errors are handled using optional results, denoted with a ‘!’ suffix. A variable of an optional
result type may either contain the regular value or a <code>fault</code> enum value.</p><pre><code class="lang-c3">fault MathError
{
    DIVISION_BY_ZERO
}

fn double! divide(int a, int b)
{
    <span class="comment">// We return an optional result of type DIVISION_BY_ZERO</span>
    <span class="comment">// when b is zero.</span>
    if (b == <span class="number">0</span>) return MathError.DIVISION_BY_ZERO?;
    return (double)a / (double)b;
}

<span class="comment">// Re-returning an optional result uses <span class="string">"!"</span> suffix</span>
fn void! testMayError()
{
    divide(foo(), bar())!;
}

fn void main()
{
    <span class="comment">// ratio is an optional result.</span>
    double! ratio = divide(foo(), bar());

    <span class="comment">// Handle the optional result value if it exists.</span>
    if (catch err = ratio)
    {
        case MathError.DIVISION_BY_ZERO:
            io::printn(<span class="string">"Division by zero\n"</span>);
            return;
        default:
            io::printn(<span class="string">"Unexpected error!"</span>);
            return;
    }
    <span class="comment">// Flow typing makes <span class="string">"ratio"</span></span>
    <span class="comment">// have the plain type <span class="string">'double'</span> here.</span>
    io::printfn(<span class="string">"Ratio was %f"</span>, ratio);
}</code></pre><pre><code class="lang-c3">fn void print_file(String filename)
{
    String! file = io::load_file(filename);

    <span class="comment">// The following function is not called on error,</span>
    <span class="comment">// so we must explicitly discard it with a void cast.</span>
    (void)io::printfn(<span class="string">"Loaded %s and got:\n%s"</span>, filename, file);

    if (catch err = file)
    {
        case IoError.FILE_NOT_FOUND:
            io::printfn(<span class="string">"I could not find the file %s"</span>, filename);
        default:
            io::printfn(<span class="string">"Could not load %s."</span>, filename);
    }
}

<span class="comment">// Note that the above is only illustrating how Optionals may skip </span>
<span class="comment">// call invocation. A more normal implementation would be:</span>

fn void print_file<span class="number">2</span>(String filename)
{
    String! file = io::load_file(filename);

    if (catch err = file)
    {
        <span class="comment">// Print the error </span>
        io::printfn(<span class="string">"Failed to load %s: %s"</span>, filename, err);
        <span class="comment">// We return, so that below <span class="string">'file'</span> will be unwrapped.</span>
        return;
    }    
    <span class="comment">// No need for a void cast here, <span class="string">'file'</span> is unwrappeed to <span class="string">'String'</span>.</span>
    io::printfn(<span class="string">"Loaded %s and got:\n%s"</span>, filename, file);
}</code></pre><p>Read more about optionals and error handling <a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">here</a>.</p><h2 id="building-on-mac-using-macports-contracts">Contracts</h2><p>Pre- and postconditions are optionally compiled into asserts helping to optimize the code.</p><pre><code class="lang-c3">&lt;*
 @param foo <span class="string">"the number of foos"</span> 
 @require foo &gt; <span class="number">0</span>, foo &lt; <span class="number">1000</span>
 @return <span class="string">"number of foos x <span class="number">10</span>"</span>
 @ensure return &lt; <span class="number">10000</span>, return &gt; <span class="number">0</span>
*&gt;
fn int testFoo(int foo)
{
    return foo * <span class="number">10</span>;
}

&lt;*
 @param array <span class="string">"the array to test"</span>
 @param length <span class="string">"length of the array"</span>
 @require length &gt; <span class="number">0</span>
*&gt;
fn int getLastElement(int* array, int length)
{
    return array[length - <span class="number">1</span>];
}</code></pre><p>Read more about contracts <a href="https://waveproc.github.io/language-common/contracts/">here</a>.</p><h2 id="building-on-mac-using-macports-struct-methods">Struct Methods</h2><p>It’s possible to namespace functions with a union, struct or enum type to enable “dot syntax” calls:</p><pre><code class="lang-c3">struct Foo
{
    int i;
}

fn void Foo.next(Foo* this)
{
    if (this) this.i++;
}

fn void test()
{
    Foo foo = { <span class="number">2</span> };
    foo.next();
    foo.next();
    <span class="comment">// Prints <span class="number">4</span></span>
    io::printfn(<span class="string">"%d"</span>, foo.i); 
}</code></pre><h2 id="building-on-mac-using-macports-macros">Macros</h2><p>Macro arguments may be immediately evaluated.</p><pre><code class="lang-c3">macro foo(a, b)
{
    return a(b);
}

fn int square(int x)
{
    return x * x;
}

fn int test()
{
    int a = <span class="number">2</span>;
    int b = <span class="number">3</span>;    
    return foo(&amp;square, <span class="number">2</span>) + a + b; <span class="comment">// <span class="number">9</span></span>
    <span class="comment">// return foo(square, <span class="number">2</span>) + a + b; </span>
    <span class="comment">// Error the symbol <span class="string">"square"</span> cannot be used as an argument.</span>
}</code></pre><p>Macro arguments may have deferred evaluation, which is basically text expansion using <code>#var</code> syntax.</p><pre><code class="lang-c3">macro @foo(<span class="comment">#a, b, #c)</span>
{
    c = a(b) * b;
}

macro @foo<span class="number">2</span>(<span class="comment">#a)</span>
{
    return a * a;
}

fn int square(int x)
{
    return x * x;
}

fn int test<span class="number">1</span>()
{
    int a = <span class="number">2</span>;
    int b = <span class="number">3</span>; 
    @foo(square, a + <span class="number">1</span>, b);
    return b; <span class="comment">// <span class="number">27</span>   </span>
}

fn int test<span class="number">2</span>()
{
    return @foo<span class="number">2</span>(<span class="number">1</span> + <span class="number">1</span>); <span class="comment">// <span class="number">1</span> + <span class="number">1</span> * <span class="number">1</span> + <span class="number">1</span> = <span class="number">3</span></span>
}</code></pre><p>Improve macro errors with preconditions:</p><pre><code class="lang-c3">&lt;*
 @param x <span class="string">"value to square"</span>
 @require types::is_numeric($typeof(x)) <span class="string">"cannot multiply"</span>
*&gt;
macro square(x)
{
    return x * x;
}

fn void test()
{
    square(<span class="string">"hello"</span>); <span class="comment">// Error: cannot multiply <span class="string">"hello"</span></span>
    int a = <span class="number">1</span>;
    square(&amp;a); <span class="comment">// Error: cannot multiply <span class="string">'&amp;a'</span></span>
}</code></pre><p>Read more about macros <a href="https://waveproc.github.io/generic-programming/macros/">here</a>.</p><h3 id="building-on-mac-using-macports-macros-compile-time-reflection-execution">Compile Time Reflection &amp; Execution</h3><p>Access type information and loop over values at compile time:</p><pre><code class="lang-c3">import std::io;

struct Foo
{
    int a;
    double b;
    int* ptr;
}

macro print_fields($Type)
{
    $foreach ($field : $Type.membersof)
        io::printfn(<span class="string">"Field %s, offset: %s, size: %s, type: %s"</span>, 
                $field.nameof, $field.offsetof, $field.sizeof, $field.typeid.nameof);
    $endforeach
}


fn void main()
{
    print_fields(Foo);
}</code></pre><p>This prints on x64:</p><pre><code class="lang-text">Field a, offset: <span class="number">0</span>, size: <span class="number">4</span>, type: int
Field b, offset: <span class="number">8</span>, size: <span class="number">8</span>, type: double
Field ptr, offset: <span class="number">16</span>, size: <span class="number">8</span>, type: int*</code></pre><h3 id="building-on-mac-using-macports-macros-compile-time-execution">Compile Time Execution</h3><p>Macros with only compile time variables are completely evaluated at compile time:</p><pre><code class="lang-c3">macro long fib(long $n)
{
    $if $n &lt;= <span class="number">1</span>:
        return $n;
    $else
        return fib($n - <span class="number">1</span>) + fib($n - <span class="number">2</span>);
    $endif
}

const long FIB<span class="number">19</span> = fib(<span class="number">19</span>); 
<span class="comment">// Same as const long FIB<span class="number">19</span> = <span class="number">4181</span>;</span></code></pre><p>:::note

C3 macros are designed to provide a replacement for C preprocessor 
macros. They extend such macros by providing compile time evaluation 
using constant folding, which offers an IDE friendly, limited, compile 
time execution.</p><p>However, if you are doing more complex compile time code generation it is recommended to use <code>$exec</code> and related techniques to generate code in external scripts instead.
:::
Read more about compile time execution <a href="https://waveproc.github.io/generic-programming/compiletime/">here</a>.</p><h2 id="building-on-mac-using-macports-generic-modules">Generic Modules</h2><p>Generic modules implements a generic system.</p><pre><code class="lang-c3">module stack(&lt;Type&gt;);
struct Stack
{
    usz capacity;
    usz size;
    Type* elems;
}


fn void Stack.push(Stack* this, Type element)
{
    if (this.capacity == this.size)
    {
        this.capacity *= <span class="number">2</span>;
        this.elems = realloc(this.elems, Type.sizeof * this.capacity);
    }
    this.elems[this.size++] = element;
}

fn Type Stack.pop(Stack* this)
{
    assert(this.size &gt; <span class="number">0</span>);
    return this.elems[--this.size];
}

fn bool Stack.empty(Stack* this)
{
    return !this.size;
}</code></pre><p>Testing it out:</p><pre><code class="lang-c3">def IntStack = Stack(&lt;int&gt;);

fn void test()
{
    IntStack stack;
    stack.push(<span class="number">1</span>);
    stack.push(<span class="number">2</span>);
    <span class="comment">// Prints pop: <span class="number">2</span></span>
    io::printfn(<span class="string">"pop: %d"</span>, stack.pop());
    <span class="comment">// Prints pop: <span class="number">1</span></span>
    io::printfn(<span class="string">"pop: %d"</span>, stack.pop());

    Stack(&lt;double&gt;) dstack;
    dstack.push(<span class="number"><span class="number">2</span>.<span class="number">3</span></span>);
    dstack.push(<span class="number"><span class="number">3</span>.<span class="number">141</span></span>);
    dstack.push(<span class="number"><span class="number">1</span>.<span class="number">1235</span></span>);
    <span class="comment">// Prints pop: <span class="number"><span class="number">1</span>.<span class="number">1235</span></span></span>
    io::printfn(<span class="string">"pop: %f"</span>, dstack.pop());
}</code></pre><p>Read more about generic modules <a href="https://waveproc.github.io/generic-programming/generics/">here</a></p><h2 id="building-on-mac-using-macports-dynamic-calls">Dynamic Calls</h2><p>Runtime dynamic dispatch through interfaces:</p><pre><code class="lang-c3">import std::io;

<span class="comment">// Define a dynamic interface</span>
interface MyName
{
    fn String myname();
}

struct Bob (MyName) { int x; }

<span class="comment">// Required implementation as Bob implements MyName</span>
fn String Bob.myname(Bob*) @dynamic { return <span class="string">"I am Bob!"</span>; }

<span class="comment">// Ad hoc implementation</span>
fn String int.myname(int*) @dynamic { return <span class="string">"I am int!"</span>; }

fn void whoareyou(any a)
{
    MyName b = (MyName)a;
    if (!&amp;b.myname)
    {
        io::printn(<span class="string">"I don't know who I am."</span>);
        return;
    }
    io::printn(b.myname());
}

fn void main()
{
    int i = <span class="number">1</span>;
    double d = <span class="number"><span class="number">1</span>.<span class="number">0</span></span>;
    Bob bob;

    any a = &amp;i;
    whoareyou(a);
    a = &amp;d;
    whoareyou(a);
    a = &amp;bob;
    whoareyou(a);
}</code></pre><p>Read more about dynamic calls <a href="https://waveproc.github.io/generic-programming/anyinterfaces/">here</a>.</p><hr><p>title: Changes From C
description: Changes From C
sidebar:</p><pre><code>order: 702</code></pre><hr><p>Although C3 is trying to improve on C, this does not only mean addition of features, but also removal, or breaking changes:</p><h5>No mandatory header files</h5><p>There is a C3 interchange header format for declaring interfaces of libraries, but it is only used for special applications.</p><h5>Removal of the old C macro system</h5><p>The old C macro system is replaced by a new C3 macro system.</p><h5>Import and modules</h5><p>C3 uses module imports instead of header includes to link modules together.</p><h5>Member access using <code>.</code> even for pointers</h5><p>The <code>-&gt;</code>
 operator is removed, access uses dot for both direct and pointer 
access. Note that this is just single access: to access a pointer of a 
pointer (e.g. <code>int**</code>) an explicit dereference would be needed.</p><h5>Different operator precedence</h5><p>Notably bit operations have higher precedence than +/-, making code like this: <code>a &amp; b == c</code> evaluate like <code>(a &amp; b) == c</code> instead of C’s <code>a &amp; (b == c)</code>. See the page about <a href="https://waveproc.github.io/language-rules/precedence/">precedence rules</a>.</p><h5>Removal of the const type qualifier</h5><p>The const qualifier is only retained for actual constant variables. C3 uses a special type of <a href="https://waveproc.github.io/language-common/contracts/">post condition</a> for functions to indicate that they do not alter in parameters.</p><pre><code class="lang-c3">&lt;*
 This function ensures that foo is not changed in the function.
 @param [in] foo
 @param [out] bar
*&gt;
fn void test(Foo* foo, Bar* bar)
{
    bar.y = foo.x;
    <span class="comment">// foo.x = foo.x + <span class="number">1</span> - compile time error, can<span class="string">'t write to '</span>in<span class="string">' param.</span>
    <span class="comment">// int x = bar.y     - compile time error, can'</span>t read from an <span class="string">'out'</span> param.</span>
}</code></pre><p><em>Rationale: const correctness requires littering 
const across the code base. Although const is useful, it provides weaker
 guarantees that it appears.</em></p><h5>Fixed arrays do not decay and have copy semantics</h5><p>C3
 has three different array types. Variable arrays and slices decay to 
pointers, but fixed arrays are value objects and do not decay.</p><pre><code class="lang-c3">int[<span class="number">3</span>] a = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };
int[<span class="number">4</span>]* b = &amp;a; <span class="comment">// No conversion</span>
int* c = a; <span class="comment">// ERROR</span>
int* d = &amp;a; <span class="comment">// Valid implicit conversion</span>
int* e = b; <span class="comment">// Valid implicit conversion</span>
int[<span class="number">3</span>] f = a; <span class="comment">// Copy by value!</span></code></pre><h5>Removal of multiple declaration syntax with initialization</h5><p>Only a single declaration with initialization is allowed per statement in C3:</p><pre><code class="lang-c3">int i, j = <span class="number">1</span>; <span class="comment">// ERROR</span>
int a = <span class="number">1</span>;    <span class="comment">// Ok</span>
int b, c;     <span class="comment">// Ok</span></code></pre><p>In conditionals, a special form of multiple declarations are allowed but each must then provide its type:</p><pre><code class="lang-c3">for (int i = <span class="number">0</span>, int j = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++, j++) { ... }</code></pre><h5>Integer promotions rules and safe signed-unsigned comparisons</h5><p>Promotion rules for integer types are different from C. 
C3 allows implicit widening only
where there is only a single way to widen the expression. To explain the latter:
take the case of <code>long x = int_val_1 + int_val_2</code>. In C this would widen the result of the addition:
<code>long x = (long)(int_val_1 + int_val_2)</code>, but there is another possible 
way to widen: <code>long x = (long)int_val_1 + (long)int_val_2</code>. so in this case, the widening
is disallowed. However, <code>long x = int_val_1</code> is unambiguous, so C3 permits it just like C (read more on the <a href="https://waveproc.github.io/language-rules/conversion/">conversion page</a>. </p><p>C3 also adds <em>safe signed-unsigned comparisons</em>: this means that comparing signed and unsigned values will always yield the correct result:</p><pre><code class="lang-c3"><span class="comment">// The code below would print <span class="string">"Hello C<span class="number">3</span>!"</span> in C<span class="number">3</span> and <span class="string">"Hello C!"</span> in C.</span>
int i = -<span class="number">1</span>;
uint j = <span class="number">1</span>;
if (i &lt; j)
{
    printf(<span class="string">"Hello C<span class="number">3</span>!\n"</span>);
}
else
{
    printf(<span class="string">"Hello C!\n"</span>);
}</code></pre><h5>Goto removed</h5><p><code>goto</code> is removed and replaced with labelled <code>break</code> and <code>continue</code> together with the <code>nextcase</code> statement that allows you to jump between cases in a <code>switch</code> statement.</p><p><em>Rationale:
 It is very difficult to make goto work well with defer and implicit 
unwrapping of optional results. It is not just making the compiler 
harder to write, but
the code is harder to understand as well. The replacements together with
 <code>defer</code> cover many if not all usages of <code>goto</code> in regular code.</em></p><h5>Implicit break in switches</h5><p>Empty <code>case</code> statements have implicit fall through in C3, otherwise the <code>nextcase</code> statement is needed
<code>nextcase</code> can also be used to jump to any other case statement in the switch.</p><pre><code class="lang-c3">switch (h)
{
    case <span class="number">1</span>:
        a = <span class="number">1</span>;
        nextcase; <span class="comment">// Fall through</span>
    case <span class="number">2</span>:
        b = <span class="number">123</span>;
    case <span class="number">3</span>:
        a = <span class="number">2</span>;
        nextcase <span class="number">2</span>; <span class="comment">// Jump to case <span class="number">2</span></span>
    default:
        a = <span class="number">111</span>;
}</code></pre><h5>Locals variables are implicitly zeroed</h5><p>In C global variables are implicitly zeroed out, but local variables aren’t. 
In C3 local variables are zeroed out by default, but may be <em>explicitly</em> undefined 
(using the <code>@noinit</code> attribute) if you wish to match the C behaviour.</p><h6>Rationale for this change</h6><ul>
<li>In the “zero-is-initialization” paradigm, zeroing variables, in particular structs, 
is very common. By offering zero initialization by default this <strong>avoids a whole class of vulnerabilities</strong>.</li>
<li>Another alternative that was considered for C3 was mandatory initialization,
but this adds a lot of extra boilerplate. </li>
<li>C3 also offers a way to opt out of zero-initialization, so the change comes at no performance loss.</li>
</ul><h5>Compound literal syntax changed</h5><pre><code class="lang-c"><span class="comment">// C style:</span>
call_foo((Foo) { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });

<span class="comment">// C++ style (<span class="number">1</span>):</span>
call_foo(Foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));

<span class="comment">// C++ style (<span class="number">2</span>):</span>
call_foo(Foo { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });

<span class="comment">// C<span class="number">3</span>:</span>
call_foo(Foo { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> } );

<span class="comment">// C<span class="number">3</span> with inference:</span>
call_foo({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });</code></pre><h5>Bitfields replaced by bitstructs</h5><p>Bitfields are replaced by bitstructs that have a well-defined encapsulating type, and 
an exact bit layout.</p><pre><code class="lang-c"><span class="comment">// C</span>
struct Foo
{
    int a : <span class="number">3</span>;
    unsigned b : <span class="number">4</span>;
    MyEnum c : <span class="number">7</span>;
};

struct Flags
{
    bool has_hyperdrive : <span class="number">1</span>;
    bool has_tractorbeam : <span class="number">1</span>;
    bool has_plasmatorpedoes : <span class="number">1</span>;
}    

<span class="comment">// C<span class="number">3</span></span>
bitstruct Foo : short
{  
    int a : <span class="number">0</span>..<span class="number">2</span>;
    uint b : <span class="number">3</span>..<span class="number">6</span>;
    MyEnum c : <span class="number">7</span>..<span class="number">13</span>;
}

<span class="comment">// Simple form, only allowed when all fields are bools.</span>
struct Flags : char
{
    bool has_hyperdrive;
    bool has_tractorbeam;
    bool has_plasmatorpedoes;
}</code></pre><h5>Evaluation order is well-defined</h5><p>Evaluation order is left-to-right, and in assignment expressions, assignment
happens after expression evaluation.</p><h5>Signed overflow is well-defined</h5><p>Signed integer overflow always wraps using 2s complement. It is never undefined behaviour.</p><h5>Octal removed</h5><p>The old <code>0777</code> octal syntax is removed and replaced by a <code>0o</code> prefix, e.g. <code>0o777</code>. Strings do not support octal sequences aside
from <code>'\0'</code>.</p><hr><p>title: Types
description: Types
sidebar:</p><pre><code>order: 38</code></pre><hr><h2 id="building-on-mac-using-macports-overview">Overview</h2><p>As usual, types are divided into basic types and user defined types (<code>enum</code>, <code>union</code>, <code>struct</code>, <code>fault</code>, <code>def</code>). All types are defined on a global level.</p><h5>Naming</h5><p>All user defined types in C3 starts with upper case. So <code>MyStruct</code> or <code>Mystruct</code> would be fine, <code>mystruct_t</code> or <code>mystruct</code> would not.
This naming requirement ensures that the language is easy to parse for tools.
It is possible to use attributes to change the external name of a type:</p><pre><code class="lang-c3">struct Stat @extern(<span class="string">"stat"</span>)
{
    <span class="comment">// ...</span>
} 

fn CInt stat(char* pathname, Stat* buf);</code></pre><p>This would affect things like generated C headers.</p><h5>Differences from C</h5><p>Unlike C, C3 does not use type qualifiers. <code>const</code> exists, 
but is a storage class modifier, not a type qualifier. 
Instead of <code>volatile</code>, volatile loads and stores are used. 
Restrictions on function parameter usage are instead described by parameter <a href="https://waveproc.github.io/language-common/contracts/#pre-conditions">preconditions</a>.</p><p><code>typedef</code> has a slightly different syntax and renamed <code>def</code>.</p><p>C3 also requires all function pointers to be used with a <code>def</code> for example:</p><pre><code class="lang-c3">def Callback = fn void();
Callback a = null; <span class="comment">// Ok!</span>
fn Callback getCallback() { /* ... */ } <span class="comment">// Ok!</span>

<span class="comment">// fn fn void() getCallback() { /* ... */ } - ERROR!</span>
<span class="comment">// fn void() a = null; - ERROR!</span></code></pre><h2 id="building-on-mac-using-macports-basic-types">Basic types</h2><p>Basic types are divided into floating point types, and integer types. Integer types being either signed or unsigned.</p><h5>Integer types</h5><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="right">bit size</th>
<th align="center">signed</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>bool</code>*</td>
<td align="right">1</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left"><code>ichar</code></td>
<td align="right">8</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left"><code>char</code></td>
<td align="right">8</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="right">16</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left"><code>ushort</code></td>
<td align="right">16</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="right">32</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left"><code>uint</code></td>
<td align="right">32</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="right">64</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left"><code>ulong</code></td>
<td align="right">64</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left"><code>int128</code></td>
<td align="right">128</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left"><code>uint128</code></td>
<td align="right">128</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left"><code>iptr</code>**</td>
<td align="right">varies</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left"><code>uptr</code>**</td>
<td align="right">varies</td>
<td align="center">no</td>
</tr>
<tr>
<td align="left"><code>isz</code>**</td>
<td align="right">varies</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="left"><code>usz</code>**</td>
<td align="right">varies</td>
<td align="center">no</td>
</tr>
</tbody>
</table><p>* <code>bool</code> will be stored as a byte.<br>** size, pointer and pointer sized types depend on platform.</p><h5>Integer arithmetics</h5><p>All signed integer arithmetics uses 2’s complement.</p><h5>Integer constants</h5><p>Integer constants are 1293832 or -918212. Without a suffix, suffix type is assumed to the signed integer of <em>arithmetic promotion width</em>. Adding the <code>u</code> suffix gives a unsigned integer of the same width. Use <code>ixx</code> and <code>uxx</code> – where <code>xx</code> is the bit width for typed integers, e.g. <code>1234u16</code></p><p>Integers may be written in decimal, but also</p><ul>
<li>in binary with the prefix 0b e.g. <code>0b0101000111011</code>, <code>0b011</code></li>
<li>in octal with the prefix 0o e.g. <code>0o0770</code>, <code>0o12345670</code></li>
<li>in hexadecimal with the prefix 0x e.g. <code>0xdeadbeef</code> <code>0x7f7f7f</code></li>
</ul><p>In the case of binary, octal and hexadecimal, the type is assumed to be <em>unsigned</em>.</p><p>Furthermore, underscore <code>_</code> may be used to add space between digits to improve readability e.g. <code>0xFFFF_1234_4511_0000</code>, <code>123_000_101_100</code></p><h5>TwoCC, FourCC and EightCC</h5><p><a href="https://en.wikipedia.org/wiki/FourCC">FourCC</a>
 codes are often used to identify binary format types. C3 adds direct 
support for 4 character codes, but also 2 and 8 characters:</p><ul>
<li>2 character strings, e.g. <code>'C3'</code>, would convert to an ushort or short.</li>
<li>4 character strings, e.g. <code>'TEST'</code>, converts to an uint or int. </li>
<li>8 character strings, e.g. <code>'FOOBAR11'</code> converts to an ulong or long.</li>
</ul><p>Conversion is always done so that the character string has the 
correct ordering in memory. This means that the same characters may have
 different integer values on different architectures due to endianness.</p><h5>Base64 and hex data literals</h5><p>Base64 encoded values work like TwoCC/FourCC/EightCC, in that is it laid out in byte order in memory. It uses the format <code>b64'&lt;base64&gt;'</code>. Hex encoded values work as base64 but with the format <code>x'&lt;hex&gt;'</code>. In data literals any whitespace is ignored, so <code>'00 00 11'x</code> encodes to the same value as <code>x'000011'</code>.</p><p>In our case we could encode <code>b64'Rk9PQkFSMTE='</code> as <code>'FOOBAR11'</code>.</p><p>Base64 and hex data literals initializes to arrays of the char type:</p><pre><code class="lang-c3">char[*] hello_world_base<span class="number">64</span> = b<span class="number">64</span><span class="string">"SGVsbG<span class="number">8</span>gV<span class="number">29</span>ybGQh"</span>;
char[*] hello_world_hex = x<span class="string">"<span class="number">4865</span> <span class="number">6</span>c<span class="number">6</span>c <span class="number">6</span>f<span class="number">20</span> <span class="number">776</span>f <span class="number">726</span>c <span class="number">6421</span>"</span>;</code></pre><h5>String literals, and raw strings</h5><p>Regular string literals is text enclosed in <code>" ... "</code> just like in C. C3 also offers two other types of literals: <em>multi-line strings</em> and <em>raw strings</em>.</p><p>Raw strings uses text between ` `. Inside of a raw string, no escapes are available. To write a ` double the character:</p><pre><code class="lang-c3">char* foo = `C:\foo\bar.dll`;
char* bar = `<span class="string">"Say ``hello``"</span>`;
<span class="comment">// Same as</span>
char* foo = <span class="string">"C:\\foo\\bar.dll"</span>;
char* bar = <span class="string">"\"</span>Say `hello`\<span class="string">""</span>;</code></pre><h5>Floating point types</h5><table>
<thead>
<tr>
<th>Name</th>
<th align="right">bit size</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bfloat16</code>*</td>
<td align="right">16</td>
</tr>
<tr>
<td><code>float16</code>*</td>
<td align="right">16</td>
</tr>
<tr>
<td><code>float</code></td>
<td align="right">32</td>
</tr>
<tr>
<td><code>double</code></td>
<td align="right">64</td>
</tr>
<tr>
<td><code>float128</code>*</td>
<td align="right">128</td>
</tr>
</tbody>
</table><p>*support is still incomplete.</p><h5>Floating point constants</h5><p>Floating point constants will <em>at least</em>
 use 64 bit precision. Just like for integer constants, it is allowed to
 use underscore, but it may not occur immediately before or after a dot 
or an exponential.</p><p>Floating point values may be written in decimal
 or hexadecimal. For decimal, the exponential symbol is e (or E, both 
are acceptable), for hexadecimal p (or P) is used: <code>-2.22e-21</code> <code>-0x21.93p-10</code> </p><p>It is possible to type a floating point by adding a suffix:</p><table>
<thead>
<tr>
<th>Suffix</th>
<th align="right">type</th>
</tr>
</thead>
<tbody>
<tr>
<td>bf16</td>
<td align="right">bfloat16</td>
</tr>
<tr>
<td>f16</td>
<td align="right">float16</td>
</tr>
<tr>
<td>f32 <em>or</em> f</td>
<td align="right">float</td>
</tr>
<tr>
<td>f64</td>
<td align="right">double</td>
</tr>
<tr>
<td>f128</td>
<td align="right">float128</td>
</tr>
</tbody>
</table><h3 id="building-on-mac-using-macports-basic-types-c-compatibility">C compatibility</h3><p>For C compatibility the following types are also defined in std::core::cinterop</p><table>
<thead>
<tr>
<th>Name</th>
<th align="right">c type</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>CChar</code></td>
<td align="right">char</td>
</tr>
<tr>
<td><code>CShort</code></td>
<td align="right">short int</td>
</tr>
<tr>
<td><code>CUShort</code></td>
<td align="right">unsigned short int</td>
</tr>
<tr>
<td><code>CInt</code></td>
<td align="right">int</td>
</tr>
<tr>
<td><code>CUInt</code></td>
<td align="right">unsigned int</td>
</tr>
<tr>
<td><code>CLong</code></td>
<td align="right">long int</td>
</tr>
<tr>
<td><code>CULong</code></td>
<td align="right">unsigned long int</td>
</tr>
<tr>
<td><code>CLongLong</code></td>
<td align="right">long long</td>
</tr>
<tr>
<td><code>CULongLong</code></td>
<td align="right">unsigned long long</td>
</tr>
<tr>
<td><code>CLongDouble</code></td>
<td align="right">long double</td>
</tr>
</tbody>
</table><p><code>float</code> and <code>double</code> will always match their C counterparts.</p><p>Note that signed C char and unsigned char will correspond to <code>ichar</code> and <code>char</code>. <code>CChar</code> is only available to match the default signedness of <code>char</code> on the platform.</p><h2 id="building-on-mac-using-macports-other-built-in-types">Other built-in types</h2><h3 id="building-on-mac-using-macports-other-built-in-types-pointer-types">Pointer types</h3><p>Pointers mirror C: <code>Foo*</code> is a pointer to a <code>Foo</code>, while <code>Foo**</code> is a pointer to a pointer of Foo.</p><h3 id="building-on-mac-using-macports-other-built-in-types-the-typeid-type">The <code>typeid</code> type</h3><p>The <code>typeid</code> can hold a runtime identifier for a type. Using <code>&lt;typename&gt;.typeid</code> a type may be converted to its unique runtime id, 
e.g. <code>typeid a = Foo.typeid;</code>. This value is pointer-sized.</p><h3 id="building-on-mac-using-macports-other-built-in-types-the-any-type">The <code>any</code> type</h3><p>C3 contains a built-in variant type, which is essentially struct containing a <code>typeid</code> plus a <code>void*</code> pointer to a value.
While it is possible to cast the <code>any</code> pointer to any pointer type,
it is recommended to use the <code>anycast</code> macro or checking the type explicitly first.</p><pre><code class="lang-c3">fn void main()
{
    int x;
    any y = &amp;x;
    int* w = (int*)y;                <span class="comment">// Returns the pointer to x</span>
    double* z_bad = (double*)y;      <span class="comment">// Don't do this!</span>
    double! z = anycast(y, double);  <span class="comment">// The safe way to get a value</span>
    if (y.type == int.typeid)
    {
        <span class="comment">// Do something if y contains an int*</span>
    }
}</code></pre><p>Switching over the <code>any</code> type is another method to unwrap the pointer inside:</p><pre><code class="lang-c3">fn void test(any z)
{
    <span class="comment">// Unwrapping switch</span>
    switch (z)
    {
        case int: 
            <span class="comment">// z is unwrapped to int* here</span>
        case double:
            <span class="comment">// z is unwrapped to double* here</span>
    }
    <span class="comment">// Assignment switch</span>
    switch (y = z)
    {
        case int:
            <span class="comment">// y is int* here</span>
    }
    <span class="comment">// Direct unwrapping to a value is also possible:</span>
    switch (w = *z)
    {
        case int:
            <span class="comment">// w is int here</span>
    }
    <span class="comment">// Finally, if we just want to deal with the case</span>
    <span class="comment">// where it is a single specific type:</span>
    if (z.type == int.typeid)
    {
        <span class="comment">// This is safe here:</span>
        int* a = (int*)z;
    }
    if (try b = *anycast(z, int))
    {
        <span class="comment">// b is an int:</span>
        foo(b * <span class="number">3</span>);
    }
}</code></pre><p><code>any.type</code> returns the underlying pointee typeid of the contained value. <code>any.ptr</code> returns 
the raw <code>void*</code> pointer.</p><h3 id="building-on-mac-using-macports-other-built-in-types-array-types">Array types</h3><p>Arrays are indicated by <code>[size]</code> after the type, e.g. <code>int[4]</code>. Slices use the <code>type[]</code>. For initialization the wildcard <code>type[*]</code> can be used to infer the size
from the initializer. See the chapter on <a href="https://waveproc.github.io/language-common/arrays/">arrays</a>.</p><h3 id="building-on-mac-using-macports-other-built-in-types-vector-types">Vector types</h3><p>Vectors use <code>[&lt;size&gt;]</code> after the type, e.g. <code>float[&lt;3&gt;]</code>, with the restriction that vectors may only form out
of integers, floats and booleans. Similar to arrays, wildcard can be used to infer the size of a vector: <code>int[&lt;*&gt;] a = { 1, 2 }</code>.</p><h2 id="building-on-mac-using-macports-types-created-using-def">Types created using <code>def</code></h2><h3 id="building-on-mac-using-macports-types-created-using-def-typedef">“typedef”</h3><p>Like in C, C3 has a “typedef” construct, <code>def &lt;typename&gt; = &lt;type&gt;</code></p><pre><code class="lang-c3">def Int<span class="number">32</span> = int;
def Vector<span class="number">2</span> = float[&lt;<span class="number">2</span>&gt;];

/* ... */

Int<span class="number">32</span> a = <span class="number">1</span>;
int b = a;</code></pre><h3 id="building-on-mac-using-macports-types-created-using-def-function-pointer-types">Function pointer types</h3><p>Function pointers are always used through a <code>def</code>:</p><pre><code class="lang-c3">def Callback = fn void(int value);
Callback callback = &amp;test;

fn void test(int a) { /* ... */ }</code></pre><p>To form a function pointer, write a normal function declaration but skipping the function name. <code>fn int foo(double x)</code> -&gt;
<code>fn int(double x)</code>.</p><p>Function pointers can have default arguments, e.g. <code>def Callback = fn void(int value = 0)</code> but default arguments
and parameter names are not taken into account when determining function pointer assignability:</p><pre><code class="lang-c3">def Callback = fn void(int value = <span class="number">1</span>);
fn void test(int a = <span class="number">0</span>) { /* ... */ }

Callback callback = &amp;main; <span class="comment">// Ok</span>

fn void main()
{
    callback(); <span class="comment">// Works, same as test(<span class="number">0</span>);</span>
    test(); <span class="comment">// Works, same as test(<span class="number">1</span>);</span>
    callback(.value = <span class="number">3</span>); <span class="comment">// Works, same as test(<span class="number">3</span>)</span>
    test(.a = <span class="number">4</span>); <span class="comment">// Works, same as test(<span class="number">4</span>)</span>
    <span class="comment">// callback(.a = <span class="number">3</span>); ERROR!</span>
}</code></pre><h3 id="building-on-mac-using-macports-types-created-using-def-distinct-types">Distinct types</h3><p>Distinct types is a kind of type alias which creates a new type that has the same properties as the original type
but is - as the name suggests - distinct from it. It cannot implicitly convert into the other type using the syntax 
<code>distict &lt;name&gt; = &lt;type&gt;</code></p><pre><code class="lang-c3">distinct MyId = int;
fn void* get_by_id(MyId id) { ... }

fn void test(MyId id)
{
    void* val = get_by_id(id); <span class="comment">// Ok</span>
    void* val<span class="number">2</span> = get_by_id(<span class="number">1</span>); <span class="comment">// Literals convert implicitly</span>
    int a = <span class="number">1</span>;
    <span class="comment">// void* val<span class="number">3</span> = get_by_id(a); // ERROR expected a MyId</span>
    void* val<span class="number">4</span> = get_by_id((MyId)a); <span class="comment">// Works</span>
    <span class="comment">// a = id; // ERROR can<span class="string">'t assign '</span>MyId<span class="string">' to '</span>int'</span>
}</code></pre><h4>Inline distinct</h4><p>Using <code>inline</code> in the <code>distinct</code> declaration allows a distinct type to implicitly convert to its underlying type:</p><pre><code class="lang-c3">distinct Abc = int;
distinct Bcd = inline int;

fn void test()
{
    Abc a = <span class="number">1</span>;
    Bcd b = <span class="number">1</span>;

    <span class="comment">// int i = a; Error: Abc cannot be implicitly converted to <span class="string">'int'</span></span>
    int i = b; <span class="comment">// This is valid</span>

    <span class="comment">// However, <span class="string">'inline'</span> does not allow implicit conversion from </span>
    <span class="comment">// the inline type to the distinct type:</span>
    <span class="comment">// a = i; Error: Can<span class="string">'t implicitly convert '</span>int<span class="string">' to '</span>Abc<span class="string">'</span>
    <span class="comment">// b = i; Error: Can'</span>t implicitly convert <span class="string">'int'</span> to <span class="string">'Bcd'</span></span>
}</code></pre><h3 id="building-on-mac-using-macports-types-created-using-def-generic-types">Generic types</h3><pre><code class="lang-c3">import generic_list; <span class="comment">// Contains the generic MyList</span>

struct Foo { 
    int x; 
}

<span class="comment">// ✅ def for each type used with a generic module.</span>
def IntMyList = MyList(&lt;Foo&gt;);
MyListFoo working_example;

<span class="comment">// ❌ An inline type definition will give an error.</span>
<span class="comment">// Only allowed in a type definition or macro </span>
<span class="comment">// To avoid this A type may be declared with @adhoc</span>
MyList&lt;Foo&gt; failing_example = MyList(&lt;Foo&gt;);</code></pre><p>Find out more about <a href="https://waveproc.github.io/generic-programming/generics">generic types</a>.</p><h2 id="building-on-mac-using-macports-enum">Enum</h2><p>Enum or enumerated types use the following syntax:</p><pre><code class="lang-c3">enum State : int 
{
    WAITING,
    RUNNING,
    TERMINATED
}

<span class="comment">// Access enum values via:</span>
State current_state = State.WAITING;</code></pre><p>The access requires referencing the <code>enum</code>‘s name as <code>State.WAITING</code> because 
an enum like <code>State</code> is a separate namespace by default, just like C++’s class <code>enum</code>.</p><h3 id="building-on-mac-using-macports-enum-enum-associated-values">Enum associated values</h3><p>It is possible to associate each enum value with one or more a static values.</p><pre><code class="lang-c3">enum State : int (String description) 
{
    WAITING = <span class="string">"waiting"</span>,
    RUNNING = <span class="string">"running"</span>,
    TERMINATED = <span class="string">"ended"</span>,
}

fn void main() 
{
    State process = State.RUNNING;
    io::printfn(<span class="string">"%s"</span>, process.description);
}</code></pre><p>Multiple static values can be associated with an enum value, for example:</p><pre><code class="lang-c3">struct Position
{
    int x;
    int y;
}

enum State : int (String desc, bool active, Position pos)
{
    WAITING    = { <span class="string">"waiting"</span>, false, { <span class="number">1</span>, <span class="number">2</span>} },
    RUNNING    = { <span class="string">"running"</span>, true,  {<span class="number">12</span>,<span class="number">22</span>} },
    TERMINATED = { <span class="string">"ended"</span>,   false, { <span class="number">0</span>, <span class="number">0</span>} },
}

fn void main()
{
    State process = State.RUNNING;
    if (process.active)
    {
        io::printfn(<span class="string">"Process is: %s"</span>, process.desc);
        io::printfn(<span class="string">"Position x: %d"</span>, process.pos.x);
    }
}</code></pre><h3 id="building-on-mac-using-macports-enum-enum-type-inference">Enum type inference</h3><p>When an <code>enum</code> is used where the type can be inferred, like in switch case-clauses or in variable assignment, the enum name is not required:</p><pre><code class="lang-c3">State process = WAITING; <span class="comment">// State.WAITING is inferred.</span>
switch (process)
{
    case RUNNING: <span class="comment">// State.RUNNING is inferred</span>
        io::printfn(<span class="string">"Position x: %d"</span>, process.pos.x);
    default:
        io::printfn(<span class="string">"Process is: %s"</span>, process.desc);
}

fn void test(State s) { ... }

test(RUNNING); <span class="comment">// State.RUNNING is inferred</span></code></pre><p>If the <code>enum</code> without it’s name matches with a global in the same scope, it needs the enum name to be added as a qualifier, for example:</p><pre><code class="lang-c3">module test;

<span class="comment">// Global variable</span>
<span class="comment">// ❌ Don't do this!</span>
const State RUNNING = State.TERMINATED; 

test(RUNNING);       <span class="comment">// Ambiguous</span>
test(test::RUNNING); <span class="comment">// Uses global variable.</span>
test(State.RUNNING); <span class="comment">// Uses enum constant.</span></code></pre><h2 id="building-on-mac-using-macports-optional-type">Optional Type</h2><p>An <a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">Optional type</a> is created by taking a type and appending <code>!</code>. 
An Optional type behaves like a tagged union, containing either the
result or an Excuse that is of a <a href="#optional-excuses-are-of-type-fault">fault</a> type.</p><p>Once extracted, any specific fault can be converted to an <code>anyfault</code>.</p><pre><code class="lang-c3">int! i;
i = <span class="number">5</span>; <span class="comment">// Assigning a real value to i.</span>
i = IOResult.IO_ERROR?; <span class="comment">// Assigning an optional result to i.</span>
anyfault b = SearchError.MISSING;
b = @catch(i); <span class="comment">// Assign the Excuse in i to b (IO_ERROR)</span></code></pre><p>Only variables, expressions and function returns may be Optionals. 
Function and macro parameters in their definitions may not be optionals.</p><pre><code class="lang-c3">fn Foo*! getFoo() { /* ... */ } <span class="comment">// ✅ Ok!</span>
int! x = <span class="number">0</span>; <span class="comment">// ✅ Ok!</span>
fn void processFoo(Foo*! f) { /* ... */ } <span class="comment">// ❌ fn paramater</span></code></pre><p>Read more about the Optional types on the page about <a href="https://waveproc.github.io/language-common/optionals-essential/">Optionals and error handling</a>.</p><h3 id="building-on-mac-using-macports-optional-type-optional-excuses-are-of-type-fault">Optional Excuses are of type Fault</h3><p>When an <a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">Optional</a> does not contain a result, it is empty, and has an Excuse, which is a<code>fault</code>.
The <code>anyfault</code> type may contain any such fault.</p><pre><code class="lang-c3">fault IOResult
{
    IO_ERROR,
    PARSE_ERROR
}   

fault MapResult
{
    NOT_FOUND
}</code></pre><p>Like the <a href="#the-typeid-type">typeid type</a>, the constants are pointer sized 
and each value is globally unique. For example the underlying value of 
<code>MapResult.NOT_FOUND</code> is guaranteed to be different from <code>IOResult.IO_ERROR</code>. 
This is true even if they are separately compiled.</p><p>:::note
The underlying values assigned to a fault may vary each time a program is compiled. 
:::</p><p>A fault may be stored as a normal value, but is also unique so that it may be passed
in an Optional as a function return value using the 
<a href="https://waveproc.github.io/language-common/optionals-essential/#using-the-rethrow-operator--to-unwrap-an-optional-value">rethrow <code>!</code> operator</a>.</p><h2 id="building-on-mac-using-macports-struct-types">Struct types</h2><p>Structs are always named:</p><pre><code class="lang-c3">struct Person  
{
    char age;
    String name;
}</code></pre><p>A struct’s members may be accessed using dot notation, even for pointers to structs.</p><pre><code class="lang-c3">fn void test()
{
    Person p;
    p.age = <span class="number">21</span>;
    p.name = <span class="string">"John Doe"</span>;

    io::printfn(<span class="string">"%s is %d years old."</span>, p.name, p.age);

    Person* p_ptr_ = &amp;p;
    p_ptr.age = <span class="number">20</span>; <span class="comment">// Ok!</span>

    io::printfn(<span class="string">"%s is %d years old."</span>, p_ptr.name, p_ptr.age);
}</code></pre><p>(One might wonder whether it’s possible to take a <code>Person**</code> and use dot access. – It’s not allowed, only one level of dereference is done.)</p><p>To change alignment and packing, <a href="https://waveproc.github.io/language-common/attributes/">attributes</a> such as <code>@packed</code> may be used.</p><h2 id="building-on-mac-using-macports-struct-subtyping">Struct subtyping</h2><p>C3 allows creating struct subtypes using <code>inline</code>:</p><pre><code class="lang-c3">struct ImportantPerson 
{
    inline Person person;
    String title;
}

fn void print_person(Person p)
{
    io::printfn(<span class="string">"%s is %d years old."</span>, p.name, p.age);
}


fn void test()
{
    ImportantPerson important_person;
    important_person.age = <span class="number">25</span>;
    important_person.name = <span class="string">"Jane Doe"</span>;
    important_person.title = <span class="string">"Rockstar"</span>;

    <span class="comment">// Only the first part of the struct is copied.</span>
    print_person(important_person); 
}</code></pre><h2 id="building-on-mac-using-macports-union-types">Union types</h2><p>Union types are defined just like structs and are fully compatible with C.</p><pre><code class="lang-c3">union Integral  
{
    char as_byte;
    short as_short;
    int as_int;
    long as_long;
}</code></pre><p>As usual unions are used to hold one of many possible values:</p><pre><code class="lang-c3">fn void test()
{
    Integral i;
    i.as_byte = <span class="number">40</span>; <span class="comment">// Setting the active member to as_byte</span>

    i.as_int = <span class="number">500</span>; <span class="comment">// Changing the active member to as_int</span>

    <span class="comment">// Undefined behaviour: as_byte is not the active member, </span>
    <span class="comment">// so this will probably print garbage.</span>
    io::printfn(<span class="string">"%d\n"</span>, i.as_byte);
}</code></pre><p>Note that unions only take up as much space as their largest member, so <code>Integral.sizeof</code> is equivalent to <code>long.sizeof</code>.</p><h2 id="building-on-mac-using-macports-nested-sub-structs-unions">Nested sub-structs / unions</h2><p>Just like in C99 and later, nested anonymous sub-structs / unions are allowed. Note that
the placement of struct / union names is different to match the difference in declaration.</p><pre><code class="lang-c3">struct Person  
{
    char age;
    String name;
    union 
    {
        int employee_nr;
        uint other_nr;
    }
    union subname 
    {
        bool b;
        Callback cb;
    }
}</code></pre><h2 id="building-on-mac-using-macports-bitstructs">Bitstructs</h2><p>Bitstructs allows storing fields in a specific bit layout. A bitstruct may only contain
integer types and booleans, in most other respects it works like a struct.</p><p>The main differences is that the bitstruct has a <em>backing type</em> and each field
has a specific bit range. In addition, it’s not possible <em>to take the address</em> of a
bitstruct field.</p><pre><code class="lang-c3">bitstruct Foo : char
{
    int a : <span class="number">0</span>..<span class="number">2</span>;
    int b : <span class="number">4</span>..<span class="number">6</span>;
    bool c : <span class="number">7</span>;
}

fn void test()
{   
    Foo f;
    f.a = <span class="number">2</span>;
    char x = (char)f;
    io::printfn(<span class="string">"%d"</span>, (char)f); <span class="comment">// prints <span class="number">2</span></span>
    f.b = <span class="number">1</span>;
    io::printfn(<span class="string">"%d"</span>, (char)f); <span class="comment">// prints <span class="number">18</span> </span>
    f.c = true;
    io::printfn(<span class="string">"%d"</span>, (char)f); <span class="comment">// prints <span class="number">146</span></span>
}</code></pre><p>The bitstruct will follow the endianness of the underlying type:</p><pre><code class="lang-c3">bitstruct Test : uint
{
    ushort a : <span class="number">0</span>..<span class="number">15</span>;
    ushort b : <span class="number">16</span>..<span class="number">31</span>;
}

fn void test()
{
    Test t;
    t.a = <span class="number">0</span>xABCD;
    t.b = <span class="number">0</span>x<span class="number">789</span>A;
    char* c = (char*)&amp;t;

    <span class="comment">// Prints <span class="number">789</span>AABCD</span>
    io::printfn(<span class="string">"%X"</span>, (uint)t); 

    for (int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) 
    {
        <span class="comment">// Prints CDAB<span class="number">9</span>A<span class="number">78</span></span>
        io::printf(<span class="string">"%X"</span>, c[i]); 
    }
    io::printn();
}</code></pre><p>It is however possible to pick a different endianness, in which case the entire representation
will internally assume big endian layout:</p><pre><code class="lang-c3">bitstruct Test : uint @bigendian
{
    ushort a : <span class="number">0</span>..<span class="number">15</span>;
    ushort b : <span class="number">16</span>..<span class="number">31</span>;
}</code></pre><p>In this case the same example yields <code>CDAB9A78</code> and <code>789AABCD</code> respectively.</p><p>Bitstruct backing types may be integers or char arrays. The difference in layout is somewhat subtle:</p><pre><code class="lang-c3">bitstruct Test<span class="number">1</span> : char[<span class="number">4</span>]
{
    ushort a : <span class="number">0</span>..<span class="number">15</span>;
    ushort b : <span class="number">16</span>..<span class="number">31</span>;
}
bitstruct Test<span class="number">2</span> : char[<span class="number">4</span>] @bigendian
{
    ushort a : <span class="number">0</span>..<span class="number">15</span>;
    ushort b : <span class="number">16</span>..<span class="number">31</span>;
}

fn void test()
{
    Test<span class="number">1</span> t<span class="number">1</span>;
    Test<span class="number">2</span> t<span class="number">2</span>;
    t<span class="number">1</span>.a = t<span class="number">2</span>.a = <span class="number">0</span>xABCD;
    t<span class="number">1</span>.b = t<span class="number">2</span>.b = <span class="number">0</span>x<span class="number">789</span>A;

    char* c = (char*)&amp;t<span class="number">1</span>;
    for (int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) 
    {
        <span class="comment">// Prints CDAB<span class="number">9</span>A<span class="number">78</span> on x<span class="number">86</span></span>
        io::printf(<span class="string">"%X"</span>, c[i]); 
    }
    io::printn();

    c = (char*)&amp;t<span class="number">2</span>;
    for (int i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) 
    {
        <span class="comment">// Prints ABCD<span class="number">789</span>A</span>
        io::printf(<span class="string">"%X"</span>, c[i]); 
    }
    io::printn();
}</code></pre><p>Bitstructs can be made to have overlapping bit fields. This is useful when modelling
a layout which has multiple different layouts depending on flag bits:</p><pre><code class="lang-c3">bitstruct Foo : char @overlap
{
    int a : <span class="number">2</span>..<span class="number">5</span>;
    <span class="comment">// <span class="string">"b"</span> is valid due to the @overlap attribute</span>
    int b : <span class="number">1</span>..<span class="number">3</span>; 
}</code></pre><hr><p>title: Arrays
description: Arrays
sidebar:</p><pre><code>order: 60</code></pre><hr><p>Arrays have a central role in programming. C3 offers built-in arrays, <a href="#slice">slices</a> and <a href="https://waveproc.github.io/language-common/vectors/">vectors</a>.
The standard library enhances this further with dynamically sized arrays and other collections.</p><h2 id="building-on-mac-using-macports-fixed-size-1d-arrays">Fixed Size 1D Arrays</h2><p>These are declared as <code>&lt;type&gt;[&lt;size&gt;]</code>, e.g. <code>int[4]</code>.
 Fixed arrays are treated as values and will be copied if given as 
parameter. Unlike C, the number is part of its type. Taking a pointer to
 a fixed array will create a pointer to a fixed array, e.g. <code>int[4]*</code>. </p><p>Unlike C, fixed arrays do not decay into pointers. Instead, an <code>int[4]*</code> may be implicitly converted into an <code>int*</code>.</p><pre><code class="lang-c3"><span class="comment">// C</span>
int foo(int *a) { ... }

int x[<span class="number">3</span>] = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };
foo(x);

<span class="comment">// C<span class="number">3</span></span>
fn int foo(int *a) { ... }

int[<span class="number">3</span>] x = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };
foo(&amp;x);</code></pre><p>When you want to initialize a fixed array without specifying the size, use the [*] array syntax:</p><pre><code class="lang-c3">int[<span class="number">3</span>] a = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };
int[*] b = { <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> }; <span class="comment">// Type inferred to be int[<span class="number">3</span>]</span></code></pre><h2 id="building-on-mac-using-macports-slice">Slice</h2><p>The final type is the slice <code>&lt;type&gt;[]</code>  e.g. <code>int[]</code>.
 A slice is a view into either a fixed or variable array. Internally it 
is represented as a struct containing a pointer and a size. Both fixed 
and variable arrays may be converted into slices, and slices may be 
implicitly converted to pointers.</p><pre><code class="lang-c3">fn void test() 
{
    int[<span class="number">4</span>] arr = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> };
    int[<span class="number">4</span>]* ptr = &amp;arr;

    <span class="comment">// Assignments to slices</span>
    int[] slice<span class="number">1</span> = &amp;arr;                <span class="comment">// Implicit conversion</span>
    int[] slice<span class="number">2</span> = ptr;                 <span class="comment">// Implicit conversion</span>

    <span class="comment">// Assignments from slices</span>
    int[] slice<span class="number">3</span> = slice<span class="number">1</span>;              <span class="comment">// Assign slices from other slices</span>
    int* int_ptr = slice<span class="number">1</span>;              <span class="comment">// Assign from slice</span>
    int[<span class="number">4</span>]* arr_ptr = (int[<span class="number">4</span>]*)slice<span class="number">1</span>;  <span class="comment">// Cast from slice</span>
}</code></pre><h3 id="building-on-mac-using-macports-slice-slicing-arrays">Slicing Arrays</h3><p>It’s possible to use the range syntax to create slices from pointers, arrays, and other slices.</p><p>This is written <code>arr[&lt;start-index&gt; .. &lt;end-index&gt;]</code>, where the <code>end-index</code> is <em>inclusive</em>. </p><pre><code class="lang-c3">fn void test() 
{
    int[<span class="number">5</span>] a = { <span class="number">1</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span> };

    int[] b = a[<span class="number">0</span> .. <span class="number">4</span>]; <span class="comment">// The whole array as a slice.</span>
    int[] c = a[<span class="number">2</span> .. <span class="number">3</span>]; <span class="comment">// { <span class="number">50</span>, <span class="number">100</span> }</span>
}</code></pre><p>You can also use the <code>arr[&lt;start-index&gt; : &lt;slice-length&gt;]</code></p><pre><code class="lang-c3">fn void test()
{
    int[<span class="number">5</span>] a = { <span class="number">1</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span> };

    int[] b<span class="number">2</span> = a[<span class="number">0</span> : <span class="number">5</span>]; <span class="comment">// { <span class="number">1</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span> } start-index <span class="number">0</span>, slice-length <span class="number">5</span></span>
    int[] c<span class="number">2</span> = a[<span class="number">2</span> : <span class="number">2</span>]; <span class="comment">// { <span class="number">50</span>, <span class="number">100</span> } start-index <span class="number">2</span>, slice-length <span class="number">2</span></span>
}</code></pre><p>It’s possible to omit the first and last indices of a range:
- <code>arr[..&lt;end-index&gt;]</code> Omitting the <code>start-index</code> will default it to 0
- <code>arr[&lt;start-index&gt;..]</code> Omitting the <code>end-index</code> will assign it to <code>arr.len-1</code> (this is not allowed on pointers)</p><p>Equivalently with index offset <code>arr[:&lt;slice-length&gt;]</code> you can omit the <code>start-index</code> </p><p>The following are all equivalent and slice the whole array</p><pre><code class="lang-c3">fn void test() 
{
    int[<span class="number">5</span>] a = { <span class="number">1</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span> };

    int[] b = a[<span class="number">0</span> .. <span class="number">4</span>];
    int[] c = a[..<span class="number">4</span>];
    int[] d = a[<span class="number">0</span>..];
    int[] e = a[..];

    int[] f = a[<span class="number">0</span> : <span class="number">5</span>];
    int[] g = a[:<span class="number">5</span>];
}</code></pre><p>You can also slice in reverse from the end with <code>^i</code> where the index is <code>len-i</code> for example:
- <code>^1</code> means <code>len-1</code>
- <code>^2</code> means <code>len-2</code>
- <code>^3</code> means <code>len-3</code></p><p>Again, this is not allowed for pointers since the length is unknown.</p><pre><code class="lang-c3">fn void test() 
{
    int[<span class="number">5</span>] a = { <span class="number">1</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span> };

    int[] b<span class="number">1</span> = a[<span class="number">1</span> .. ^<span class="number">1</span>];  <span class="comment">// { <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span> } a[<span class="number">1</span> .. (a.len-<span class="number">1</span>)]</span>
    int[] b<span class="number">2</span> = a[<span class="number">1</span> .. ^<span class="number">2</span>];  <span class="comment">// { <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span> }      a[<span class="number">1</span> .. (a.len-<span class="number">2</span>)]</span>
    int[] b<span class="number">3</span> = a[<span class="number">1</span> .. ^<span class="number">3</span>];  <span class="comment">// { <span class="number">20</span>, <span class="number">50</span> }           a[<span class="number">1</span> .. (a.len-<span class="number">3</span>)]</span>

    int[] c<span class="number">1</span> = a[^<span class="number">1</span>..];     <span class="comment">// { <span class="number">200</span> }              a[(a.len-<span class="number">1</span>)..]</span>
    int[] c<span class="number">2</span> = a[^<span class="number">2</span>..];     <span class="comment">// { <span class="number">100</span>, <span class="number">200</span> }         a[(a.len-<span class="number">2</span>)..]</span>
    int[] c<span class="number">3</span> = a[^<span class="number">3</span>..];     <span class="comment">// { <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span> }     a[(a.len-<span class="number">3</span>)..]</span>

    int[] d = a[^<span class="number">3</span> : <span class="number">2</span>];    <span class="comment">// { <span class="number">50</span>, <span class="number">100</span> }          a[(a.len-<span class="number">3</span>) : <span class="number">2</span>]</span>

    <span class="comment">// Slicing a whole array, the inclusive index of : gives the difference</span>
    int[] e = a[<span class="number">0</span> .. ^<span class="number">1</span>];   <span class="comment">// a[<span class="number">0</span> .. a.len-<span class="number">1</span>]</span>
    int[] f = a[<span class="number">0</span> : ^<span class="number">0</span>];    <span class="comment">// a[<span class="number">0</span> : a.len]</span>

}</code></pre><p>One may also assign to slices:</p><pre><code class="lang-c3">int[<span class="number">3</span>] a = { <span class="number">1</span>, <span class="number">20</span>, <span class="number">50</span> };
a[<span class="number">1</span>..<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// a = { <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> }</span></code></pre><p>Or copy slices to slices:</p><pre><code class="lang-c3">int[<span class="number">3</span>] a = { <span class="number">1</span>, <span class="number">20</span>, <span class="number">50</span> };
int[<span class="number">3</span>] b = { <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span> };
a[<span class="number">1</span>..<span class="number">2</span>] = b[<span class="number">0</span>..<span class="number">1</span>]; <span class="comment">// a = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span> }</span></code></pre><p>Copying between two overlapping ranges, e.g. <code>a[1..2] = a[0..1]</code> is unspecified behaviour.</p><h3 id="building-on-mac-using-macports-slice-conversion-list">Conversion List</h3><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">int[4]</th>
<th align="center">int[]</th>
<th align="center">int[4]*</th>
<th align="center">int*</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">int[4]</td>
<td align="center">copy</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">int[]</td>
<td align="center">-</td>
<td align="center">assign</td>
<td align="center">assign</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">int[4]*</td>
<td align="center">-</td>
<td align="center">cast</td>
<td align="center">assign</td>
<td align="center">cast</td>
</tr>
<tr>
<td align="center">int*</td>
<td align="center">-</td>
<td align="center">assign</td>
<td align="center">assign</td>
<td align="center">assign</td>
</tr>
</tbody>
</table><p>Note that all casts above are inherently unsafe and will only work if the type cast is indeed compatible.</p><p>For example:</p><pre><code class="lang-c3">int[<span class="number">4</span>] a;
int[<span class="number">4</span>]* b = &amp;a;
int* c = b;

<span class="comment">// Safe cast:</span>
int[<span class="number">4</span>]* d = (int[<span class="number">4</span>]*)c; 
int e = <span class="number">12</span>;
int* f = &amp;e;

<span class="comment">// Incorrect, but not checked</span>
int[<span class="number">4</span>]* g = (int[<span class="number">4</span>]*)f;

<span class="comment">// Also incorrect but not checked.</span>
int[] h = f[<span class="number">0</span>..<span class="number">2</span>];</code></pre><h4>Internals</h4><p>Internally the layout of a slice is guaranteed to be <code>struct { &lt;type&gt;* ptr; usz len; }</code>.</p><p>There is a built-in struct <code>std::core::runtime::SliceRaw</code> which 
has the exact data layout of the fat array pointers. It is defined to be</p><pre><code class="lang-c3">struct SliceRaw
{
    void* ptr;
    usz len;
}</code></pre><h2 id="building-on-mac-using-macports-iteration-over-arrays">Iteration Over Arrays</h2><h3 id="building-on-mac-using-macports-iteration-over-arrays-foreach-element-by-copy">Foreach element by copy</h3><p>You may iterate over slices, arrays and vectors using <code>foreach (Type x : array)</code>. 
Using compile-time type inference this can be abbreviated 
to <code>foreach (x : array)</code> for example:</p><pre><code class="lang-c3">fn void test()
{
    int[<span class="number">4</span>] arr = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span> };
    foreach (item : arr)
    {
        io::printfn(<span class="string">"item: %s"</span>, item);
    }

    <span class="comment">// Or equivalently, writing the type:</span>
    foreach (int x : arr)
    {
        /* ... */
    }
}</code></pre><h3 id="building-on-mac-using-macports-iteration-over-arrays-foreach-element-by-reference">Foreach element by reference</h3><p>Using <code>&amp;</code> it is possible to get an element by reference rather than by copy.
Providing two variables to <code>foreach</code>, the first is assumed to be the index and the second the value:</p><pre><code class="lang-c3">fn void test()
{
    float[<span class="number">4</span>] arr = { };
    foreach (idx, &amp;item : arr)
    {
        item = <span class="number">7</span> + idx; <span class="comment">// Mutates the array element</span>
    }

    <span class="comment">// Or equivalently, writing the types</span>
    foreach (int idx, Foo* &amp;&amp;item  : arr)
    {
        item = <span class="number">7</span> + idx; <span class="comment">// Mutates the array element</span>
    }
}</code></pre><h3 id="building-on-mac-using-macports-iteration-over-arrays-foreach_r-reverse-iterating">Foreach_r reverse iterating</h3><p>With <code>foreach_r</code> arrays or slices can be iterated over in reverse order </p><pre><code class="lang-c3">fn void test()
{
    float[<span class="number">4</span>] arr = { <span class="number"><span class="number">1</span>.<span class="number">0</span></span>, <span class="number"><span class="number">2</span>.<span class="number">0</span></span> };
    foreach_r (idx, item : arr)
    {
        <span class="comment">// Prints <span class="number"><span class="number">2</span>.<span class="number">0</span></span>, <span class="number"><span class="number">1</span>.<span class="number">0</span></span></span>
         io::printfn(<span class="string">"item: %s"</span>, item); 
    }

    <span class="comment">// Or equivalently, writing the types</span>
     foreach_r (int idx, float item : arr)
    {
        <span class="comment">// Prints <span class="number"><span class="number">2</span>.<span class="number">0</span></span>, <span class="number"><span class="number">1</span>.<span class="number">0</span></span></span>
         io::printfn(<span class="string">"item: %s"</span>, item); 
    }
}</code></pre><h2 id="building-on-mac-using-macports-iteration-over-array-like-types">Iteration Over Array-Like types</h2><p>It is possible to enable foreach on any custom type 
by implementing <code>.len</code> and <code>[]</code> methods and annotating them using the <code>@operator</code> attribute:</p><pre><code class="lang-c3">struct DynamicArray
{
    usz count;
    usz capacity;
    int* elements;
}

macro int DynamicArray.get(DynamicArray* arr, usz element) @operator([])
{
    return arr.elements[element];
}

macro usz DynamicArray.count(DynamicArray* arr) @operator(len)
{
    return arr.count;
}

fn void DynamicArray.push(DynamicArray* arr, int value)
{
    arr.ensure_capacity(arr.count + <span class="number">1</span>);  <span class="comment">// Function not shown in example.</span>
    arr.elements[arr.count++] = value;
}

fn void test()
{
    DynamicArray v;
    v.push(<span class="number">3</span>);
    v.push(<span class="number">7</span>);

    <span class="comment">// Will print <span class="number">3</span> and <span class="number">7</span></span>
    foreach (int i : v)
    {
        io::printfn(<span class="string">"%d"</span>, i);
    }
}</code></pre><p>For more information, see <a href="https://waveproc.github.io/generic-programming/operator-overloading/">operator overloading</a></p><h2 id="building-on-mac-using-macports-dynamic-arrays-and-lists">Dynamic Arrays and Lists</h2><p>The standard library offers dynamic arrays and other collections in the <code>std::collections</code> module.</p><pre><code class="lang-c3">def ListStr = List(&lt;String&gt;);

fn void test()
{
    ListStr list_str;    

    <span class="comment">// Initialize the list on the heap.</span>
    list_str.new_init();    

    list_str.push(<span class="string">"Hello"</span>);  <span class="comment">// Add the string <span class="string">"Hello"</span></span>
    list_str.push(<span class="string">"World"</span>);

    foreach (str : list_str)
    {
        io::printn(str);   <span class="comment">// Prints <span class="string">"Hello"</span>, then <span class="string">"World"</span></span>
    }
    String str = list_str[<span class="number">1</span>]; <span class="comment">// str == <span class="string">"World"</span></span>
    list_str.free();        <span class="comment">// Free all memory associated with list.</span>
}</code></pre><h2 id="building-on-mac-using-macports-fixed-size-multi-dimensional-arrays">Fixed Size Multi-Dimensional Arrays</h2><p>To declare two dimensional fixed arrays as <code>&lt;type&gt;[&lt;x-size&gt;, &lt;y-size&gt;] arr</code>, like <code>int[4][2] arr</code>. Below you can see how this compares to C:</p><pre><code class="lang-c"><span class="comment">// C </span>
<span class="comment">// Uses: name[&lt;rows&gt;][&lt;columns&gt;]</span>
int array_in_c[<span class="number">4</span>][<span class="number">2</span>] = {
    {<span class="number">1</span>, <span class="number">2</span>},
    {<span class="number">3</span>, <span class="number">4</span>},
    {<span class="number">5</span>, <span class="number">6</span>},
    {<span class="number">7</span>, <span class="number">8</span>},
};

<span class="comment">// C<span class="number">3</span></span>
<span class="comment">// Uses: &lt;type&gt;[&lt;x-size&gt;][&lt;y-size&gt;]</span>
<span class="comment">// C<span class="number">3</span> declares the dimensions, inner-most to outer-most</span>
int[<span class="number">4</span>][<span class="number">2</span>] array = {
    {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>},
    {<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>},
};

<span class="comment">// To match C we must invert the order of the dimensions </span>
int[<span class="number">2</span>][<span class="number">4</span>] array = {
    {<span class="number">1</span>, <span class="number">2</span>},
    {<span class="number">3</span>, <span class="number">4</span>},
    {<span class="number">5</span>, <span class="number">6</span>},
    {<span class="number">7</span>, <span class="number">8</span>},
};

<span class="comment">// C<span class="number">3</span> also supports Irregular arrays, for example:</span>
int[][<span class="number">4</span>] array = {
    { <span class="number">1</span> },
    { <span class="number">2</span>, <span class="number">3</span> },
    { <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> },
    { <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> },
};</code></pre><p>:::note
Accessing the multi-dimensional fixed array has inverted array index order to when the array was declared.</p><pre><code class="lang-c3"><span class="comment">// Uses: &lt;type&gt;[&lt;x-size&gt;][&lt;y-size&gt;]</span>
int[<span class="number">2</span>][<span class="number">4</span>] array = {
    {<span class="number">1</span>, <span class="number">2</span>},
    {<span class="number">3</span>, <span class="number">4</span>},
    {<span class="number">5</span>, <span class="number">6</span>},
    {<span class="number">7</span>, <span class="number">8</span>},
};

<span class="comment">// Access fixed array using: array[&lt;row&gt;][&lt;column&gt;]</span>
int value = array[<span class="number">3</span>][<span class="number">1</span>]; <span class="comment">// <span class="number">8</span></span></code></pre><p>:::</p><hr><p>title: Define
description: The <code>def</code> statement
sidebar:</p><pre><code>order: 61</code></pre><hr><h1 id="the-def-statement">The “def” statement</h1><p>The <code>def</code> statement in C3 is intended for aliasing identifiers and types.</p><h2 id="the-def-statement-defining-a-type-alias">Defining a type alias</h2><p><code>def &lt;type alias&gt; = &lt;type&gt;</code> creates a type alias. Type aliases need to follow the name convention of user defined types (i.e. capitalized
names with at least one lower case letter).</p><pre><code class="lang-c3">def CharPtr = char*;
def Numbers = int[<span class="number">10</span>];</code></pre><p>Function pointers <em>must</em> be aliased in C3. The syntax is somewhat different from C:</p><pre><code class="lang-c3">def Callback = fn void(int a, bool b);</code></pre><p>This
 defines an alias to function pointer type of a function that returns 
nothing and requires two arguments: an int and a bool. Here is a sample 
usage:</p><pre><code class="lang-c3">Callback cb = my_callback;
cb(<span class="number">10</span>, false);</code></pre><h2 id="the-def-statement-distinct-types">Distinct types</h2><p>Similar to <code>def</code> aliases are <code>distinct</code> which create distinct new types. Unlike type aliases,
they do not implicitly convert to or from any other type.
Literals will convert to the distinct types if they would convert to the underlying type.</p><p>Because a distinct type is a standalone type, it can have its own methods, like any other user-defined type.</p><pre><code class="lang-c3">distinct Foo = int;
Foo f = <span class="number">0</span>; <span class="comment">// Valid since <span class="number">0</span> converts to an int.</span>
f = f + <span class="number">1</span>;
int i = <span class="number">1</span>;
<span class="comment">// f = f + i Error!</span>
f = f + (Foo)i; <span class="comment">// Valid</span></code></pre><h2 id="the-def-statement-distinct-inline">Distinct inline</h2><p>When interacting with various APIs it is sometimes desirable for distinct types to implicitly convert <em>to</em> 
its base type, but not <em>from</em> that type.</p><p>Behaviour here is analogous how structs may use <code>inline</code> to create struct subtypes.</p><pre><code class="lang-c3">distinct CString = char*;
distinct ZString = inline char*;
...
CString abc = <span class="string">"abc"</span>;
ZString def = <span class="string">"def"</span>;
<span class="comment">// char* from_abc = abc; // Error!</span>
char* from_def = def; <span class="comment">// Valid!</span></code></pre><h2 id="the-def-statement-function-and-variable-aliases">Function and variable aliases</h2><p><code>def</code> can also be used to create aliases for functions and variables.</p><p>The syntax is <code>def &lt;alias&gt; = &lt;original identifier&gt;</code>.</p><pre><code class="lang-c3">fn void foo() { ... }
int foo_var;

def bar = foo;
def bar_var = foo_var;

fn void test() 
{
  <span class="comment">// These are the same:</span>
  foo();
  bar();

  <span class="comment">// These access the same variable:</span>
  int x = foo_var;
  int y = bar_var;
}</code></pre><h2 id="the-def-statement-using-def-to-create-generic-types-functions-and-variables">Using <code>def</code> to create generic types, functions and variables</h2><p>It
 is recommended to favour using def to create aliases for parameterized 
types, but it can also be used for parameterized functions and 
variables:</p><pre><code class="lang-c3">import generic_foo;

<span class="comment">// Parameterized function aliases</span>
def int_foo_call = generic_foo::foo_call(&lt;int&gt;);
def double_foo_call = generic_foo::foo_call(&lt;double&gt;);

<span class="comment">// Parameterized type aliases</span>
def IntFoo = Foo(&lt;int&gt;);
def DoubleFoo = Foo(&lt;double&gt;);

<span class="comment">// Parameterized global aliases</span>
def int_max_foo = generic_foo::max_foo(&lt;int&gt;);
def double_max_foo = generic_foo::max_foo(&lt;double&gt;);</code></pre><p>For more information, see the chapter on <a href="https://waveproc.github.io/generic-programming/generics/">generics</a>.</p><h2 id="the-def-statement-function-pointer-default-arguments-and-named-parameters">Function pointer default arguments and named parameters</h2><p>It is possible to attach default arguments to function pointer aliases. There is no requirement
that the function has the same default arguments. In fact, the function pointer may have 
default arguments where the function doesn’t have it and vice-versa. Calling the function
directly will then use the function’s default arguments, and calling through the function pointer
will yield the function pointer alias’ default argument.</p><p>Similarly, named parameter arguments follow the alias definition when calling through the 
function pointer:</p><pre><code class="lang-c3">def TestFn = fn void(int y = <span class="number">123</span>);

fn void test(int x = <span class="number">5</span>)
{
    io::printfn(<span class="string">"X = %d"</span>, x);
}

fn void main()
{
    TestFn test<span class="number">2</span> = &amp;test;
    test();         <span class="comment">// Prints X = <span class="number">5</span></span>
    test<span class="number">2</span>();        <span class="comment">// Prints X = <span class="number">123</span></span>
    test(x: <span class="number">3</span>);     <span class="comment">// Prints X = <span class="number">3</span> </span>
    test<span class="number">2</span>(y: <span class="number">4</span>);    <span class="comment">// Prints X = <span class="number">4</span></span>
}</code></pre><hr><p>title: Strings
description: Strings
sidebar:</p><pre><code>order: 62</code></pre><hr><p>In C3, multiple string types are available, each suited to different use cases.</p><h3 id="the-def-statement-function-pointer-default-arguments-and-named-parameters-string">String</h3><pre><code class="lang-c3">
distinct String = inline char[];</code></pre><p>\
Strings are usually the typical type to use, they can be sliced , compared etc … \
It is possible to access the length of a <code>String</code> instance through the  <code>.len</code>  operator.</p><h3 id="the-def-statement-function-pointer-default-arguments-and-named-parameters-zstring">ZString</h3><pre><code class="lang-c3">
distinct ZString = inline char*;</code></pre><p>\
ZString is used when working with C code, which expects null-terminated C-style strings of type <code>char*</code>. it is a distinct type so converting to a <code>ZString</code> requires an explicit cast. This helps to remind the user to check there is appropriate <code>\0</code> termination of the string data. </p><p>The <a href="#zstring-member-functions">ZString methods</a> are outlined below.</p><p>:::caution<br>Ensure the terminal <code>\0</code> when converting from <code>String</code> to <code>ZString</code>.
:::</p><h4>WString</h4><pre><code class="lang-c3">
distinct WString = inline Char<span class="number">16</span>*;</code></pre><p>\
The <code>WString</code> type is similar to <code>ZString</code> but uses <code>Char16*</code>, typically for UTF-16 encoded strings. This type is useful for applications where 16-bit character encoding is required.</p><h4>DString</h4><pre><code class="lang-c3">
distinct DString (OutStream) = void*;</code></pre><p>\
<code>DString</code> is a dynamic string builder that supports various 
string operations at runtime, allowing for flexible manipulation without
 the need for manual memory allocation.</p><h2 id="the-def-statement-member-functions">Member functions:</h2><h3 id="the-def-statement-member-functions-string-member-functions">String Member Functions</h3><pre><code class="lang-c3">fn Char<span class="number">16</span>[]! String.to_new_utf<span class="number">16</span>(s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Char<span class="number">16</span>[]! String.to_temp_utf<span class="number">16</span>(s);</code></pre><pre><code class="lang-c3">fn WString! String.to_wstring(s, Allocator allocator)</code></pre><p>```c3 implementation
fn String String.free(&amp;s, Allocator allocator = allocator::heap())</p><pre><code>
```c3 implementation
fn String String.tcopy(s) =&gt; s.copy(allocator::temp()) @inline;</code></pre><p>```c3 implementation
fn String String.copy(s, Allocator allocator = allocator::heap())</p><pre><code>
```c3 implementation
fn String String.strip_end(string, String needle);</code></pre><p>```c3 implementation
fn String String.strip(string, String needle);</p><pre><code>
```c3 implementation
fn String String.trim(string, String to_trim);</code></pre><p>```c3 implementation
fn bool String.contains(string, String needle);</p><pre><code>
```c3 implementation
fn bool String.starts_with(string, String needle);</code></pre><p>```c3 implementation
fn bool String.ends_with(string, String needle);</p><pre><code>```c3 implementation
fn usz! String.index_of_char(s, char needle);</code></pre><p>```c3 implementation
fn usz! String.index_of_char_from(s, char needle, usz start_index);</p><pre><code>
```c3 implementation
fn usz! String.index_of(s, String needle)</code></pre><pre><code class="lang-c3">fn usz! String.rindex_of(s, String needle)</code></pre><p>```c3 implementation
fn String[] String.split(s, String needle, usz max = 0, Allocator allocator = allocator::heap());</p><pre><code>
```c3 implementation
fn String String.new_split(s, String needle, usz max = 0) =&gt; s.split(needle, max, allocator::heap()) @inline;</code></pre><p>```c3 implementation
// temporary String split
fn String String.tsplit(s, String needle, usz max = 0) =&gt; s.split(needle, max, allocator::temp());</p><pre><code>
```c3 implementation
fn String String.tconcat(s1, String s2);</code></pre><p>```c3 implementation
fn String String.tconcat(s1, String s2) =&gt; s1.concat(s2, allocator::temp());</p><pre><code>```c3 implementation
fn WString! String.to_temp_wstring(s) =&gt; s.to_wstring(allocator::temp());</code></pre><p>```c3 implementation
fn WString! String.to_new_wstring(s) =&gt; s.to_wstring(allocator::heap());</p><pre><code>```c3 implementation
fn int128! String.to_int128(s, int base = 10) =&gt; s.to_integer(int128, base);</code></pre><p>```c3 implementation
fn long! String.to_long(s, int base = 10) =&gt; s.to_integer(long, base);</p><pre><code>```c3 implementation
fn int! String.to_int(s, int base = 10) =&gt; s.to_integer(int, base);</code></pre><p>```c3 implementation
fn short! String.to_short(s, int base = 10) =&gt; s.to_integer(short, base);</p><pre><code>```c3 implementation
fn ichar! String.to_ichar(s, int base = 10) =&gt; s.to_integer(ichar, base);</code></pre><p>```c3 implementation
fn uint128! String.to_uint128(s, int base = 10) =&gt; s.to_integer(uint128, base);</p><pre><code>```c3 implementation
fn ulong! String.to_ulong(s, int base = 10) =&gt; s.to_integer(ulong, base);</code></pre><p>```c3 implementation
fn uint! String.to_uint(s, int base = 10) =&gt; s.to_integer(uint, base);</p><pre><code>```c3 implementation
fn ushort! String.to_ushort(s, int base = 10) =&gt; s.to_integer(ushort, base);</code></pre><p>```c3 implementation
fn char! String.to_uchar(s, int base = 10) =&gt; s.to_integer(char, base);</p><pre><code>```c3 implementation
fn double! String.to_double(s) =&gt; s.to_real(double);</code></pre><p>```c3 implementation
fn float! String.to_float(s) =&gt; s.to_real(float);</p><pre><code>```c3 implementation
fn String String.new_ascii_to_upper(s, Allocator allocator = allocator::heap());</code></pre><p>```c3 implementation
fn Char16[]! String.to_new_utf16(s, Allocator allocator = allocator::heap());</p><pre><code>
```c3 implementation
fn Char16[]! String.to_temp_utf16(s);</code></pre><p>```c3 implementation
fn Char32[]! String.to_utf32(s, Allocator allocator);</p><pre><code>
```c3 implementation
fn Char32[]! String.to_new_utf32(s) =&gt; s.to_utf32(allocator::heap()) @inline;</code></pre><p>```c3 implementation
fn Char32[]! String.to_temp_utf32(s) =&gt; s.to_utf32(allocator::temp()) @inline;</p><pre><code>
```c3 implementation
fn WString! String.to_wstring(s, Allocator allocator);</code></pre><pre><code class="lang-c3">fn WString! String.to_new_wstring(s) =&gt; s.to_wstring(allocator::heap());</code></pre><pre><code class="lang-c3">fn WString! String.to_temp_wstring(s) =&gt; s.to_wstring(allocator::temp());</code></pre><pre><code class="lang-c3">fn StringIterator String.iterator(s);</code></pre><h3 id="the-def-statement-member-functions-zstring-member-functions">ZString Member Functions</h3><p>```c3 implementation
fn String ZString.str_view(str);</p><pre><code>
```c3 implementation
fn usz ZString.char_len(str);</code></pre><p>```c3 implementation
fn usz ZString.len(str);</p><pre><code>```c3 implementation
fn ZString String.zstr_copy(s, Allocator allocator = allocator::heap())</code></pre><p>```c3 implementation
fn ZString String.zstr_tcopy(s) =&gt; s.zstr_copy(allocator::temp()) @inline;</p><pre><code>

---
title: Vectors
description: Vectors
sidebar:
    order: 63
---

Vectors - where possible - based on underlying hardware vector implementations. A vector is similar to an array, but 
with additional functionality. The restriction is that a vector may only consist of elements that are numerical
types, boolean or pointers.

A vector is declared similar to an array but uses `[&lt;&gt;]` rather than `[]`, e.g. `int[&lt;4&gt;]`.

(If you are searching for the counterpart of C++'s `std::vector`, look instead at the standard
library [`List` type](/language-common/arrays/#dynamic-arrays-and-lists).)

## Arithmetics on vectors

Vectors support all arithmetics and other operations supported by its underlying type. The operations are
always performed elementwise.

```c3
int[&lt;2&gt;] a = { 23, 11 };
int[&lt;2&gt;] b = { 2, 1 };
int[&lt;2&gt;] c = a * b;     // c = { 46, 11 }</code></pre><p>For integer and boolean types, bit operations such as <code>^ | &amp; &lt;&lt; &gt;&gt;</code> are available, and for pointers, pointer arithmetic
is supported.</p><h3 id="the-def-statement-member-functions-scalar-values">Scalar values</h3><p>Scalar values will implicitly widen to vectors when used with vectors:</p><pre><code class="lang-c3">int[&lt;<span class="number">2</span>&gt;] d = { <span class="number">21</span>, <span class="number">14</span> };
int[&lt;<span class="number">2</span>&gt;] e = d / <span class="number">7</span>;      <span class="comment">// e = { <span class="number">3</span>, <span class="number">2</span> }</span>
int[&lt;<span class="number">2</span>&gt;] f = <span class="number">4</span>;          <span class="comment">// f = { <span class="number">4</span>, <span class="number">4</span> }</span></code></pre><h2 id="the-def-statement-additional-operations">Additional operations</h2><p>The <code>std::math</code> module contains a wealth of additional operations available on vectors using dot-method syntax.</p><ul>
<li><code>.sum()</code> - sum all vector elements.</li>
<li><code>.product()</code> - multiply all vector elements.</li>
<li><code>.max()</code> - get the maximum element.</li>
<li><code>.min()</code> - get the minimum element.</li>
<li><code>.dot(other)</code> - return the dot product with the other vector.</li>
<li><code>.length(other)</code> - return the square root of the dot product (not available on integer vectors).</li>
<li><code>.distance(other)</code> - return the length of the difference of the two vectors (not available on integer vectors).</li>
<li><code>.normalize()</code> - return a normalized vector (not available on integer vectors).</li>
<li><code>.comp_lt(other)</code> - return a boolean vector with a component wise “&lt;” </li>
<li><code>.comp_le(other)</code> - return a boolean vector with a component wise “&lt;=”  </li>
<li><code>.comp_eq(other)</code> - return a boolean vector with a component wise “==”  </li>
<li><code>.comp_gt(other)</code> - return a boolean vector with a component wise “&gt;”  </li>
<li><code>.comp_ge(other)</code> - return a boolean vector with a component wise “&gt;=”  </li>
<li><code>.comp_ne(other)</code> - return a boolean vector with a component wise “!=”  </li>
</ul><p>Dot methods available for scalar values, such as <code>ceil</code>, <code>fma</code> etc are in general also available for vectors.</p><h2 id="the-def-statement-swizzling">Swizzling</h2><p>Swizzling using dot notation is supported, using x, y, z, w <em>or</em> r, g, b, a:</p><pre><code class="lang-c3">int[&lt;<span class="number">3</span>&gt;] a = { <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span> };
int[&lt;<span class="number">4</span>&gt;] b = a.xxzx;                         <span class="comment">// b = { <span class="number">11</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">11</span> }</span>
int c = b.w;                                 <span class="comment">// c = <span class="number">11</span>;</span>
char[&lt;<span class="number">4</span>&gt;] color = { <span class="number">0</span>x<span class="number">11</span>, <span class="number">0</span>x<span class="number">22</span>, <span class="number">0</span>x<span class="number">33</span>, <span class="number">0</span>xFF };
char red = color.r;                          <span class="comment">// red = <span class="number">0</span>x<span class="number">11</span></span></code></pre><h2 id="the-def-statement-array-like-operations">Array-like operations</h2><p>Like arrays, it’s possible to make slices and iterate over vectors. It should be noted that the storage alignment of
vectors are often different from arrays, which should be taken into account when storing vectors.</p><hr><p>title: Essential Error Handling
description: Essential Error Handling
sidebar:</p><pre><code>order: 64</code></pre><hr><p>In this section we will go over the <em>essential</em> information about Optionals and safe methods for working with them, for example 
 <a href="#checking-if-an-optional-is-empty"><code>if (catch optional_value)</code></a> 
 and the <a href="#using-the-rethrow-operator--to-unwrap-an-optional-value">Rethrow operator <code>!</code></a>.</p><p>In the <a href="https://waveproc.github.io/language-common/optionals-advanced/">advanced section</a> there are other <em>nice to have</em> features. 
Like an alternative to safely unwrap a result from an Optionals using 
<a href="https://waveproc.github.io/language-common/optionals-advanced/#run-code-if-the-optional-has-a-result"><code>if (try optional_value)</code></a> 
and an unsafe method to <a href="https://waveproc.github.io/language-common/optionals-advanced/#force-unwrapping-expressions">force unwrap <code>!!</code></a> 
a result from an Optional, return <a href="https://waveproc.github.io/language-common/optionals-advanced/#return-a-default-value-if-optional-is-empty">default values for optionals <code>??</code></a> if they are empty and other more specialised concepts.</p><h2 id="the-def-statement-what-is-an-optional">What is an Optional?</h2><p>Optionals are a safer alternative to returning <code>-1</code> or <code>null</code> from 
a function, when a valid value can’t be returned. An Optional 
has either a <em>result</em> or is <em>empty</em>. When an Optional 
is empty it has an <code>Excuse</code> explaining what happened. </p><ul>
<li>For example trying to open a missing file returns the <code>Excuse</code> of <code>IoError.FILE_NOT_FOUND</code>.</li>
<li>Optionals are declared by adding <code>!</code> after the type.</li>
<li>An <code>Excuse</code> is of the type <code>anyfault</code>.<pre><code class="lang-c3">int! a = <span class="number">1</span>; <span class="comment">// Set the Optional to a result</span></code></pre>
The Optional Excuse is set with <code>?</code> after the value.<pre><code class="lang-c3"><span class="comment">// Set the Optional to empty with a specific Excuse.</span>
int! b = IoError.FILE_NOT_FOUND?;</code></pre>
</li>
</ul><h2 id="the-def-statement-unwrapping-an-optional">🎁 Unwrapping an Optional</h2><p>:::note</p><p>Unwrapping an Optional is safe because it checks it has a 
result present before trying to use it.</p><p>After unwrapping, the variable then behaves like a normal variable, a non-Optional.
:::</p><h2 id="the-def-statement-checking-if-an-optional-is-empty">Checking if an Optional is empty</h2><pre><code class="lang-c3">import std::io;

fn void! test()
{
    <span class="comment">// Return an Excuse by adding <span class="string">'?'</span> after the fault.</span>
    return IoError.FILE_NOT_FOUND?; 
}

fn void main(String[] args)
{
    <span class="comment">// If the Optional is empty, assign the</span>
    <span class="comment">// Excuse to a variable: </span>
    if (catch excuse = test())
    {
        io::printfn(<span class="string">"test() gave an Excuse: %s"</span>, excuse);
    }
}</code></pre><h3 id="the-def-statement-checking-if-an-optional-is-empty-automatically-unwrapping-an-optional-result">Automatically unwrapping an Optional result</h3><p>If we escape the current scope from an <code>if (catch my_var)</code> using a <code>return</code>, <code>break</code>, <code>continue</code> 
or <a href="#using-the-rethrow-operator--to-unwrap-an-optional-value">Rethrow</a> <code>!</code>,
then the variable is automatically <a href="#-unwrapping-an-optional">unwrapped</a> to a non-Optional:</p><pre><code class="lang-c3">fn void! test() 
{
    int! foo = unreliable_function();
    if (catch excuse = foo) 
    {
        <span class="comment">// Return the excuse with `?` operator</span>
        return excuse?;
    }
    <span class="comment">// Because the compiler knows <span class="string">'foo'</span> cannot</span>
    <span class="comment">// be empty here, it is unwrapped to non-Optional</span>
    <span class="comment">// <span class="string">'int foo'</span> in this scope:</span>
    io::printfn(<span class="string">"foo: %s"</span>, foo); <span class="comment">// <span class="number">7</span></span>
}</code></pre><h3 id="the-def-statement-checking-if-an-optional-is-empty-using-the-rethrow-operator-to-unwrap-an-optional-value">Using the Rethrow operator <code>!</code> to unwrap an Optional value</h3><ul>
<li>The Rethrow operator <code>!</code> will return from the function with the <code>Excuse</code> if the Optional result is empty.</li>
<li>The resulting value will be <a href="#-unwrapping-an-optional">unwrapped</a> to a non-Optional. </li>
</ul><pre><code class="lang-c3">import std::io;

<span class="comment">// Function returning an Optional</span>
fn int! maybe_func() { /* ... */ }

fn void! test() 
{
    <span class="comment">// ❌ This will be a compile error</span>
    <span class="comment">// maybe_function() returns an Optional</span>
    <span class="comment">// and <span class="string">'bar'</span> is not declared Optional:</span>
    <span class="comment">// int bar = maybe_function();</span>

    int bar = maybe_function()!; 
    <span class="comment">// ✅ The above is equivalent to:    </span>
    <span class="comment">// int! temp = maybe_function();</span>
    <span class="comment">// if (catch excuse = temp) return excuse?</span>

    <span class="comment">// Now temp is unwrapped to a non-Optional</span>
    int bar = temp; <span class="comment">// ✅ This is OK</span>
}</code></pre><h2 id="the-def-statement-optionals-affect-types-and-control-flow">⚠️ Optionals affect types and control flow</h2><h3 id="the-def-statement-optionals-affect-types-and-control-flow-optionals-in-expressions-produce-optionals">Optionals in expressions produce Optionals</h3><p>Use an Optional anywhere in an expression the resulting
expression will be an Optional too.</p><pre><code class="lang-c3">import std::io;

fn void main(String[] args)
{
    <span class="comment">// Returns Optional with result of type `int` or an Excuse</span>
    int! first_optional = <span class="number">7</span>;

    <span class="comment">// This is Optional too:</span>
    int! second_optional = first_optional + <span class="number">1</span>;
}</code></pre><h3 id="the-def-statement-optionals-affect-types-and-control-flow-optionals-affect-function-return-types">Optionals affect function return types</h3><pre><code class="lang-c3">import std::io;

fn int test(int input) 
{
    io::printn(<span class="string">"test(): inside function body"</span>);
    return input;
}

fn void main(String[] args)
{
    int! optional_argument = <span class="number">7</span>;

    <span class="comment">// `optional_argument` makes returned `returned_optional` </span>
    <span class="comment">// Optional too: </span>
    int! returned_optional = test(optional_argument);
}</code></pre><h3 id="the-def-statement-optionals-affect-types-and-control-flow-functions-conditionally-run-when-called-with-optional-arguments">Functions conditionally run when called with Optional arguments</h3><p>When calling a function with an Optionals as arguments, 
the result will be the first Excuse found looking left-to-right. 
The function is only executed if all Optional arguments
have a result.</p><pre><code class="lang-c3">import std::io;

fn int test(int input, int input<span class="number">2</span>) 
{
    io::printn(<span class="string">"test(): inside function body"</span>);
    return input;
}

fn void main(String[] args)
{
    int! first_optional = IoError.FILE_NOT_FOUND?;
    int! second_optional = <span class="number">7</span>;

    <span class="comment">// Return first excuse we find</span>
    int! third_optional = test(first_optional, second_optional);
    if (catch excuse = third_optional) 
    {
        <span class="comment">// excuse == IoError.FILE_NOT_FOUND</span>
        io::printfn(<span class="string">"third_optional's Excuse: %s"</span>, excuse); 
    }
}</code></pre><h2 id="the-def-statement-interfacing-with-c">Interfacing with C</h2><p>For C the interface to C3:
- The <code>Excuse</code> in the Optional of type <code>anyfault</code> is returned as the regular return.
- The result in the Optional is passed by reference.</p><p>For example:</p><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> code:</span>
fn int! get_value();</code></pre><pre><code class="lang-c"><span class="comment">// Corresponding C code:</span>
c<span class="number">3</span>fault_t get_value(int *value_ref);</code></pre><p>The <code>c3fault_t</code> is guaranteed to be a pointer sized value.</p><hr><p>title: Advanced Error Handling
description: Advanced Error Handling
sidebar:</p><pre><code>order: 65</code></pre><hr><h3 id="the-def-statement-interfacing-with-c-optionals-are-only-defined-in-certain-code">Optionals are only defined in certain code</h3><p>✅ Variable declarations</p><pre><code class="lang-c3">int! example = unreliable_function();</code></pre><p>✅ Function return signature</p><pre><code class="lang-c3">fn int! example() { /* ... */ }</code></pre><h2 id="the-def-statement-handling-an-empty-optional">Handling an empty Optional</h2><h3 id="the-def-statement-handling-an-empty-optional-file-reading-example">File reading example</h3><ul>
<li>If the file is present the Optional result will be the first 100 bytes of the file.</li>
<li>If the file is not present the Optional <code>Excuse</code> will be <code>IoError.FILE_NOT_FOUND</code>.</li>
</ul><p>Try running this code below with and without a file called <code>file_to_open.txt</code> in the same directory.</p><pre><code class="lang-c3">import std::io;

&lt;*
 Function modifies <span class="string">'buffer'</span>
 Returns an Optional with a <span class="string">'char[]'</span> result 
 OR an empty Optional with an Excuse
*&gt;
fn char[]! read_file(String filename, char[] buffer)
{
    <span class="comment">// Return Excuse if opening a file failed, using Rethrow `!`</span>
    File file = file::open(filename, <span class="string">"r"</span>)!; 

    <span class="comment">// At scope exit, close the file.</span>
    <span class="comment">// Discard the Excuse from file.close() with (void) cast</span>
    defer (void)file.close(); 

    <span class="comment">// Return Excuse if reading failed, using Rethrow `!`</span>
    file.read(buffer)!; 
    return buffer; <span class="comment">// return a buffer result</span>
}

fn void! test_read()
{
    char[] buffer = mem::new_array(char, <span class="number">100</span>);
    defer free(buffer); <span class="comment">// Free memory on scope exit</span>

    char[]! read_buffer = read_file(<span class="string">"file_to_open.txt"</span>, buffer);
    <span class="comment">// Catch the empty Optional and assign the Excuse </span>
    <span class="comment">// to `excuse`</span>
    if (catch excuse = read_buffer) 
    {
        io::printfn(<span class="string">"Excuse found: %s"</span>, excuse);
        <span class="comment">// Returning Excuse using the `?` suffix</span>
        return excuse?;
    }

    <span class="comment">// `read_buffer` behaves like a normal variable here </span>
    <span class="comment">// because the Optional being empty was handled by <span class="string">'if (catch)'</span></span>
    <span class="comment">// which automatically unwrapped <span class="string">'read_buffer'</span> at this point.</span>
    io::printfn(<span class="string">"read_buffer: %s"</span>, read_buffer);
}

fn void main()
{
    test_read()!!; <span class="comment">// Panic on failure.</span>
}</code></pre><h3 id="the-def-statement-handling-an-empty-optional-return-a-default-value-if-optional-is-empty">Return a default value if Optional is empty</h3><p>The <code>??</code> operator allows us to return a default value if the Optional is empty.</p><pre><code class="lang-c3">import std::io;

fn void test_bad() 
{
    int regular_value;
    int! optional_value = function_may_error();

    <span class="comment">// An empty Optional found in optional_value</span>
    if (catch optional_value) 
    {   
        <span class="comment">// Assign default result when empty.</span>
        regular_value = -<span class="number">1</span>;
    }

    <span class="comment">// A result was found in optional_value</span>
    if (try optional_value) 
    {
        regular_value = optional_value;
    }
    io::printfn(<span class="string">"The value was: %d"</span>, regular_value);
}

fn void test_good() 
{
    <span class="comment">// Return <span class="string">'-<span class="number">1</span>'</span> when `foo_may_error()` is empty.</span>
    int regular_value = foo_may_error() ?? -<span class="number">1</span>;

    io::printfn(<span class="string">"The value was: %d"</span>, regular_value);
}</code></pre><h4>Modifying the returned Excuse</h4><p>A common use of <code>??</code> is to catch an empty Optional and change 
the <code>Excuse</code> to another more specific <code>Excuse</code>, which 
allows us to distinguish one failure from the other, 
even when they had the same <code>Excuse</code> originally.</p><pre><code class="lang-c3">import std::io;

fault NoHomework
{
    DOG_ATE_MY_HOMEWORK,
    MY_TEXTBOOK_CAUGHT_FIRE,
    DISTRACTED_BY_CAT_PICTURES
}

fn int! test() 
{
    return IoError.FILE_NOT_FOUND?;
}

fn void! examples() 
{
    int! a = test(); <span class="comment">// IoError.FILE_NOT_FOUND</span>
    int! b = test(); <span class="comment">// IoError.FILE_NOT_FOUND</span>

    <span class="comment">// We can tell these apart by default assigning our own unique</span>
    <span class="comment">// Excuse. Our custom Excuse is assigned only if an</span>
    <span class="comment">// empty Optional is returned.</span>
    int! c = test() ?? NoHomework.DOG_ATE_MY_HOMEWORK?;
    int! d = test() ?? NoHomework.DISTRACTED_BY_CAT_PICTURES?;

    <span class="comment">// If you want to immediately return with an Excuse, </span>
    <span class="comment">// use the <span class="string">"?"</span> and <span class="string">"!"</span> operators together, see the code below:</span>
    int! e = test() ?? NoHomework.DOG_ATE_MY_HOMEWORK?!;
    int! f = test() ?? NoHomework.DISTRACTED_BY_CAT_PICTURES?!;
}</code></pre><h3 id="the-def-statement-handling-an-empty-optional-force-unwrapping-expressions">Force unwrapping expressions</h3><p>The force <a href="https://waveproc.github.io/language-common/optionals-essential/#-unwrapping-an-optional">unwrap</a> operator <code>!!</code> will 
make the program panic and exit if the expression is an empty optional. 
This is useful when the error should – in normal cases – not happen 
and you don’t want to write any error handling for it. 
That said, it should be used with great caution in production code.</p><pre><code class="lang-c3">fn void find_file_and_test()
{
    find_file()!!;

    <span class="comment">// Force unwrap <span class="string">'!!'</span> is roughly equal to:</span>
    <span class="comment">// if (catch find_file()) unreachable(<span class="string">"Unexpected excuse"</span>);</span>
}</code></pre><h3 id="the-def-statement-handling-an-empty-optional-find-empty-optional-without-reading-the-excuse">Find empty Optional without reading the Excuse</h3><pre><code class="lang-c3">import std::io;
fn void test() 
{
    int! optional_value = IoError.FILE_NOT_FOUND?;

    <span class="comment">// Find empty Optional, then handle inside scope</span>
    if (catch optional_value) 
    {
        io::printn(<span class="string">"Found empty Optional, the Excuse was not read"</span>);
    } 
}</code></pre><h3 id="the-def-statement-handling-an-empty-optional-find-empty-optional-and-switch-on-excuse">Find empty Optional and switch on Excuse</h3><p><code>if (catch)</code> can also immediately switch on the <code>Excuse</code> value:</p><pre><code class="lang-c3">fn void! test() 
{
    if (catch excuse = optional_value)
    {
        case NoHomework.DOG_ATE_MY_HOMEWORK:
            io::printn(<span class="string">"Dog ate your file"</span>);
        case IoError.FILE_NOT_FOUND:
            io::printn(<span class="string">"File not found"</span>);
        default:
            io::printfn(<span class="string">"Unexpected Excuse: %s"</span>, excuse);
            return excuse?;
    }
}</code></pre><p>Which is shorthand for:</p><pre><code class="lang-c3">fn void! test() 
{
    if (catch excuse = optional_value)
    {
        switch (excuse)
        {
            case NoHomework.DOG_ATE_MY_HOMEWORK:
                io::printn(<span class="string">"Dog ate your file"</span>);
            case IoError.FILE_NOT_FOUND:
                io::printn(<span class="string">"File not found"</span>);
            default:
                io::printfn(<span class="string">"Unexpected Excuse: %s"</span>, excuse);
                return excuse?;
        }
    }
}</code></pre><h2 id="the-def-statement-run-code-if-the-optional-has-a-result">Run code if the Optional has a result</h2><p>This is a convenience method, the logical inverse of 
<a href="https://waveproc.github.io/language-common/optionals-essential/#checking-if-an-optional-is-empty"><code>if (catch)</code></a> 
and is helpful when you don’t care about the empty branch of 
the code or you wish to perform an early return.</p><pre><code class="lang-c3">fn void test()
{
    <span class="comment">// <span class="string">'optional_value'</span> is a non-Optional variable inside the scope</span>
    if (try optional_value) 
    {
        io::printfn(<span class="string">"Result found: %s"</span>, optional_value);    
    } 

    <span class="comment">// The Optional result is assigned to <span class="string">'unwrapped_value'</span> inside the scope</span>
    if (try unwrapped_value = optional_value)
    {
        io::printfn(<span class="string">"Result found: %s"</span>, unwrapped_value);    
    }  
}</code></pre><p>Another example:</p><pre><code class="lang-c3">import std::io;

<span class="comment">// Returns Optional result with `int` type or empty with an Excuse</span>
fn int! reliable_function()
{
    return <span class="number">7</span>; <span class="comment">// Return a result</span>
}

fn void main(String[] args)
{
    int! reliable_result = reliable_function();

    <span class="comment">// Unwrap the result from reliable_result</span>
    if (try reliable_result)
    {
        <span class="comment">// reliable_result is unwrapped in this scope, can be used as normal</span>
        io::printfn(<span class="string">"reliable_result: %s"</span>, reliable_result);
    }
}</code></pre><p>It is possible to add conditions to an <code>if (try)</code> but they must be 
joined with <code>&amp;&amp;</code>. However you <strong>cannot</strong> use logical OR (<code>||</code>) conditions:</p><pre><code class="lang-c3">import std::io;

<span class="comment">// Returns Optional with an <span class="string">'int'</span> result or empty with an Excuse</span>
fn int! reliable_function()
{
    return <span class="number">7</span>; <span class="comment">// Return an Optional result</span>
}

fn void main(String[] args)
{
    int! reliable_result<span class="number">1</span> = reliable_function();
    int! reliable_result<span class="number">2</span> = reliable_function();

    <span class="comment">// Unwrap the result from reliable_result<span class="number">1</span> and reliable_result<span class="number">2</span></span>
    if (try reliable_result<span class="number">1</span> &amp;&amp; try reliable_result<span class="number">2</span> &amp;&amp; <span class="number">5</span> &gt; <span class="number">2</span>)
    {
        <span class="comment">// `reliable_result<span class="number">1</span>` is can be used as a normal variable here</span>
        io::printfn(<span class="string">"reliable_result<span class="number">1</span>: %s"</span>, reliable_result<span class="number">1</span>);

        <span class="comment">// `reliable_result<span class="number">2</span>` is can be used as a normal variable here</span>
        io::printfn(<span class="string">"reliable_result<span class="number">2</span>: %s"</span>, reliable_result<span class="number">2</span>);
    }

    <span class="comment">// ERROR cannot use logical OR `||`</span>
    <span class="comment">// if (try reliable_result<span class="number">1</span> || try reliable_result<span class="number">2</span>)</span>
    <span class="comment">// {</span>
    <span class="comment">//     io::printn("this can never happen);</span>
    <span class="comment">// }</span>
}</code></pre><h2 id="the-def-statement-shorthands-to-work-with-optionals">Shorthands to work with Optionals</h2><h3 id="the-def-statement-shorthands-to-work-with-optionals-getting-the-excuse">Getting the Excuse</h3><p>Retrieving the <code>Excuse</code> with <a href="https://waveproc.github.io/language-common/optionals-essential/#checking-if-an-optional-is-empty"><code>if (catch excuse = optional_value) {...}</code></a> 
is not the only way to get the <code>Excuse</code> from an Optional, we can use the macro <code>@catch</code> instead.
Unlike <code>if (catch)</code> this will never cause automatic <a href="https://waveproc.github.io/language-common/optionals-essential/#-unwrapping-an-optional">unwrapping</a>.</p><pre><code class="lang-c3">fn void main(String[] args)
{
    int! optional_value = IoError.FILE_NOT_FOUND?;

    anyfault excuse = @catch(optional_value);
    if (excuse)
    {
        io::printfn(<span class="string">"Excuse found: %s"</span>, excuse);
    }
}</code></pre><h3 id="the-def-statement-shorthands-to-work-with-optionals-checking-if-an-optional-has-a-result-without-unwrapping">Checking if an Optional has a result without unwrapping</h3><p>The <code>@ok</code> macro will return <code>true</code> if an Optional result is present and 
<code>false</code> if the Optional is empty. 
Functionally this is equivalent to <a href="#getting-the-excuse"><code>!@catch</code></a>, meaning no Excuse was found, for example:</p><pre><code class="lang-c3">fn void main(String[] args)
{
    int! optional_value = <span class="number">7</span>;

    bool result_found = @ok(optional_value);
    assert(result_found == !@catch(optional_value));
}</code></pre><h2 id="the-def-statement-no-void-variables">No void! variables</h2><p>The <code>void!</code> type has no possible representation as a variable, and may
only be a function return type. </p><p>To store the <code>Excuse</code> returned from a <code>void!</code> function without 
<a href="https://waveproc.github.io/language-common/optionals-essential/#checking-if-an-optional-is-empty"><code>if (catch foo = optional_value)</code></a>, 
use the <a href="#getting-the-excuse"><code>@catch</code></a> macro to convert the Optional to an <code>anyfault</code>:</p><pre><code class="lang-c3">fn void! test() 
{
    return IoError.FILE_NOT_FOUND?;
}

anyfault excuse = @catch(test());</code></pre><hr><p>title: Defer and Cleanup
description: Defer and Cleanup
sidebar:</p><pre><code>order: 66</code></pre><hr><h1 id="defer">Defer</h1><p>A <code>defer</code> <em>always</em> runs at the <a href="#end-of-a-scope">end of a scope</a> at any point <em>after</em> it is declared, <code>defer</code>
 is commonly used to simplify code that needs clean-up; like closing 
unix file descriptors, freeing dynamically allocated memory or closing 
database connections.</p><h3 id="defer-end-of-a-scope">End of a scope</h3><p>The end of a scope also includes <code>return</code>, <code>break</code>, <code>continue</code> or <a href="https://waveproc.github.io/language-common/optionals-essential/#using-the-rethrow-operator--to-unwrap-an-optional-value">rethrow <code>!</code></a>. </p><pre><code class="lang-c3">fn void test() 
{
    io::printn(<span class="string">"print first"</span>);
    defer io::printn(<span class="string">"print third, on function return"</span>);
    io::printn(<span class="string">"print second"</span>);
    return;
}</code></pre><p>The <code>defer</code> runs <strong>after</strong> the other print statements, at the function return.</p><p>:::note
<a href="https://waveproc.github.io/language-common/optionals-essential/#using-the-rethrow-operator--to-unwrap-an-optional-value">Rethrow <code>!</code></a>
 unwraps the Optional result if present, afterwards the previously 
Optional variable is a normal variable again, if the Optional result is 
empty then the Excuse is returned from the function back to the caller.
:::</p><h3 id="defer-defer-execution-order">Defer Execution order</h3><p>When there are multiple <code>defer</code> statements they are executed in reverse order of their declaration, last-to-first declared. </p><pre><code class="lang-c3">fn void test() 
{
    io::printn(<span class="string">"print first"</span>);
    defer io::printn(<span class="string">"print third, defers execute in reverse order"</span>);
    defer io::printn(<span class="string">"print second, defers execute in reverse order"</span>);
    return;
}</code></pre><h3 id="defer-example-defer">Example defer</h3><pre><code class="lang-c3">import std::io;

fn char[]! file_read(String filename, char[] buffer)
{   
    <span class="comment">// return Excuse if failed to open file</span>
    File file = file::open(filename, <span class="string">"r"</span>)!; 

    defer { 
        io::printn(<span class="string">"File was found, close the file"</span>); 
        if (catch excuse = file.close()) 
        {
            io::printfn(<span class="string">"Fault closing file: %s"</span>, excuse); 
        }
    }

    <span class="comment">// return if fault reading the file into the buffer</span>
    file.read(buffer)!; 
    return buffer;
}</code></pre><p>If the file named <code>filename</code> is found the function will read the content into a buffer, 
<code>defer</code> will then make sure that any open <code>File</code> handlers are closed. 
Note that if a scope exit happens before the <code>defer</code> declaration, the <code>defer</code> will not run, this a useful property because if the file failed to open, we don’t need to close it.</p><h2 id="defer-defer-try">Defer try</h2><p>A <code>defer try</code> is called at <a href="#end-of-a-scope">end of a scope</a> when the returned <a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">Optional contained a result</a> value.</p><h3 id="defer-defer-try-examples">Examples</h3><pre><code class="lang-c3">fn void! test() 
{
    defer try io::printn(<span class="string">"✅ defer try run"</span>); 
    <span class="comment">// Returned an Optional result</span>
    return;
}

fn void main(String[] args) 
{
    (void)test();
}</code></pre><p>Function returns an <a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">Optional result</a> value, 
this means <code>defer try</code> runs on <a href="#end-of-a-scope">scope exit</a>.</p><pre><code class="lang-c3">fn void! test() 
{
    defer try io::printn(<span class="string">"❌ defer try not run"</span>);
    <span class="comment">// Returned an Optional Excuse</span>
    return IoError.FILE_NOT_FOUND?;
}

fn void main(String[] args) 
{
    if (catch err = test()) 
    {
        io::printfn(<span class="string">"test() returned a fault: %s"</span>, err);
    }
}</code></pre><p>Function returns an <a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">Optional Excuse</a>, 
this means the <code>defer try</code> does <em>not</em> run on <a href="#end-of-a-scope">scope exit</a>.</p><h2 id="defer-defer-catch">Defer catch</h2><p>A <code>defer catch</code> is called at <a href="#end-of-a-scope">end of a scope</a> when exiting exiting with an 
<a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">Optional Excuse</a>, and is helpful for logging, cleanup and freeing resources.</p><pre><code class="lang-c3">defer catch { ... }</code></pre><pre><code class="lang-c3">defer (catch err) { ... };</code></pre><p>When the fault is captured this is convenient for logging the fault:</p><pre><code class="lang-c3">defer (catch err) io::printfn(<span class="string">"fault found: %s"</span>, err)</code></pre><h3 id="defer-defer-catch-memory-allocation-example">Memory allocation example</h3><pre><code class="lang-c3">import std::core::mem;

fn char[]! test()
{
    char[] data = mem::new_array(char, <span class="number">12</span>)!;

    defer (catch err) 
    {
        io::printfn(<span class="string">"Excuse found: %s"</span>, err)
        (void)free(data);
    }

    <span class="comment">// Returns Excuse, memory gets freed</span>
    return IoError.FILE_NOT_FOUND?; 
}</code></pre><h2 id="defer-pitfalls-with-defer-and-defer-catch">Pitfalls with defer and defer catch</h2><p>If cleaning up memory allocations or resources make sure the <code>defer</code> or <code>defer catch</code> 
are declared as close to the resource declaration as possible. 
This helps to avoid unwanted memory leaks or unwanted resource usage from other code <a href="https://waveproc.github.io/language-common/optionals-essential/#using-the-rethrow-operator--to-unwrap-an-optional-value">rethrowing <code>!</code></a> before the <code>defer catch</code> was even declared. </p><pre><code class="lang-c3">fn void! function_throws() 
{
    return IoError.FILE_NOT_FOUND?;
}

fn String! test()
{
    char[] data = mem::new_array(char, <span class="number">12</span>)!;

    <span class="comment">// ❌ Before the defer catch declaration</span>
    <span class="comment">// memory was NOT freed</span>
    <span class="comment">// function_throws()!;  </span>

    defer (catch err) 
    {
        io::printn(<span class="string">"freeing memory"</span>);
        (void)free(data);
    }

    <span class="comment">// ✅ After the defer catch declaration</span>
    <span class="comment">// memory freed correctly</span>
    function_throws()!;     

    return (String)data; 
}</code></pre><hr><p>title: Contracts
description: Contracts
sidebar:</p><pre><code>order: 67</code></pre><hr><p>Contracts are optional pre- and post-conditions checks that the compiler may use for optimization and runtime checks. Note that <em>compilers are not obliged to process pre- and post-conditions at all</em>.
 However, violating either pre- or post-conditions is considered 
undefined behaviour, so a compiler may optimize as if they always hold –
 even if a potential bug may cause them to be violated.</p><h1 id="pre-conditions">Pre-conditions</h1><p>Pre-conditions are usually used to validate incoming arguments. 
Each condition must be an expression that can be evaluated to a boolean. 
Pre-conditions use the <code>@require</code> annotation, and optionally can have an 
error message to display after them.</p><pre><code class="lang-c3">&lt;*
 @require foo &gt; <span class="number">0</span>, foo &lt; <span class="number">1000</span>, <span class="string">"optional error msg"</span>
*&gt;
fn int testFoo(int foo)
{
    return foo * <span class="number">10</span>;
}</code></pre><h1 id="post-conditions">Post conditions</h1><p>Post conditions are evaluated to make checks on the resulting state after passing through the function.
The post condition uses the <code>@ensure</code> annotation. Where <code>return</code> is used to represent the return value from the function. </p><pre><code class="lang-c3">&lt;*
 @require foo != null
 @ensure return &gt; foo.x
*&gt;
fn uint checkFoo(Foo* foo)
{
    uint y = abs(foo.x) + <span class="number">1</span>;
    <span class="comment">// If we had row: foo.x = <span class="number">0</span>, then this would be a compile time error.</span>
    return y * abs(foo.x);
}</code></pre><h2 id="post-conditions-parameter-annotations">Parameter annotations</h2><p><code>@param</code> supports <code>[in]</code> <code>[out]</code> and <code>[inout]</code>. These are only applicable
for pointer arguments. <code>[in]</code> disallows writing to the variable,
<code>[out]</code> disallows reading from the variable. Without an annotation,
pointers may both be read from and written to without checks. If an <code>&amp;</code> is placed
in front of the annotation (e.g. <code>[&amp;in]</code>), then this means the pointer must be non-null
and is checked for <code>null</code>.</p><table>
<thead>
<tr>
<th>Type</th>
<th align="center">readable?</th>
<th align="center">writable?</th>
<th align="center">use as “in”?</th>
<th align="center">use as “out”?</th>
<th align="center">use as “inout”</th>
</tr>
</thead>
<tbody>
<tr>
<td>no annotation</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
<tr>
<td><code>in</code></td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">No</td>
</tr>
<tr>
<td><code>out</code></td>
<td align="center">No</td>
<td align="center">Yes</td>
<td align="center">No</td>
<td align="center">Yes</td>
<td align="center">No</td>
</tr>
<tr>
<td><code>inout</code></td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
<td align="center">Yes</td>
</tr>
</tbody>
</table><p>However, it should be noted that the compiler might not 
detect whether the annotation is correct or not! This program might 
compile, but will behave strangely:</p><pre><code class="lang-c3">fn void bad_func(int* i)
{
    *i = <span class="number">2</span>;
}

&lt;*
 @param [&amp;in] i
*&gt;
fn void lying_func(int* i)
{
    bad_func(i); <span class="comment">// The compiler might not check this!</span>
}

fn void test()
{
    int a = <span class="number">1</span>;
    lying_func(&amp;a);
    io::printf(<span class="string">"%d"</span>, a); <span class="comment">// Might print <span class="number">1</span>!</span>
}</code></pre><p>However, compilers will usually detect this:</p><pre><code class="lang-c3">&lt;*
 @param [&amp;in] i
*&gt;
fn void bad_func(int* i)
{
    *i = <span class="number">2</span>; <span class="comment">// &lt;- Compiler error: cannot write to <span class="string">"in"</span> parameter</span>
}</code></pre><h3 id="post-conditions-parameter-annotations-pure-in-detail">Pure in detail</h3><p>The <code>pure</code> annotation allows a program to make assumptions in regard to how the function treats global variables. 
Unlike for <code>const</code>, a pure function is not allowed to call a function which is known to be impure.</p><p>However, just like for <code>const</code> the compiler might not detect whether the annotation 
is correct or not! This program might compile, but will behave strangely:</p><pre><code class="lang-c3">int i = <span class="number">0</span>;

def SecretFn = fn void();

fn void bad_func()
{
    i = <span class="number">2</span>;
}

&lt;*
 @pure
*&gt;
fn void lying_func(SecretFn f)
{
    f(); <span class="comment">// The compiler cannot reason about this!</span>
}

fn void main()
{
    i = <span class="number">1</span>;
    lying_func(&amp;bad_func);
    io::printf(<span class="string">"%d"</span>, i); <span class="comment">// Might print <span class="number">1</span>!</span>
}</code></pre><p>However, compilers will usually detect this:</p><pre><code class="lang-c3">int i = <span class="number">0</span>;

def SecretFn = fn void();

fn void bad_func()
{
    i = <span class="number">2</span>;
}

&lt;*
 @pure
*&gt;
fn void lying_func(SecretFn f)
{
    f(); <span class="comment">// &lt;- ERROR: Only <span class="string">'@pure'</span> functions may be called. </span>
}

fn void main()
{
    i = <span class="number">1</span>;
    lying_func(&amp;bad_func);
    io::printf(<span class="string">"%d"</span>, i); <span class="comment">// Might print <span class="number">1</span>!</span>
}</code></pre><p>Consequently, circumventing “pure” annotations is undefined behaviour.</p><h1 id="pre-conditions-for-macros">Pre conditions for macros</h1><p>In order to check macros, it’s often useful to use the builtin <code>$defined</code>
function which returns true if the code inside would pass semantic checking.</p><pre><code class="lang-c3">&lt;*
 @require $defined(resource.open, resource.open()), `Expected resource to have an <span class="string">"open"</span> function`
 @require resource != nil
 @require $assignable(resource.open(), void*)
*&gt;
macro open_resource(resource)
{
    return resource.open();
}</code></pre><hr><p>title: Attributes
description: Attributes
sidebar:</p><pre><code>order: 68</code></pre><hr><p>Attributes are 
compile-time annotations on functions, types, global constants and 
variables. Similar to Java annotations, a decoration may also take 
arguments. A attribute can also represent a bundle of attributes.</p><h2 id="pre-conditions-for-macros-built-in-attributes">Built in attributes</h2><h3 id="pre-conditions-for-macros-built-in-attributes-adhoc">@adhoc</h3><p><em>Used for: type parameterized generic modules</em></p><p>Normally a parameterized generic module needs to be defined before it is used like:</p><pre><code class="lang-c3">module my_lib(&lt;Type&gt;);

struct MyType
{
      Type value;
}

module my_code;

<span class="comment">// Definition here</span>
def MyType(&lt;int&gt;) = MyTypeInt; 

fn void main()
{
    MyType(&lt;int&gt;) x;
}</code></pre><p>A type with <code>@adhoc</code> can be declared parameterized, without any warning being issued, for example:</p><pre><code class="lang-c3">module my_lib(&lt;Type&gt;);

struct MyType @adhoc
{
      Type value;
}

module my_code;

fn void main()
{
    MyType(&lt;int&gt;) x;
}</code></pre><h3 id="pre-conditions-for-macros-built-in-attributes-alignalignment">@align(alignment)</h3><p><em>Used for: struct, bitstructs, union, var, function</em></p><p>This attribute sets the minimum alignment for a field or a variable, for example:</p><pre><code class="lang-c3">struct Foo @align(<span class="number">32</span>)
{
    int a;
    int b @align(<span class="number">16</span>);
}</code></pre><h3 id="pre-conditions-for-macros-built-in-attributes-benchmark">@benchmark</h3><p><em>Used for: function</em></p><p>Marks the function as a benchmark function. Will be added to the list of benchmark functions when the benchmarks are run,
otherwise the function will not be included in the compilation.</p><h3 id="pre-conditions-for-macros-built-in-attributes-bigendian">@bigendian</h3><p><em>Used for: bitstruct</em></p><p>Lays out the bits as if the data was stored in a big endian type, regardless of host system endianness.</p><h3 id="pre-conditions-for-macros-built-in-attributes-builtin">@builtin</h3><p><em>Used for: function, macro, global, const</em></p><p>Allows a macro, function, global or constant be used from another module without the module path prefixed.
Should be used sparingly.</p><h3 id="pre-conditions-for-macros-built-in-attributes-callc">@callc</h3><p><em>Used for: function</em></p><p>Sets the call convention, which may be ignored if the convention is not supported on the target.
Valid arguments are <code>veccall</code>, <code>ccall</code>, <code>stdcall</code>.</p><h3 id="pre-conditions-for-macros-built-in-attributes-deprecated">@deprecated</h3><p><em>Used for: types, function, macro, global, const, member</em></p><p>Marks the particular type, global, const or member as deprecated, making use trigger a warning.</p><h3 id="pre-conditions-for-macros-built-in-attributes-export">@export</h3><p><em>Used for: function, global, const, enum, union, struct, fault</em></p><p>Marks this declaration as an export, this ensures it is never removed and exposes it as public when linking.
The attribute takes an optional string value, which is the external name. This acts as if <code>@extern</code> had been
added with that name.</p><h3 id="pre-conditions-for-macros-built-in-attributes-extern">@extern</h3><p><em>Used for: function, global, const, enum, union, struct, fault</em></p><p>Sets the external (linkage) name of this declaration.</p><h3 id="pre-conditions-for-macros-built-in-attributes-finalizer">@finalizer</h3><p><em>Used for: function</em></p><p>Make this function run at shutdown. See <code>@init</code> for the optional priority. Note that running a
finalizer is a “best effort” attempt by the OS. During abnormal termination it is not guaranteed to run.</p><p>The function must be a void function taking no arguments.</p><h3 id="pre-conditions-for-macros-built-in-attributes-if">@if</h3><p><em>Used for: all declarations</em></p><p>Conditionally includes the declaration in the compilation. It takes a constant compile time value argument, if this
value is <code>true</code> then the declaration is retained, on false it is removed.</p><h3 id="pre-conditions-for-macros-built-in-attributes-init">@init</h3><p><em>Used for: function</em></p><p>Make this function run at startup before main. It has an optional priority 1 - 65535, with lower
being executed earlier. It is not recommended to use values less than 128 as they are generally
reserved and using them may interfere with standard program initialization.</p><p>The function must be a void function taking no arguments.</p><h3 id="pre-conditions-for-macros-built-in-attributes-inline">@inline</h3><p><em>Used for: function, call</em></p><p>Declares a function to always be inlined or if placed on a call, that the call should be inlined.</p><h3 id="pre-conditions-for-macros-built-in-attributes-littleendian">@littleendian</h3><p><em>Used for: bitstruct</em></p><p>Lays out the bits as if the data was stored in a little endian type, regardless of host system endianness.</p><h3 id="pre-conditions-for-macros-built-in-attributes-local">@local</h3><p><em>Used for: any declaration</em></p><p>Sets the visibility to “local”, which means it’s only visible in the current module section.</p><h3 id="pre-conditions-for-macros-built-in-attributes-maydiscard">@maydiscard</h3><p><em>Used for: function, macro</em></p><p>Allows the return value of the function or macro to be discarded even if it is an optional. Should be
used sparingly.</p><h3 id="pre-conditions-for-macros-built-in-attributes-naked">@naked</h3><p><em>Used for: function</em></p><p>This attribute disables prologue / epilogue emission for the function.</p><h3 id="pre-conditions-for-macros-built-in-attributes-nodiscard">@nodiscard</h3><p><em>Used for: function, macro</em></p><p>The return value may not be discarded.</p><h3 id="pre-conditions-for-macros-built-in-attributes-noinit">@noinit</h3><p><em>Used for: global, local variable</em></p><p>Prevents the compiler from zero initializing the variable.</p><h3 id="pre-conditions-for-macros-built-in-attributes-norecurse">@norecurse</h3><p><em>Used for: import <module_name> @norecurse</module_name></em></p><p>Import the module but not sub-modules or parent-modules, see <a href="https://waveproc.github.io/language-fundamentals/modules/#non-recursive-imports">Modules Section</a>.</p><h3 id="pre-conditions-for-macros-built-in-attributes-noreturn">@noreturn</h3><p><em>Used for: function</em></p><p>Declares that the function will never return.</p><h3 id="pre-conditions-for-macros-built-in-attributes-nostrip">@nostrip</h3><p><em>Used for: any declaration</em></p><p>This causes the declaration never to be stripped from the executable, even if it’s not used. This
also transitively applies to any dependencies the declaration might have.</p><h3 id="pre-conditions-for-macros-built-in-attributes-obfuscate">@obfuscate</h3><p><em>Used for: any declaration</em></p><p>Removes any string values that would identify the declaration in some way. Mostly this is used
on faults and enums to remove the stored names.</p><h3 id="pre-conditions-for-macros-built-in-attributes-operator">@operator</h3><p><em>Used for: method, macro method</em></p><p>This attribute has arguments <code>[]</code> <code>[]=</code> <code>&amp;[]</code> and <code>len</code> allowing <a href="https://waveproc.github.io/generic-programming/operator-overloading/">operator overloading</a> for <code>[]</code> and <code>foreach</code>.
By implementing <code>[]</code> and <code>len</code>, <code>foreach</code> and <code>foreach_r</code> is enabled. In order to do <code>foreach</code> by reference,
<code>&amp;[]</code> must be implemented as well.</p><h3 id="pre-conditions-for-macros-built-in-attributes-overlap">@overlap</h3><p><em>Used for: bitstruct</em></p><p>Allows bitstruct fields to have overlapping bit ranges.</p><h3 id="pre-conditions-for-macros-built-in-attributes-packed">@packed</h3><p><em>Used for: struct, union</em></p><p>Causes all members to be packed as if they had alignment 1. The alignment of the struct/union is set to 1.
This alignment can be overridden with <code>@align</code>.</p><h3 id="pre-conditions-for-macros-built-in-attributes-private">@private</h3><p><em>Used for: any declaration</em></p><p>Sets the visibility to “private”, which means it is visible in the same module, but not from other modules.</p><h3 id="pre-conditions-for-macros-built-in-attributes-pure">@pure</h3><p><em>Used for: call</em></p><p>Used to annotate a non pure function as “pure” when checking for conformance to <code>@pure</code> on 
functions.</p><h3 id="pre-conditions-for-macros-built-in-attributes-packed">@packed</h3><p><em>Used for: struct, union, enum</em></p><p>If
 used on a struct or enum: packs the type, including any components to 
minimum size. On an enum, it uses the smallest representation containing
 all its values.</p><h3 id="pre-conditions-for-macros-built-in-attributes-reflect">@reflect</h3><p><em>Used for: any declaration</em></p><p>Adds additional reflection information. Has no effect currently.</p><h3 id="pre-conditions-for-macros-built-in-attributes-sectionname">@section(name)</h3><p><em>Used for: function, const, global</em></p><p>Declares that a global variable or function should appear in a specific section.</p><h3 id="pre-conditions-for-macros-built-in-attributes-test">@test</h3><p><em>Used for: function</em></p><p>Marks the function as a test function. Will be added to the list of test functions when the tests are run,
otherwise the function will not be included in the compilation.</p><h3 id="pre-conditions-for-macros-built-in-attributes-unused">@unused</h3><p><em>Used for: any declaration</em></p><p>Marks the declaration as possibly unused (but should not emit a warning).</p><h3 id="pre-conditions-for-macros-built-in-attributes-used">@used</h3><p><em>Used for: any declaration</em></p><p>Marks a parameter, value etc. as must being used.</p><h3 id="pre-conditions-for-macros-built-in-attributes-weak">@weak</h3><p><em>Used for: function, const, global</em></p><p>Emits a weak symbol rather than a global.</p><h2 id="pre-conditions-for-macros-user-defined-attributes">User defined attributes</h2><p>User defined attributes are intended for conditional application of built-in attributes.</p><pre><code class="lang-c3">def @MyAttribute = { @noreturn @inline };

<span class="comment">// The following two are equivalent:</span>
fn void foo() @MyAttribute { ... }
fn void foo() @noreturn @inline { ... }</code></pre><p>A user defined attribute may also be completely empty:</p><pre><code>def @MyAttributeEmpty = {};</code></pre><hr><p>title: C Interoperability
description: C Interoperability
sidebar:</p><pre><code>order: 69</code></pre><hr><p>C3 is C ABI compatible. That means you can call C from C3, and call C3 from C without having to
do anything special. As a quick way to call C, you can simply declare the function as a 
C3 function but with <code>extern</code> in front of it. As long as the function is linked, it will work:</p><pre><code class="lang-c3">extern fn void puts(char*); <span class="comment">// C <span class="string">"puts"</span></span>

fn void main()
{
    <span class="comment">// This will call the <span class="string">"puts"</span></span>
    <span class="comment">// function in the standard c lib.</span>
    puts(<span class="string">"Hello, world!"</span>); 
}</code></pre><p>To use a different identifier inside of your C3 code 
compared to the function or variable’s external name, use the @extern 
attribute:</p><pre><code class="lang-c3">extern fn void foo_puts(char*) @extern(<span class="string">"puts"</span>); <span class="comment">// C <span class="string">"puts"</span></span>

fn void main()
{
    foo_puts(<span class="string">"Hello, world!"</span>); <span class="comment">// Still calls C <span class="string">"puts"</span></span>
}</code></pre><p>While C3 functions are available from C using their external name, it’s often useful to
define an external name using <code>@extern</code> or <code>@export</code> with a name to match C usage.</p><pre><code class="lang-c3">module foo;
fn int square(int x) @export <span class="comment">// @export ensures external visibility</span>
{
    return x * x;
}

fn int square<span class="number">2</span>(int x) @export(<span class="string">"square"</span>)
{
    return x * x;
}</code></pre><p>Calling from C:</p><pre><code class="lang-c3">extern int square(int);
int foo_square(int) __attribute__ ((weak, alias (<span class="string">"foo.square"</span>)));

void test()
{
    <span class="comment">// This would call square<span class="number">2</span></span>
    printf(<span class="string">"%d\n"</span>, square(<span class="number">11</span>));

    <span class="comment">// This would call square</span>
    printf(<span class="string">"%d\n"</span>, foo_square(<span class="number">11</span>));
}</code></pre><h2 id="pre-conditions-for-macros-linking-static-and-dynamic-libraries">Linking static and dynamic libraries</h2><p>If you have a library <code>foo.a</code> or <code>foo.so</code> or <code>foo.obj</code> (depending on type and OS), just add
<code>-l foo</code> on the command line, or in the project file add it to the <code>linked-libraries</code> value, e.g.
<code>"linked-libraries" = ["foo"]</code>.</p><p>To add library search paths, use <code>-L &lt;directory&gt;</code> from the command line and <code>linker-search-paths</code>
the project file (e.g. <code>"linker-search-paths" = ["../mylibs/", "/extra-libs/"]</code>)</p><h3 id="pre-conditions-for-macros-linking-static-and-dynamic-libraries-gotchas">Gotchas</h3><ul>
<li>Bitstructs will be seen as its backing type, when used from C. </li>
<li>C bit fields must be manually converted to a C3 bitstruct with the correct layout for each target platform.</li>
<li>C assumes the enum size is <code>CInt</code></li>
<li>C3 uses fixed integer sizes, this means that <code>int</code> and <code>CInt</code> does not <em>need</em> to be the same though in practice on 32/64 bit machines, <code>long</code> is usually the <em>only</em> type that differs in size between C and C3.</li>
<li>Atomic types are not supported by C3.<ul>
<li>In C3 there are generic Atomic types instead.</li>
</ul>
</li>
<li>There are no <code>volatile</code> and <code>const</code> <strong>qualifiers</strong> like in C. <ul>
<li>C3 has <a href="https://waveproc.github.io/language-fundamentals/naming/#global-constants">global constants</a> declared with <code>const</code>. </li>
<li>Instead of the <code>volatile</code> type qualifier, there are standard library macros <code>@volatile_load</code> and <code>@volatile_store</code>.</li>
</ul>
</li>
<li>Passing arrays by value like in C3 must be represented as passing a struct containing the array.</li>
<li>In C3, fixed arrays do <em>not</em> decay into pointers like in C. <ul>
<li>When defining a C function that has an array argument, replace the array type with a pointer. E.g. <code>void test(int[] a)</code> should become
<code>extern fn void test(int* a)</code>. If the function has a sized array, like <code>void test2(int[4] b)</code>
replace it with a pointer to a sized array: <code>extern fn void test2(int[4]* b);</code>      </li>
<li>Note that a pointer to an array is always implicitly convertable to a pointer to the first element For example, <code>int[4]*</code> may be implicitly converted to <code>int*</code>.</li>
</ul>
</li>
<li>The C3 names of functions are name-spaced with the module by default when using <code>@export</code>, so when
exporting a function with <code>@export</code> that is to be used from C, specify an explicit external name. E.g. <code>fn void myfunc() @export("myfunc") { ... }</code>.</li>
</ul><hr><p>title: Interfaces and Any Type
description: Interfaces and Any Type
sidebar:</p><pre><code>order: 80</code></pre><hr><h2 id="pre-conditions-for-macros-working-with-the-type-of-any-at-runtime">Working with the type of <code>any</code> at runtime.</h2><p>The <code>any</code> type is recommended for writing code that is polymorphic at runtime where macros are not appropriate.
It can be thought of as a typed <code>void*</code>.</p><p>An <code>any</code> can be created by assigning any pointer to it. You can then query the <code>any</code> type for the typeid of 
the enclosed type (the type the pointer points to) using the <code>type</code> field.</p><p>This allows switching over the typeid, either using a normal switch:</p><pre><code class="lang-c3">switch (my_any.type)
{
    case Foo.typeid:
        ...
    case Bar.typeid:
        ...
}</code></pre><p>Or the special <code>any</code>-version of the switch:</p><pre><code class="lang-c3">switch (my_any)
{
    case Foo:
        <span class="comment">// my_any can be used as if it was Foo* here</span>
    case Bar:
        <span class="comment">// my_any can be used as if it was Bar* here</span>
}</code></pre><p>Sometimes one needs to manually construct an any-pointer, which
is typically done using the <code>any_make</code> function: <code>any_make(ptr, type)</code>
will create an <code>any</code> pointing to <code>ptr</code> and with typeid <code>type</code>.</p><p>Since the runtime <code>typeid</code> is available, we can query for any runtime <code>typeid</code> property available
at runtime, for example the size, e.g. <code>my_any.type.sizeof</code>. This allows us to do a lot of work
on with the enclosed data without knowing the details of its type.</p><p>For example, this would make a copy of the data and place it in the variable <code>any_copy</code>:</p><pre><code class="lang-c3">void* data = malloc(a.type.sizeof);
mem::copy(data, a.ptr, a.type.sizeof);
any any_copy = any_make(data, a.type);</code></pre><h2 id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any">Variable argument functions with implicit <code>any</code></h2><p>Regular typed varargs are of a single type, e.g. <code>fn void abc(int x, double... args)</code>.
In order to take variable functions that are of multiple types, <code>any</code> may be used.
There are two variants:</p><h3 id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any-explicit-any-vararg-functions">Explicit <code>any</code> vararg functions</h3><p>This type of function has a format like <code>fn void vaargfn(int x, any... args)</code>. Because only
pointers may be passed to an <code>any</code>, the arguments must explicitly be pointers (e.g. <code>vaargfn(2, &amp;b, &amp;&amp;3.0)</code>).</p><p>While explicit, this may be somewhat less user-friendly than implicit vararg functions:</p><h3 id="pre-conditions-for-macros-variable-argument-functions-with-implicit-any-implicit-any-vararg-functions">Implicit <code>any</code> vararg functions</h3><p>The implicit <code>any</code> vararg function has instead a format like <code>fn void vaanyfn(int x, args...)</code>.
Calling this function will implicitly cause taking the pointer of the values (so for
example in the call <code>vaanyfn(2, b, 3.0)</code>, what is actually passed are <code>&amp;b</code> and <code>&amp;&amp;3.0</code>).</p><p>Because this passes values implicitly by reference, care must be taken <em>not</em> to mutate any
values passed in this manner. Doing so would very likely break user expectations.</p><h2 id="pre-conditions-for-macros-interfaces">Interfaces</h2><p>Most statically typed object-oriented languages implements extensibility using vtables. In C, and by extension
C3, this is possible to emulate by passing around structs containing list of function pointers in addition to the data.</p><p>While this is efficient and often the best solution, but it puts certain assumptions on the code and makes interfaces
more challenging to evolve over time.</p><p>As an alternative there are languages (such as Objective-C) which instead use message passing to dynamically typed
objects, where the availability of a certain functionality may be queried at runtime.</p><p>C3 provides this latter functionality over the <code>any</code> type using <em>interfaces</em>.</p><h3 id="pre-conditions-for-macros-interfaces-defining-an-interface">Defining an interface</h3><p>The first step is to define an interface:</p><pre><code class="lang-c3">interface MyName
{
    fn String myname();
}</code></pre><p>While <code>myname</code> will behave as a method, we declare it without type. Note here that unlike normal methods we leave
out the first “self”, argument.</p><h3 id="pre-conditions-for-macros-interfaces-implementing-the-interface">Implementing the interface</h3><p>To declare that a type implements an interface, add it after the type name:</p><pre><code class="lang-c3">struct Baz (MyName) 
{ 
    int x; 
}

<span class="comment">// Note how the first argument differs from the interface.</span>
fn String Baz.myname(Baz* self) @dynamic 
{ 
    return <span class="string">"I am Baz!"</span>; 
}</code></pre><p>If a type declares an interface but does not implement its methods, then that is compile time error.
A type may implement multiple interfaces, by placing them all inside of <code>()</code> e.g. <code>struct Foo (VeryOptional, MyName) { ... }</code></p><p>A limitation is that only user-defined types may declare they are implementing interfaces. To make existing types
implement interfaces is possible but does not provide compile time checks.</p><p>One of the interfaces available in the standard library is Printable, which contains <code>to_format</code> and <code>to_new_string</code>.
If we implemented it for our struct above it might look like this:</p><pre><code class="lang-c3">fn String Baz.to_new_string(Baz baz, Allocator allocator) @dynamic
{
    return string::printf(<span class="string">"Baz(%d)"</span>, baz.x, allocator: allocator);
}</code></pre><h3 id="pre-conditions-for-macros-interfaces-dynamic-methods">“@dynamic” methods</h3><p>A method must be declared <code>@dynamic</code> to implement an interface, but a method may also be declared <code>@dynamic</code> <em>without</em>
the type declaring it implements a particular interface. For example, this allows us to write:</p><pre><code class="lang-c3"><span class="comment">// This will make <span class="string">"int"</span> satisfy the MyName interface</span>
fn String int.myname(int*) @dynamic
{ 
    return <span class="string">"I am int!"</span>; 
}</code></pre><p><code>@dynamic</code> methods have their reference retained in the runtime code and can also be searched for at runtime and invoked
from the <code>any</code> type.</p><h3 id="pre-conditions-for-macros-interfaces-referring-to-an-interface-by-pointer">Referring to an interface by pointer</h3><p>An interface e.g. <code>MyName</code>, can be cast back and forth to <code>any</code>, but only types which 
implement the interface completely may implicitly be cast to the interface.</p><p>So for example:</p><pre><code class="lang-c3">Bob b = { <span class="number">1</span> };
double d = <span class="number"><span class="number">0</span>.<span class="number">5</span></span>;
int i = <span class="number">3</span>;
MyName a = &amp;b;          <span class="comment">// Valid, Bob implements MyName.</span>
<span class="comment">// MyName c = &amp;d;       // Error, double does not implement MyName.</span>
MyName c = (MyName)&amp;d;  <span class="comment">// Would break at runtime as double doesn<span class="string">'t implement MyName</span>
<span class="comment">// MyName z = &amp;i;       // Error, implicit conversion because int doesn'</span>t explicitly implement it.</span>
MyName* z = (MyName)&amp;i; <span class="comment">// Explicit conversion works and is safe at runtime if int implements <span class="string">"myname"</span></span></code></pre><h3 id="pre-conditions-for-macros-interfaces-calling-dynamic-methods">Calling dynamic methods</h3><p>Methods implementing interfaces are like normal methods, and if called directly, they are just normal function calls. The
difference is that they may be invoked through the interface:</p><pre><code class="lang-c3">fn void whoareyou(MyName a)
{
    io::printn(a.myname());
}</code></pre><p>If we have an optional method we should first check that it is implemented:</p><pre><code class="lang-c3">fn void do_something(VeryOptional z)
{
    if (&amp;z.do_something)
    {
        z.do_something(<span class="number">1</span>, null);
    }
}</code></pre><p>We first query if the method exists on the value. If it does we actually run it.</p><p>Here is another example, showing how the correct function will be called depending on type, checking
for methods on an <code>any</code>:</p><pre><code class="lang-c3">fn void whoareyou<span class="number">2</span>(any a)
{
    <span class="comment">// Query if the function exists</span>
    if (!&amp;a.myname)
    {
        io::printn(<span class="string">"I don<span class="string">'t know who I am."</span>);
        return;
    }
    <span class="comment">// Dynamically call the function</span>
    io::printn(((MyName)a).myname());
}

fn void main()
{
    int i;
    double d;
    Bob bob;

    any a = &amp;i; 
    whoareyou<span class="number">2</span>(a); <span class="comment">// Prints <span class="string">"I am int!"</span></span>
    a = &amp;d;
    whoareyou<span class="number">2</span>(a); <span class="comment">// Prints <span class="string">"I don'</span>t know who I am."</span></span>
    a = &amp;bob;
    whoareyou<span class="number">2</span>(a); <span class="comment">// Prints <span class="string">"I am Bob!"</span></span>
}</code></pre><h3 id="pre-conditions-for-macros-interfaces-reflection-invocation">Reflection invocation</h3><p><em>This functionality is not yet implemented and may see syntax changes</em></p><p>It is possible to retrieve any <code>@dynamic</code> function by name and invoke it:</p><pre><code class="lang-c3">def VoidMethodFn = fn void(void*);

fn void* int.test_something(&amp;self) @dynamic
{
    io::printfn(<span class="string">"Testing: %d"</span>, *self);
}

fn void main()
{
    int z = <span class="number">321</span>;
    any a = &amp;z;
    VoidMethodFn test_func = a.reflect(<span class="string">"test_something"</span>);
    test_func(a); <span class="comment">// Will print <span class="string">"Testing: <span class="number">321</span>"</span></span>
}</code></pre><p>This feature allows methods to be linked up at runtime.</p><hr><p>title: Operator Overloading
description: Operator Overloading
sidebar:</p><pre><code>order: 81</code></pre><hr><p>C3 allows some <em>limited</em> operator overloading for working with containers. </p><h2 id="pre-conditions-for-macros-element-at-operator">“Element at” operator []</h2><p>Implementing <code>[]</code> allows a type to use the <code>my_type[&lt;value&gt;]</code> syntax:</p><pre><code class="lang-c3">struct Foo
{
    double[] x;
}

fn double Foo.get(&amp;self, usz i) @operator([])
{
    return self.x[i];
}</code></pre><p>It’s possible to use any type as argument, such as a string:</p><pre><code class="lang-c3">fn double Bar.get(&amp;self, String str) @operator([])
{
    return self.get_val_by_key(str);
}</code></pre><p>Only a single [] overload is allowed.</p><h2 id="pre-conditions-for-macros-element-ref-operator">“Element ref” operator &amp;[]</h2><p>Similar to [], the operator returns a value for <code>&amp;my_type[&lt;value&gt;]</code>, which may
be retrieved in a different way. If this overload isn’t defined, then <code>&amp;my_type[&lt;value&gt;]</code> would
be a syntax error.</p><pre><code class="lang-c3">fn double* Foo.get_ref(&amp;self, usz i) @operator(&amp;[])
{
    return &amp;self.x[i];
}</code></pre><h2 id="pre-conditions-for-macros-element-set-operator">“Element set” operator []=</h2><p>The counterpart of [] allows setting an element using <code>my_type[&lt;index&gt;] = &lt;value&gt;</code>.</p><pre><code class="lang-c3">fn void Foo.set(&amp;self, usz i, double new_val) @operator([]=)
{
    return self.x[i] = new_val;
}</code></pre><h2 id="pre-conditions-for-macros-len-operator">“len” operator</h2><p>Unlike the previous operator overloads, the “len” operator simply enables functionality
which augments the <code>[]</code>-family of operators: you can use the “from end” syntax e.g <code>my_type[^1]</code> 
to get the last element assuming the indexing uses integers.</p><h2 id="pre-conditions-for-macros-enabling-foreach">Enabling ‘foreach’</h2><p>In order to use a type with foreach, e.g. <code>foreach(d : foo)</code>, at a minimum methods 
with overloads for <code>[]</code> (<code>@operator([])</code>) and <code>len</code> (<code>@operator(len)</code>) need to be added. 
If <code>&amp;[]</code> is implemented, foreach by reference is enabled (e.g. <code>foreach(double* &amp;d : foo)</code>)</p><pre><code class="lang-c3">fn double Foo.get(&amp;self, usz i) @operator([])
{
    return self.x[i];
}

fn usz Foo.len(&amp;self) @operator(len)
{
    return self.x.len;
}

fn void test(Foo f)
{
    <span class="comment">// Print all elements in f</span>
    foreach (d : f)
    {
        io::printfn(<span class="string">"%f"</span>, d);
    }
}</code></pre><p>:::note</p><p>Operator overloading is limited, by 
design, as these features delivered the most value while still keeping 
the language as simple as possible.</p><p>:::</p><hr><p>title: Generics
description: Generics
sidebar:</p><pre><code>order: 82</code></pre><hr><p>Generic modules are parameterized modules that allow functionality for arbitrary types.</p><p>For generic modules, the generic parameters follows the module name:</p><pre><code class="lang-c3"><span class="comment">// TypeA, TypeB, TypeC are generic parameters.</span>
module vector(&lt;TypeA, TypeB, TypeC&gt;);</code></pre><p>It is also possible to parameterize by an <code>int</code> or <code>bool</code> constant, for example:</p><pre><code class="lang-c3"><span class="comment">// module custom_type&lt;Type, VALUE&gt;  </span>
module custom_type&lt;float, <span class="number">3</span>&gt;;</code></pre><p>Code inside a generic module may use the generic parameters as if they were well-defined symbols:</p><pre><code class="lang-c3">module foo_test(&lt;Type<span class="number">1</span>, Type<span class="number">2</span>&gt;);

struct Foo 
{
   Type<span class="number">1</span> a;
}

fn Type<span class="number">2</span> test(Type<span class="number">2</span> b, Foo *foo) 
{
   return foo.a + b;
}</code></pre><p>Including a generic module works as usual:</p><pre><code class="lang-c3">import foo_test;

def FooFloat = Foo(&lt;float, double&gt;);
def test_float = foo_test::test(&lt;float, double&gt;);

...

FooFloat f;
Foo(&lt;int, double&gt;) g;

...

test_float(<span class="number"><span class="number">1</span>.<span class="number">0</span></span>, &amp;f);
foo_test::test(&lt;int, double&gt;)(<span class="number"><span class="number">1</span>.<span class="number">0</span></span>, &amp;g);</code></pre><p>Just like for macros, optional constraints may be added to improve compile errors:</p><pre><code class="lang-c3">&lt;*
 @require $assignable(<span class="number">1</span>, TypeB) &amp;&amp; $assignable(<span class="number">1</span>, TypeC)
 @require $assignable((TypeB)<span class="number">1</span>, TypeA) &amp;&amp; $assignable((TypeC)<span class="number">1</span>, TypeA)
*&gt; 
module vector(&lt;TypeA, TypeB, TypeC&gt;);

/* .. code * ../</code></pre><pre><code class="lang-c3">def testFunction = vector::testFunc(&lt;Bar, float, int&gt;);

<span class="comment">// This would give the error </span>
<span class="comment">// --&gt; Parameter(s) failed validation: </span>
<span class="comment">//     @require <span class="string">"$assignable((TypeB)<span class="number">1</span>, TypeA) &amp;&amp; $assignable((TypeC)<span class="number">1</span>, TypeA)"</span> violated.</span></code></pre><hr><p>title: Macros
description: Macros
sidebar:</p><pre><code>order: 83</code></pre><hr><p>The macro capabilities of C3 reaches across several constructs: 
macros, <a href="https://waveproc.github.io/generic-programming/generics/">generic functions, generic modules</a>, and <a href="https://waveproc.github.io/generic-programming/compiletime/#compile-time-values">compile time variables</a> (prefixed with <code>$</code>), macro compile time execution (using <code>$if</code>, <code>$for</code>, <code>$foreach</code>, <code>$switch</code>) and attributes.</p><h2 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros">A quick comparison of C and C3 macros</h2><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-conditional-compilation">Conditional compilation</h3><pre><code class="lang-c"><span class="comment">// C Macro</span>
<span class="comment">#if defined(x) &amp;&amp; Y &gt; <span class="number">3</span></span>
int z;
<span class="comment">#endif</span></code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
$if $defined(x) &amp;&amp; Y &gt; <span class="number">3</span>:
    int z;
$endif

<span class="comment">// or</span>
int z @if($defined(x) &amp;&amp; Y &gt; <span class="number">3</span>);</code></pre><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-macros">Macros</h3><pre><code class="lang-c"><span class="comment">// C Macro</span>
<span class="comment">#define M(x) ((x) + <span class="number">2</span>)</span>
<span class="comment">#define UInt<span class="number">32</span> unsigned int</span>

<span class="comment">// Use:</span>
int y = M(foo() + <span class="number">2</span>);
UInt<span class="number">32</span> b = y;</code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
macro m(x)
{
    return x + <span class="number">2</span>;
}
def UInt<span class="number">32</span> = uint;

<span class="comment">// Use:</span>
int y = m(foo() + <span class="number">2</span>);
UInt<span class="number">32</span> b = y;</code></pre><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-dynamic-scoping">Dynamic scoping</h3><pre><code class="lang-c"><span class="comment">// C Macro</span>
<span class="comment">#define Z() ptr-&gt;x-&gt;y-&gt;z</span>
int x = Z();</code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
... currently no corresponding functionality ...</code></pre><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-expression-arguments">Expression arguments</h3><pre><code class="lang-c"><span class="comment">// C Macro</span>
<span class="comment">#define M(x, y) x = <span class="number">2</span> * (y);</span>
...
M(x, <span class="number">3</span>);</code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
macro @m(<span class="comment">#x, y)</span>
{
    <span class="comment">#x = <span class="number">2</span> * y;</span>
}
...
@m(x, <span class="number">3</span>);</code></pre><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-first-class-types">First class types</h3><pre><code class="lang-c"><span class="comment">// C Macro</span>
<span class="comment">#define SIZE(T) (sizeof(T) + sizeof(int))</span></code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
macro size($Type)
{
    return $Type.sizeof + int.sizeof;
}</code></pre><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-trailing-blocks-for-macros">Trailing blocks for macros</h3><pre><code>// C Macro
#define FOR_EACH(x, list) \
for (x = (list); x; x = x-&gt;next)

// Use:
Foo *it;
FOR_EACH(it, list) 
{
    if (!process(it)) return;
}</code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
macro @for_each(list; @body(it))
{
    for ($typeof(list) x = list; x; x = x.next)
    {
        @body(x);
    }    
}

<span class="comment">// Use:</span>
@for_each(list; Foo* x)
{
    if (!process(x)) return;
}</code></pre><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-first-class-names">First class names</h3><pre><code class="lang-c"><span class="comment">// C Macro</span>
<span class="comment">#define offsetof(T, field) (size_t)(&amp;((T*)<span class="number">0</span>)-&gt;field)</span></code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
macro usz @offset($Type, <span class="comment">#field)</span>
{
    $Type* t = null;
    return (usz)(uptr)&amp;t.<span class="comment">#field;</span>
}</code></pre><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-declaration-attributes">Declaration attributes</h3><pre><code class="lang-c"><span class="comment">// C Macro</span>
<span class="comment">#define PURE_INLINE __attribute__((pure)) __attribute__((always_inline))</span>
int foo(int x) PURE_INLINE { ... }</code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
def @NoDiscardInline = { @nodiscard @inline };
fn int foo(int) @NoDiscardInline { ... }</code></pre><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-declaration-macros">Declaration macros</h3><pre><code class="lang-c"><span class="comment">// C Macro</span>
<span class="comment">#define DECLARE_LIST(name) List name = { .head = NULL };</span>
<span class="comment">// Use:</span>
DECLARE_LIST(hello)</code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
... currently no corresponding functionality ...</code></pre><h3 id="pre-conditions-for-macros-a-quick-comparison-of-c-and-c3-macros-stringification">Stringification</h3><pre><code class="lang-c"><span class="comment">// C Macro</span>
<span class="comment">#define CHECK(x) do { if (!x) abort(#x); } while(<span class="number">0</span>)</span></code></pre><pre><code class="lang-c3"><span class="comment">// C<span class="number">3</span> Macro</span>
macro @check(<span class="comment">#expr)</span>
{
    if (!<span class="comment">#expr) abort($stringify(#expr));</span>
}</code></pre><h2 id="pre-conditions-for-macros-top-level-evaluation">Top level evaluation</h2><p>Script languages, and also upcoming languages like <em>Jai</em>, 
usually have unbounded top level evaluation. 
The flexibility of this style of meta programming has a trade-off in making the code more challenging to understand. </p><p>In C3, top level compile time evaluation is limited to <code>@if</code> attributes to conditionally enable or 
disable declarations. This makes the code easier to read, but at the cost of expressive power.</p><h2 id="pre-conditions-for-macros-macro-declarations">Macro declarations</h2><p>A macro is defined using <code>macro &lt;name&gt;(&lt;parameters&gt;)</code>. All user defined macros use the @ symbol if they use the <code>&amp;</code> or <code>#</code> parameters.</p><p>The parameters have different sigils:
<code>$</code> means compile time evaluated (constant expression or type). <code>#</code> indicates an expression that is not yet evaluated, 
but is bound to where it was defined. <code>@</code> is required on macros that use <code>#</code> parameters or trailing macro bodies.</p><p>A basic swap:</p><pre><code class="lang-c3">&lt;*
 @checked $defined(<span class="comment">#a = #b, #b = #a)</span>
*&gt;
macro void @swap(<span class="comment">#a, #b)</span>
{
    var temp = <span class="comment">#a;</span>
    <span class="comment">#a = #b;</span>
    <span class="comment">#b = temp;</span>
}</code></pre><p>This expands on usage like this:</p><pre><code class="lang-c3">fn void test()
{
    int a = <span class="number">10</span>;
    int b = <span class="number">20</span>;
    @swap(a, b);
}
<span class="comment">// Equivalent to:</span>
fn void test()
{
    int a = <span class="number">10</span>;
    int b = <span class="number">20</span>;
    {
        int __temp = a;
        a = b;
        b = __temp;
    }
}</code></pre><p>Note the necessary <code>#</code>. Here is an incorrect swap and what it would expand to:</p><pre><code class="lang-c3">macro void badswap(a, b)
{
    var temp = a;
    a = b;
    b = temp;
}

fn void test()
{
    int a = <span class="number">10</span>;
    int b = <span class="number">20</span>;
    badswap(a, b);
}
<span class="comment">// Equivalent to:</span>
fn void test()
{
    int a = <span class="number">10</span>;
    int b = <span class="number">20</span>;
    {
        int __a = a;
        int __b = b;
        int __temp = __a;
        __a = __b;
        __b = __temp;
    }
}</code></pre><h2 id="pre-conditions-for-macros-macro-methods">Macro methods</h2><p>Similar to regular <em>methods</em> a macro may also be associated with a particular type:</p><pre><code class="lang-c3">struct Foo { ... }

macro Foo.generate(&amp;self) { ... }
Foo f;
f.generate();</code></pre><p>See the chapter on <a href="https://waveproc.github.io/language-fundamentals/functions/">functions</a> for more details.</p><h2 id="pre-conditions-for-macros-capturing-a-trailing-block">Capturing a trailing block</h2><p>It
 is often useful for a macro to take a trailing compound statement as an
 argument. In C++ this pattern is usually expressed with a lambda, but 
in C3 this is completely inlined.</p><p>To accept a trailing block, <code>; @name(param1, ...)</code> is placed after declaring the regular macro parameters.</p><p>Here’s an example to illustrate its use:</p><pre><code class="lang-c3">&lt;*
 A macro looping through a list of values, executing the body once
 every pass.

 @require $defined(a.len) &amp;&amp; $defined(a[<span class="number">0</span>])
*&gt;
macro @foreach(a; @body(index, value))
{
    for (int i = <span class="number">0</span>; i &lt; a.len; i++)
    {
        @body(i, a[i]);
    }
}

fn void test()
{
    double[] a = { <span class="number"><span class="number">1</span>.<span class="number">0</span></span>, <span class="number"><span class="number">2</span>.<span class="number">0</span></span>, <span class="number"><span class="number">3</span>.<span class="number">0</span></span> };
    @foreach(a; int index, double value)
    {
        io::printfn(<span class="string">"a[%d] = %f"</span>, index, value);
    };
}

<span class="comment">// Expands to code similar to:</span>
fn void test()
{
    int[] a = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };
    {
        int[] __a = a;
        for (int __i = <span class="number">0</span>; i &lt; __a.len; i++)
        {
            io::printfn(<span class="string">"Value: %d, x<span class="number">2</span>: %d"</span>, __value<span class="number">1</span>, __value<span class="number">2</span>);
        }
    }
}</code></pre><h2 id="pre-conditions-for-macros-macros-returning-values">Macros returning values</h2><p>A macro may return a value, it is then considered an expression rather than a statement:</p><pre><code class="lang-c3">macro square(x)
{
    return x * x;
}

fn int getTheSquare(int x)
{
    return square(x);
}

fn double getTheSquare<span class="number">2</span>(double x)
{
    return square(x);
}</code></pre><h2 id="pre-conditions-for-macros-calling-macros">Calling macros</h2><p>It’s perfectly fine for a macro to invoke another macro or itself.</p><pre><code class="lang-c3">macro square(x) { return x * x; }

macro squarePlusOne(x)
{
    return square(x) + <span class="number">1</span>; <span class="comment">// Expands to <span class="string">"return x * x + <span class="number">1</span>;"</span></span>
}</code></pre><p>The maximum recursion depth is limited to the <code>macro-recursion-depth</code> build setting.</p><h2 id="pre-conditions-for-macros-macro-vaargs">Macro vaargs</h2><p>Macros support the typed vaargs used by C3 functions: <code>macro void foo(int... args)</code> and <code>macro void bar(args...)</code> 
but it also supports a unique set of macro vaargs that look like C style vaargs: <code>macro void baz(...)</code></p><p>To access the arguments there is a family of $va-* built-in functions to retrieve
the arguments:</p><pre><code class="lang-c3">macro compile_time_sum(...)
{
    var $x = <span class="number">0</span>;
    $for (var $i = <span class="number">0</span>; $i &lt; $vacount; $i++)
        $x += $vaconst[$i];
    $endfor
    return $x;
}
$if compile_time_sum(<span class="number">1</span>, <span class="number">3</span>) &gt; <span class="number">2</span>: <span class="comment">// Will compile to $if <span class="number">4</span> &gt; <span class="number">2</span></span>
    ...
$endif</code></pre><h3 id="pre-conditions-for-macros-macro-vaargs-vacount">$vacount</h3><p>Returns the number of arguments.</p><h3 id="pre-conditions-for-macros-macro-vaargs-vaarg">$vaarg</h3><p>Returns the argument as a regular parameter. The argument is
guaranteed to be evaluated once, even if the argument is used multiple times.</p><h3 id="pre-conditions-for-macros-macro-vaargs-vaconst">$vaconst</h3><p>Returns the argument as a compile time constant, this is suitable for
placing in a compile time variable or use for compile time evaluation,
e.g. <code>$foo = $vaconst(1)</code>. This corresponds to <code>$</code> parameters.</p><h3 id="pre-conditions-for-macros-macro-vaargs-vaexpr">$vaexpr</h3><p>Returns the argument as an unevaluated expression. Multiple uses will
evaluate the expression multiple times, this corresponds to <code>#</code> parameters.</p><h3 id="pre-conditions-for-macros-macro-vaargs-vatype">$vatype</h3><p>Returns the argument as a type. This corresponds to <code>$Type</code> style parameters, 
e.g. <code>$vatype(2) a = 2</code></p><h3 id="pre-conditions-for-macros-macro-vaargs-vasplat">$vasplat</h3><p><code>$vasplat</code> allows you to paste the varargs in the call into another call. For example,
if the macro was called with values <code>"foo"</code> and <code>1</code>, the code <code>foo($vasplat())</code>, would become <code>foo("foo", 1)</code>.
You can even extract provide a range as the argument: <code>$vasplat(2..4)</code> (in this case, this would past in 
arguments 2, 3 and 4).</p><p>Nor is it limited to function arguments, you can also use it with initializers:</p><pre><code class="lang-c3">int[*] a = { <span class="number">5</span>, $vasplat[<span class="number">2</span>..], <span class="number">77</span> };</code></pre><h2 id="pre-conditions-for-macros-untyped-lists">Untyped lists</h2><p>Compile time variables may hold untyped lists. Such lists may be iterated over or 
implicitly converted to initializer lists:</p><pre><code class="lang-c3">var $a = { <span class="number">1</span>, <span class="number">2</span> };
$foreach ($x : $a)
    io::printfn(<span class="string">"%d"</span>, $x);
$endforeach
int[<span class="number">2</span>] x = $a;
io::printfn(<span class="string">"%s"</span>, x);
io::printfn(<span class="string">"%s"</span>, $a[<span class="number">1</span>]);
<span class="comment">// Will print</span>
<span class="comment">// <span class="number">1</span></span>
<span class="comment">// <span class="number">2</span></span>
<span class="comment">// [<span class="number">1</span>, <span class="number">2</span>]</span>
<span class="comment">// <span class="number">2</span></span></code></pre><hr><p>title: Compile Time Evaluation
description: Compile time introspection and execution
sidebar:</p><pre><code>order: 84</code></pre><hr><p>During compilation, constant expressions will automatically be folded. Together with the compile
time conditional statements <code>$if</code>, <code>$switch</code> and the compile time iteration statements <code>$for</code> <code>$foreach</code>
it is possible to perform limited compile time execution.</p><h3 id="pre-conditions-for-macros-untyped-lists-compile-time-values">Compile time values</h3><p>During compilation, global constants are considered compile time values, as are any 
derived constant values, such as type names and sizes, variable alignments etc.</p><p>Inside of a macro or a function, it is possible to define mutable compile time variables. Such
local variables are prefixed with <code>$</code> (e.g. <code>$foo</code>). It is also possible to define local <em>type</em> variables,
that are also prefixed using <code>$</code> (e.g. <code>$MyType</code> <code>$ParamType</code>).</p><p>Mutable compile time variables are <em>not</em> allowed in the global scope.</p><h3 id="pre-conditions-for-macros-untyped-lists-if-and-switch">$if and $switch</h3><p><code>$if &lt;const expr&gt;:</code> takes a compile time constant value and evaluates it to true or false.</p><pre><code class="lang-c3">macro @foo($x, <span class="comment">#y)</span>
{
    $if $x &gt; <span class="number">3</span>:
        <span class="comment">#y += $x * $x;</span>
    $else
        <span class="comment">#y += $x;</span>
    $endif
}

const int FOO = <span class="number">10</span>;

fn void test()
{
    int a = <span class="number">5</span>;
    int b = <span class="number">4</span>;
    @foo(<span class="number">1</span>, a); <span class="comment">// Allowed, expands to a += <span class="number">1</span>;</span>
    <span class="comment">// @foo(b, a); // Error: b is not a compile time constant.</span>
    @foo(FOO, a); <span class="comment">// Allowed, expands to a += FOO * FOO;</span>
}</code></pre><p>For switching between multiple possibilities, use <code>$switch</code>.</p><pre><code class="lang-c3">macro @foo($x, <span class="comment">#y)</span>
{
    $switch ($x)
        $case <span class="number">1</span>: 
            <span class="comment">#y += $x * $x;</span>
        $case <span class="number">2</span>:
            <span class="comment">#y += $x;</span>
        $case <span class="number">3</span>:
            <span class="comment">#y *= $x;</span>
        $default:
            <span class="comment">#y -= $x;</span>
    $endswitch
}</code></pre><p>Switching without argument is also allowed, which works like an if-else chain:</p><pre><code class="lang-c3">macro @foo($x, <span class="comment">#y)</span>
{
    $switch 
        $case $x &gt; <span class="number">10</span>: 
            <span class="comment">#y += $x * $x;</span>
        $case $x &lt; <span class="number">0</span>:
            <span class="comment">#y += $x;</span>
        $default:
            <span class="comment">#y -= $x;</span>
    $endswitch
}</code></pre><h3 id="pre-conditions-for-macros-untyped-lists-loops-using-foreach-and-for">Loops using $foreach and $for</h3><p><code>$for</code> … <code>$endfor</code> works analogous to <code>for</code>, only it is limited to using compile time variables. <code>$foreach</code> … <code>$endforeach</code> similarly 
matches the behaviour of <code>foreach</code>.</p><p>Compile time looping:</p><pre><code class="lang-c3">macro foo($a)
{
    $for (var $x = <span class="number">0</span>; $x &lt; $a; $x++)
        io::printfn(<span class="string">"%d"</span>, $x);     
    $endfor
}

fn void test()
{
    foo(<span class="number">2</span>);
    <span class="comment">// Expands to -&gt;</span>
    <span class="comment">// io::printfn(<span class="string">"%d"</span>, <span class="number">0</span>);     </span>
    <span class="comment">// io::printfn(<span class="string">"%d"</span>, <span class="number">1</span>);         </span>
}</code></pre><p>Looping over enums:</p><pre><code class="lang-c3">macro foo_enum($SomeEnum)
{
    $foreach ($x : $SomeEnum.values)
        io::printfn(<span class="string">"%d"</span>, (int)$x);     
    $endforeach
}

enum MyEnum
{
    A,
    B,
}

fn void test()
{
    foo_enum(MyEnum);
    <span class="comment">// Expands to -&gt;</span>
    <span class="comment">// io::printfn(<span class="string">"%d"</span>, (int)MyEnum.A);</span>
    <span class="comment">// io::printfn(<span class="string">"%d"</span>, (int)MyEnum.B);    </span>
}</code></pre><p>An important thing to note is that the content of the <code>$foreach</code> or <code>$for</code> body must be at least a complete statement.
It’s not possible to compile partial statements.</p><h3 id="pre-conditions-for-macros-untyped-lists-compile-time-macro-execution">Compile time macro execution</h3><p>If a macro only takes compile time parameters, that is only <code>$</code>-prefixed parameters, and then does not generate 
any other statements than returns, then the macro will be completely compile time executed.</p><pre><code class="lang-c3">macro @test($abc)
{
    return $abc * <span class="number">2</span>;
}

const int MY_CONST = @test(<span class="number">2</span>); <span class="comment">// Will fold to <span class="string">"<span class="number">4</span>"</span></span></code></pre><p>This constant evaluation allows us to write some limited compile time code. For example, this
macro will compute Fibonacci at compile time:</p><pre><code class="lang-c3">macro long @fib(long $n)
{
    $if $n &lt;= <span class="number">1</span>:
        return $n;
    $else
        return @fib($n - <span class="number">1</span>) + @fib($n - <span class="number">2</span>);
    $endif
}</code></pre><p>It is important to remember that if we had replaced <code>$n</code> with <code>n</code> the compiler would have complained. <code>n &lt;= 1</code> 
is not be considered to be a constant expression, even if the actual argument to the macro was a constant.
This limitation is deliberate, to offer control over what is compiled out and what isn’t.</p><h3 id="pre-conditions-for-macros-untyped-lists-conditional-compilation-at-the-top-level-using-if">Conditional compilation at the top level using @if</h3><p>At the top level, conditional compilation is controlled using with <code>@if</code> attributes on declarations</p><pre><code class="lang-c3">fn void foo_win<span class="number">32</span>() @if(env::WIN<span class="number">32</span>)
{
    /* .... */
}

struct Foo
{
    int a;
    int b @if(env::NO_LIBC);
}</code></pre><p>The argument to <code>@if</code> must be possible to resolve to a constant at compile time. This means that argument
may also be a compile time evaluated macro:</p><pre><code class="lang-c3">macro bool @foo($x) =&gt; $x &gt; <span class="number">2</span>;

int x @if(@foo(<span class="number">5</span>)); <span class="comment">// Will be included</span>
int y @if(@foo(<span class="number">0</span>)); <span class="comment">// Will not be included</span></code></pre><h4>Evaluation order of top level conditional compilation</h4><p>Conditional compilation at the top level can cause unexpected ordering issues, especially when combined with 
<code>$defined</code>. At a high level, there are three phases of evaluation:</p><ol>
<li>Non-conditional declarations are registered.</li>
<li>Conditional module sections are either discarded or have all of their non-conditional declarations registered.</li>
<li>Each module in turn will evaluate <code>@if</code> attributes for each module section. </li>
</ol><p>The order of module and module section evaluation in (2) and (3) is not deterministic and any use of <code>$defined</code> should not 
rely on this ordering.</p><h2 id="pre-conditions-for-macros-compile-time-introspection">Compile time introspection</h2><p>At compile time, full type information is available. This allows for creation of reusable, code generating, macros for things
like serialization.</p><pre><code class="lang-c3">usz foo_alignment = Foo.alignof;
usz foo_member_count = Foo.membersof.len;
String foo_name = Foo.nameof;</code></pre><p>To read more about all the fields available at compile time, see the page on <a href="https://waveproc.github.io/generic-programming/reflection">reflection</a>.</p><h2 id="pre-conditions-for-macros-compile-time-functions">Compile time functions</h2><p>A set of compile time functions are available at compile time:</p><h3 id="pre-conditions-for-macros-compile-time-functions-alignof"><code>$alignof</code></h3><p>Get the alignment of something. See <a href="https://waveproc.github.io/generic-programming/reflection">reflection</a>.</p><h3 id="pre-conditions-for-macros-compile-time-functions-append"><code>$append</code></h3><p>Append a compile time constant to a compile time array or untyped list.</p><h3 id="pre-conditions-for-macros-compile-time-functions-assert"><code>$assert</code></h3><p>Check a condition at compile time.</p><h3 id="pre-conditions-for-macros-compile-time-functions-assignable"><code>$assignable</code></h3><p>Check if an expression is assignable to the given type, e.g. <code>Type x = expr;</code> would be valid.</p><h3 id="pre-conditions-for-macros-compile-time-functions-defined"><code>$defined</code></h3><p>Returns true if a type or identifier is defined. See <a href="https://waveproc.github.io/generic-programming/reflection">reflection</a>.</p><h3 id="pre-conditions-for-macros-compile-time-functions-echo"><code>$echo</code></h3><p>Print a message to stdout when compiling the code.</p><h3 id="pre-conditions-for-macros-compile-time-functions-embed"><code>$embed</code></h3><p>Embed binary data from a file. See <a href="https://waveproc.github.io/language-fundamentals/expressions/">expressions</a>.</p><h3 id="pre-conditions-for-macros-compile-time-functions-error"><code>$error</code></h3><p>When this is compiled, issue a compile time error.</p><h3 id="pre-conditions-for-macros-compile-time-functions-eval"><code>$eval</code></h3><p>Converts a compile time string to the corresponding variable or function. See <a href="https://waveproc.github.io/generic-programming/reflection">reflection</a>.</p><h3 id="pre-conditions-for-macros-compile-time-functions-evaltype"><code>$evaltype</code></h3><p>Converts a compile time string to the corresponding type. See <a href="https://waveproc.github.io/generic-programming/reflection">reflection</a>.</p><h3 id="pre-conditions-for-macros-compile-time-functions-exec"><code>$exec</code></h3><p>Execute a script at compile time and include the result in the source code.</p><h3 id="pre-conditions-for-macros-compile-time-functions-extnameof-qnameof-and-nameof"><code>$extnameof</code>, <code>$qnameof</code> and <code>$nameof</code></h3><p>Get the external name of a symbol. See <a href="https://waveproc.github.io/generic-programming/reflection">reflection</a>.</p><h3 id="pre-conditions-for-macros-compile-time-functions-feature"><code>$feature</code></h3><p>Check if a given feature is enabled.</p><h3 id="pre-conditions-for-macros-compile-time-functions-is_const"><code>$is_const</code></h3><p>Check if the expression is constant at compile time.</p><h3 id="pre-conditions-for-macros-compile-time-functions-nameof"><code>$nameof</code></h3><p>Get the local name of a symbol. See <a href="https://waveproc.github.io/generic-programming/reflection">reflection</a>.</p><h3 id="pre-conditions-for-macros-compile-time-functions-offsetof"><code>$offsetof</code></h3><p>Get the offset of a member. See <a href="https://waveproc.github.io/generic-programming/reflection">reflection</a>.</p><h3 id="pre-conditions-for-macros-compile-time-functions-qnameof"><code>$qnameof</code></h3><p>Get the qualified name of a symbol. See <a href="https://waveproc.github.io/generic-programming/reflection">reflection</a>.</p><h3 id="pre-conditions-for-macros-compile-time-functions-vacount"><code>$vacount</code></h3><p>Return the number of macro vaarg arguments</p><h3 id="pre-conditions-for-macros-compile-time-functions-vaconst"><code>$vaconst</code></h3><p>Return a vaarg as a <code>$constant</code> parameter.</p><h3 id="pre-conditions-for-macros-compile-time-functions-vaexpr"><code>$vaexpr</code></h3><p>Return a vaarg as an <code>#expr</code> parameter.</p><h3 id="pre-conditions-for-macros-compile-time-functions-vasplat"><code>$vasplat</code></h3><p>Expand the vaargs in an initializer list or function call.</p><h3 id="pre-conditions-for-macros-compile-time-functions-vatype"><code>$vatype</code></h3><p>Get a vaarg as a <code>$Type</code> parameter.</p><h3 id="pre-conditions-for-macros-compile-time-functions-sizeof"><code>$sizeof</code></h3><p>Return the size of an expression.</p><h3 id="pre-conditions-for-macros-compile-time-functions-stringify"><code>$stringify</code></h3><p>Turn an expression into a string.</p><h3 id="pre-conditions-for-macros-compile-time-functions-typeof"><code>$typeof</code></h3><p>Get the type of an expression (without evaluating it).</p><h3 id="pre-conditions-for-macros-compile-time-functions-typefrom"><code>$typefrom</code></h3><p>Get a type from a compile time constant <code>typeid</code>.</p><hr><p>title: Reflection
description: Reflection
sidebar:</p><pre><code>order: 85</code></pre><hr><p>C3 allows both compile time and runtime reflection.</p><p>During
 compile time the type information may be directly used as compile time 
constants, the same data is then available dynamically at runtime.</p><p><em>Note that not all reflection is implemented in the compiler at this point in time.</em></p><h2 id="pre-conditions-for-macros-compile-time-reflection">Compile time reflection</h2><p>During compile time there are a number of compile time fields that may be accessed directly.</p><h3 id="pre-conditions-for-macros-compile-time-reflection-type-properties">Type properties</h3><p>It is possible to access properties on the type itself:</p><ul>
<li><code>alignof</code></li>
<li><code>associated</code></li>
<li><code>elements</code></li>
<li><code>extnameof</code></li>
<li><code>inf</code></li>
<li><code>inner</code></li>
<li><code>kindof</code></li>
<li><code>len</code></li>
<li><code>max</code></li>
<li><code>membersof</code></li>
<li><code>min</code></li>
<li><code>nan</code></li>
<li><code>nameof</code></li>
<li><code>names</code></li>
<li><code>params</code></li>
<li><code>parentof</code></li>
<li><code>qnameof</code></li>
<li><code>returns</code></li>
<li><code>sizeof</code></li>
<li><code>typeid</code></li>
<li><code>values</code></li>
</ul><h4>alignof</h4><p>Returns the alignment in bytes needed for the type.</p><pre><code class="lang-c3">struct Foo @align(<span class="number">8</span>)
{
    int a;
}

uint a = Foo.alignof; <span class="comment">// <span class="number">8</span></span></code></pre><h4>associated</h4><p><em>Only available for enums.</em>
Returns an array containing the types of associated values if any.</p><pre><code class="lang-c3">enum Foo : int (double d, String s)
{
    BAR = { <span class="number"><span class="number">1</span>.<span class="number">0</span></span>, <span class="string">"normal"</span> },
    BAZ = { <span class="number"><span class="number">2</span>.<span class="number">0</span></span>, <span class="string">"exceptional"</span> }
}
String s = Foo.associated[<span class="number">0</span>].nameof; <span class="comment">// <span class="string">"double"</span></span></code></pre><h4>elements</h4><p>Returns the element count of an enum or fault.</p><pre><code class="lang-c3">enum FooEnum
{
    BAR,
    BAZ
}
int x = FooEnum.elements; <span class="comment">// <span class="number">2</span></span></code></pre><h4>inf</h4><p><em>Only available for floating point types</em></p><p>Returns a representation of floating point “infinity”.</p><h4>inner</h4><p>This returns a typeid to an “inner” type. What this means is different for each type:</p><ul>
<li>Array -&gt; the array base type.</li>
<li>Bitstruct -&gt; underlying base type.</li>
<li>Distinct -&gt; the underlying type.</li>
<li>Enum -&gt; underlying enum base type.</li>
<li>Pointer -&gt; the type being pointed to.</li>
<li>Vector -&gt; the vector base type.</li>
</ul><p>It is not defined for other types.</p><h4>kindof</h4><p>Returns the underlying <code>TypeKind</code> as defined in std::core::types.</p><pre><code class="lang-c3">TypeKind kind = int.kindof; <span class="comment">// TypeKind.SIGNED_INT</span></code></pre><h4>len</h4><p>Returns the length of the array.</p><pre><code class="lang-c3">usz len = int[<span class="number">4</span>].len; <span class="comment">// <span class="number">4</span></span></code></pre><h4>max</h4><p>Returns the maximum value of the type (only valid for integer and float types).</p><pre><code class="lang-c3">ushort max_ushort = ushort.max; <span class="comment">// <span class="number">65535</span></span></code></pre><h4>membersof</h4><p><em>Only available for bitstruct, struct and union types.</em></p><p>Returns a <em>compile time</em> list containing the fields in a bitstruct, struct or union. The
elements have the <em>compile time only</em> type of <code>member_ref</code>. </p><p><em>Note: As the list is an “untyped” list, you are limited to iterating and accessing it at 
compile time.</em></p><pre><code class="lang-c3">struct Baz
{
    int x;
    Foo* z;
}
String x = Baz.membersof[<span class="number">1</span>].nameof; <span class="comment">// <span class="string">"z"</span></span></code></pre><p>A <code>member_ref</code> has properties <code>alignof</code>, <code>kindof</code>, <code>membersof</code>, <code>nameof</code>, <code>offsetof</code>, <code>sizeof</code> and <code>typeid</code>.</p><h4>min</h4><p>Returns the minimum value of the type (only valid for integer and float types).</p><pre><code class="lang-c3">ichar min_ichar = ichar.min; <span class="comment">// -<span class="number">128</span></span></code></pre><h4>nameof</h4><p>Returns the name of the type.</p><h4>names</h4><p>Returns a slice containing the names of an enum or fault.</p><pre><code class="lang-c3">enum FooEnum
{
    BAR,
    BAZ
}
String[] x = FooEnum.names; <span class="comment">// [<span class="string">"BAR"</span>, <span class="string">"BAZ"</span>]</span></code></pre><h4>paramsof</h4><p><em>Only available for function pointer types.</em>
Returns a ReflectParam struct for all function pointer parameters.</p><pre><code class="lang-c3">def TestFunc = fn int(int x, double f);
String s = TestFunc.paramsof[<span class="number">1</span>].name; <span class="comment">// <span class="string">"f"</span></span>
typeid t = TestFunc.paramsof[<span class="number">1</span>].type; <span class="comment">// double.typeid</span></code></pre><h4>parentof</h4><p><em>Only available for bitstruct and struct types.</em>
Returns the typeid of the parent type.</p><pre><code class="lang-c3">struct Foo
{
    int a;
}

struct Bar
{
    inline Foo f;
}

String x = Bar.parentof.nameof; <span class="comment">// <span class="string">"Foo"</span></span></code></pre><h4>returns</h4><p><em>Only available for function types.</em>
Returns the typeid of the return type.</p><pre><code class="lang-c3">def TestFunc = fn int(int, double);
String s = TestFunc.returns.nameof; <span class="comment">// <span class="string">"int"</span></span></code></pre><h4>sizeof</h4><p>Returns the size in bytes for the given type, like C <code>sizeof</code>.</p><pre><code class="lang-c3">usz x = Foo.sizeof;</code></pre><h4>typeid</h4><p>Returns the typeid for the given type. <code>def</code>s will return the typeid of the underlying type. The typeid size is the same as that of an <code>iptr</code>.</p><pre><code class="lang-c3">typeid x = Foo.typeid;</code></pre><h4>values</h4><p>Returns a slice containing the values of an enum or fault.</p><pre><code class="lang-c3">enum FooEnum
{
    BAR,
    BAZ
}
String x = FooEnum.values[<span class="number">1</span>].nameof; <span class="comment">// <span class="string">"BAR"</span></span></code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-compile-time-functions">Compile time functions</h3><p>There are several built-in functions to inspect the code during compile time.</p><ul>
<li><code>$alignof</code></li>
<li><code>$defined</code></li>
<li><code>$eval</code></li>
<li><code>$evaltype</code></li>
<li><code>$extnameof</code></li>
<li><code>$nameof</code></li>
<li><code>$offsetof</code></li>
<li><code>$qnameof</code></li>
<li><code>$sizeof</code></li>
<li><code>$stringify</code></li>
<li><code>$typeof</code></li>
</ul><h3 id="pre-conditions-for-macros-compile-time-reflection-alignof">$alignof</h3><p>Returns the alignment in bytes needed for the type or member.</p><pre><code class="lang-c3">module test::bar;

struct Foo
{
    int x;
    char[] y;
}
int g = <span class="number">123</span>;

$alignof(Foo.x); <span class="comment">// =&gt; returns <span class="number">4</span></span>
$alignof(Foo.y); <span class="comment">// =&gt; returns <span class="number">8</span> on <span class="number">64</span> bit</span>
$alignof(Foo);   <span class="comment">// =&gt; returns <span class="number">8</span> on <span class="number">64</span> bit</span>
$alignof(g);     <span class="comment">// =&gt; returns <span class="number">4</span></span></code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-defined">$defined</h3><p>Returns true if the expression inside is defined and all sub expressions are valid.</p><pre><code class="lang-c3">$defined(Foo.x);     <span class="comment">// =&gt; returns true</span>
$defined(Foo.z);     <span class="comment">// =&gt; returns false</span>
int[<span class="number">2</span>] abc;
$defined(abc.len);   <span class="comment">// =&gt; returns true</span>
$defined(abc.len()); <span class="comment">// =&gt; returns false</span>
$defined((int)abc);  <span class="comment">// =&gt; returns false</span>
<span class="comment">// $defined(abc.len() + <span class="number">1</span>)  would be an error</span></code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-eval">$eval</h3><p>Converts a compile time string with the corresponding variable:</p><pre><code class="lang-c3">int a = <span class="number">123</span>;         <span class="comment">// =&gt; a is now <span class="number">123</span></span>
$eval(<span class="string">"a"</span>) = <span class="number">222</span>;    <span class="comment">// =&gt; a is now <span class="number">222</span></span>
$eval(<span class="string">"mymodule::fooFunc"</span>)(a); <span class="comment">// =&gt; same as mymodule::fooFunc(a)</span></code></pre><p><code>$eval</code> is limited to a single, optionally path prefixed, identifier.
Consequently methods cannot be evaluated directly:</p><pre><code class="lang-c3">struct Foo { ... }
fn int Foo.test(Foo* f) { ... }

fn void test()
{
    void* test<span class="number">1</span> = &amp;$eval(<span class="string">"test"</span>); <span class="comment">// Works</span>
    void* test<span class="number">2</span> = &amp;Foo.$eval(<span class="string">"test"</span>); <span class="comment">// Works</span>
    <span class="comment">// void* test<span class="number">3</span> = &amp;$eval(<span class="string">"Foo.test"</span>); // Error</span>
}</code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-evaltype">$evaltype</h3><p>Similar to <code>$eval</code> but for types:</p><pre><code class="lang-c3">$evaltype(<span class="string">"float"</span>) f = <span class="number"><span class="number">12</span>.<span class="number">0</span></span>f;</code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-extnameof">$extnameof</h3><p>Returns the external name of a type, variable or function. The external name is
the one used by the linker.</p><pre><code class="lang-c3">fn void testfn(int x) { }
String a = $extnameof(g); <span class="comment">// =&gt; <span class="string">"test.bar.g"</span>;</span>
string b = $extnameof(testfn); <span class="comment">// =&gt; <span class="string">"test.bar.testfn"</span></span></code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-nameof">$nameof</h3><p>Returns the name of a function or variable as a string without module prefixes.</p><pre><code class="lang-c3">fn void test() { }
int g = <span class="number">1</span>;

String a = $nameof(g); <span class="comment">// =&gt; <span class="string">"g"</span></span>
String b = $nameof(test); <span class="comment">// =&gt; <span class="string">"test"</span></span></code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-offsetof">$offsetof</h3><p>Returns the offset of a member in a struct.</p><pre><code class="lang-c3">Foo z;
$offsetof(z.y); <span class="comment">// =&gt; returns <span class="number">8</span> on <span class="number">64</span> bit, <span class="number">4</span> on <span class="number">32</span> bit</span></code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-qnameof">$qnameof</h3><p>Returns the same as <code>$nameof</code>, but with the full module name prepended.</p><pre><code class="lang-c3">module abc;
fn void test() { }
int g = <span class="number">1</span>;

String a = $qnameof(g); <span class="comment">// =&gt; <span class="string">"abc::g"</span></span>
String b = $qnameof(test); <span class="comment">// =&gt; <span class="string">"abc::test"</span></span></code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-sizeof">$sizeof</h3><p>This is used on a value to determine the allocation size needed. <code>$sizeof(a)</code> is equivalent
to doing <code>$typeof(a).sizeof</code>. Note that this is only used on values and not on types.</p><pre><code class="lang-c3">$typeof(a)* x = allocate_bytes($sizeof(a));
*x = a;</code></pre><h3 id="pre-conditions-for-macros-compile-time-reflection-stringify">$stringify</h3><p>Returns the expression as a string. It has a special behaviour for macro expression parameters,
where <code>$stringify(#foo)</code> will return the expression contained in <code>#foo</code> rather than simply return
“#foo”</p><h3 id="pre-conditions-for-macros-compile-time-reflection-typeof">$typeof</h3><p>Returns the type of an expression or variable as a type itself.</p><pre><code class="lang-c3">Foo f;
$typeof(f) x = f;</code></pre><hr><p>title: Standard Library
description: Standard Library
sidebar:</p><pre><code>order: 128</code></pre><hr><p>The standard library is currently in development, so frequent changes will occur. Note that all std::core modules and
sub modules are implicitly imported.</p><h2 id="pre-conditions-for-macros-stdcorebuiltin">std::core::builtin</h2><p>All functions and macros in this library can be used without path qualifiers.</p><h3 id="pre-conditions-for-macros-stdcorebuiltin-void-panicchar-message-char-file-char-function-uint-line">void panic(char<em> message, char </em>file, char *function, uint line)</h3><p>Default function called when the asserts fails.</p><h3 id="pre-conditions-for-macros-stdcorebuiltin-void-swapa-b">void @swap(&amp;a, &amp;b)</h3><p>Swap values in <code>a</code> and <code>b</code>.</p><pre><code class="lang-c">int a = <span class="number">3</span>;
int b = <span class="number">5</span>;
@swap(a, b);
io::printfn(<span class="string">"%d"</span>, a); <span class="comment">// Prints <span class="number">5</span></span></code></pre><h3 id="pre-conditions-for-macros-stdcorebuiltin-anycastany-v-type">anycast(any v, $Type)</h3><p>Optionally cast the value <code>v</code> to type <code>$Type*</code> on failure returns <code>CastResult.TYPE_MISMATCH</code>.</p><pre><code class="lang-c">int b;
any a = &amp;b;
float*! c = anycast(a, float); <span class="comment">// Will return TYPE_MISMATCH</span>
int*! d = anycast(a, int);     <span class="comment">// Works!</span></code></pre><h3 id="pre-conditions-for-macros-stdcorebuiltin-void-unreachablestring-unreachable-statement-reached">void unreachable($string = “Unreachable statement reached.”)</h3><p>Mark a code path as unreachable.</p><pre><code class="lang-c">switch (x)
{
    case <span class="number">0</span>:
        foo();
    case <span class="number">1</span>:
        bar();
    default:
        <span class="comment">// Should never happen.</span>
        unreachable(<span class="string">"x should have been <span class="number">0</span> or <span class="number">1</span>"</span>);    
}</code></pre><p>On safe mode this will throw a runtime panic when reached. For release mode the
compiler will assume this case never happens.</p><h3 id="pre-conditions-for-macros-stdcorebuiltin-bitcastvalue-type">bitcast(value, $Type)</h3><p>Do a bitcast of a value to <code>$Type</code>, requires that the types are of the same memory size.</p><pre><code class="lang-c">float x = <span class="number"><span class="number">1</span>.<span class="number">0</span></span>;
int y = bitcast(x, int); <span class="comment">// y = <span class="number">0</span>x<span class="number">3</span>f<span class="number">800000</span></span></code></pre><h3 id="pre-conditions-for-macros-stdcorebuiltin-enum_by_nametype-enum_name">enum_by_name($Type, enum_name)</h3><p>Optionally returns the enum value with the given name. <code>$Type</code> must be an enum. Returns <code>SearchResult.MISSING</code>
on failure.</p><pre><code class="lang-c">enum Foo { ABC, CDE, EFG }

fn void! test()
{
    Foo f = enum_by_name(Foo, <span class="string">"CDE"</span>)!; 
    <span class="comment">// same as Foo f = Foo.CDE;</span>
}</code></pre><h3 id="pre-conditions-for-macros-stdcorebuiltin-void-scopevariable-body">void @scope(&amp;variable; @body)</h3><p>Scopes a variable:</p><pre><code>int a = 3;

@scope(a)
{
    a = 4;
    a++;
};

// Prints a = 3
io::printfn("a = %d", a, b);</code></pre><h3 id="pre-conditions-for-macros-stdcorebuiltin-less-greater-less_eq-greater_eq-equals">less, greater, less_eq, greater_eq, equals</h3><p>All macros take two values and compare them. Any type implementing <code>Type.less</code> 
or <code>Type.compare_to</code> may be compared (or if the type implements <code>&lt;</code>). Types 
implementing <code>Type.equals</code> may use <code>equals</code> even if neither <code>less</code> nor <code>compare_to</code>
are implemented.</p><h3 id="pre-conditions-for-macros-stdcorebuiltin-faults">Faults</h3><ul>
<li><code>IteratorResult</code> returned when reaching the end of an iterator.</li>
<li><code>SearchResult</code> used when a search fails.</li>
<li><code>CastResult</code> when an anycast fails.</li>
</ul><h2 id="pre-conditions-for-macros-stdcoreenv">std::core::env</h2><h3 id="pre-conditions-for-macros-stdcoreenv-constants">Constants</h3><ul>
<li><code>OS_TYPE</code> the OS type compiled for.</li>
<li><code>COMPILER_OPT_LEVEL</code> the optimization level used.</li>
<li><code>I128_SUPPORT</code> true if int128 support is available.</li>
<li><code>COMPILER_SAFE_MODE</code> true if compiled with safety checks.</li>
</ul><h2 id="pre-conditions-for-macros-stdcoremem">std::core::mem</h2><h3 id="pre-conditions-for-macros-stdcoremem-malloc-malloc_checked-malloc_aligned">malloc, malloc_checked, malloc_aligned</h3><p>Allocate the given number of bytes. <code>malloc</code> will panic on out of memory, 
whereas <code>malloc_checked</code> and <code>malloc_aligned</code> returns an optional value.
<code>malloc_aligned</code> adds an alignment, which must be a power of 2. Any pointer
allocated using <code>malloc_aligned</code> must be freed using <code>free_aligned</code> rather
the normal <code>free</code> or memory corruption may result.</p><pre><code class="lang-c">char* data = malloc(<span class="number">8</span>);
char*! data<span class="number">2</span> = malloc_checked(<span class="number">8</span>);
int[&lt;<span class="number">16</span>&gt;]*! data<span class="number">3</span> = malloc_aligned(<span class="number">16</span> * int.sizeof), <span class="number">128</span>);</code></pre><h3 id="pre-conditions-for-macros-stdcoremem-newtype-initializer-new_alignedtype-initializer">new($Type, #initializer), new_aligned($Type, #initializer)</h3><p>This allocates a single element of $Type, returning the pointer. An optional initializer may be added, which
immediately initializes the value to that of the initializer.</p><p>If no initializer is provided, it is zero initialized. <code>new_aligned</code> works the same but for overaligned types, such allocations
must be freed using <code>free_aligned</code></p><pre><code class="lang-c3">int* a = mem::new(int);
Foo* foo = mem::new(Foo, { <span class="number">1</span>, <span class="number">2</span> });</code></pre><h3 id="pre-conditions-for-macros-stdcoremem-alloctype-alloc_alignedtype">alloc($Type), alloc_aligned($Type)</h3><p>Allocates a single element of $Type, same as <code>new</code>, but without initializing the data.</p><h3 id="pre-conditions-for-macros-stdcoremem-new_arraytype-usz-elements-new_array_alignedtype-usz-elements">new_array($Type, usz elements), new_array_aligned($Type, usz elements)</h3><p>Allocates a slice of <code>elements</code> number of elements, returning
a slice of the given length. Elements are zero initialized. <code>new_array_aligned</code> is used for 
types that exceed standard alignment.</p><pre><code class="lang-c3">int[] ints = mem::new_array(int, <span class="number">100</span>); <span class="comment">// Allocated int[<span class="number">100</span>] on the heap, zero initialized.</span></code></pre><h3 id="pre-conditions-for-macros-stdcoremem-alloc_arraytype-usz-elements-alloc_array_alignedtype-usz-elements">alloc_array($Type, usz elements), alloc_array_aligned($Type, usz elements)</h3><p>Same as <code>new_array</code> but without initialization.</p><h3 id="pre-conditions-for-macros-stdcoremem-calloc-calloc_checked-calloc_aligned">calloc, calloc_checked, calloc_aligned</h3><p>Identical to the <code>malloc</code> variants, except the data is guaranteed to be zeroed out.</p><h3 id="pre-conditions-for-macros-stdcoremem-relloc-relloc_checked-realloc_aligned">relloc, relloc_checked, realloc_aligned</h3><p>Resizes memory allocated using <code>malloc</code> or <code>calloc</code>. Any extra data is 
guaranteed to be zeroed out. <code>realloc_aligned</code> can only be used with
pointers created using <code>calloc_aligned</code> or <code>alloc_aligned</code>.</p><h3 id="pre-conditions-for-macros-stdcoremem-free-free_aligned">free, free_aligned</h3><p>Frees memory allocated using <code>malloc</code> or <code>calloc</code>. Any memory allocated using “_aligned” variants
must be freed using <code>free_aligned</code>.</p><h3 id="pre-conditions-for-macros-stdcoremem-scopedallocator-allocator-body">@scoped(Allocator* allocator; @body())</h3><p>Swaps the current memory allocator for the duration of the call.</p><pre><code class="lang-c">DynamicArenaAllocator dynamic_arena;
dynamic_arena.init(<span class="number">1024</span>);
mem::@scoped(&amp;dynamic_arena) 
{
    <span class="comment">// This allocation uses the dynamic arena </span>
    Foo* f = malloc(Foo);
};
<span class="comment">// Release any dynamic arena memory.</span>
dynamic_arena.destroy();</code></pre><h3 id="pre-conditions-for-macros-stdcoremem-tscoped-body">@tscoped(; @body())</h3><p>Same as @scoped, but uses the temporary allocator rather than any
arbitrary allocator.</p><h3 id="pre-conditions-for-macros-stdcoremem-void-tmallocusz-size-usz-alignment-0">void* tmalloc(usz size, usz alignment = 0)</h3><p>Allocates memory using the temporary allocator. Panic on failure. It has type
variants similar to <code>malloc</code>, so <code>tmalloc(Type)</code> would create a <code>Type*</code> using
the temporary allocator.</p><h3 id="pre-conditions-for-macros-stdcoremem-void-tcallocusz-size-usz-alignment-0">void* tcalloc(usz size, usz alignment = 0)</h3><p>Same as <code>tmalloc</code> but clears the memory.</p><h3 id="pre-conditions-for-macros-stdcoremem-void-treallocvoid-ptr-usz-size-usz-alignment-0">void<em> trealloc(void</em> ptr, usz size, usz alignment = 0)</h3><p><code>realloc</code> but on memory received using <code>tcalloc</code> or <code>tmalloc</code>.</p><h3 id="pre-conditions-for-macros-stdcoremem-temp_new-temp_alloc-temp_new_array-temp_alloc_array">temp_new, temp_alloc, temp_new_array, temp_alloc_array</h3><p>Same as the <code>new</code>, <code>alloc</code>, <code>new_array</code> and <code>alloc_array</code> respectively.</p><h3 id="pre-conditions-for-macros-stdcoremem-void-poolbody">void @pool(;@body)</h3><p>Opens a temporary memory scope.</p><pre><code class="lang-c3">@pool() 
{
    <span class="comment">// This allocation uses the dynamic arena </span>
    Foo* f = tmalloc(Foo);
};</code></pre><h3 id="pre-conditions-for-macros-stdcoremem-volatile_loadx">@volatile_load(&amp;x)</h3><p>Returns the value in <code>x</code> using a volatile load.</p><pre><code class="lang-c3"><span class="comment">// Both loads will always happen:</span>
int y = @volatile_load(my_global);
y = @volatile_load(my_global);</code></pre><h3 id="pre-conditions-for-macros-stdcoremem-volatile_storex-y">@volatile_store(&amp;x, y)</h3><p>Store the value <code>y</code> in <code>x</code> using a volatile store.</p><pre><code class="lang-c3"><span class="comment">// Both stores will always happen:</span>
@volatile_store(y, <span class="number">1</span>);
@volatile_store(y, <span class="number">1</span>);</code></pre><h3 id="pre-conditions-for-macros-stdcoremem-usz-aligned_offsetusz-offset-usz-alignment">usz aligned_offset(usz offset, usz alignment)</h3><p>Returns an aligned size based on the current offset. The alignment
must be a power of two. E.g. <code>mem::aligned_offset(17, 8)</code> would return <code>24</code></p><h3 id="pre-conditions-for-macros-stdcoremem-usz-aligned_pointervoid-ptr-usz-alignment">usz aligned_pointer(void* ptr, usz alignment)</h3><p>Returns a pointer aligned to the given alignment, using <code>aligned_offset</code>.</p><h3 id="pre-conditions-for-macros-stdcoremem-bool-ptr_is_alignedvoid-ptr-usz-alignment">bool ptr_is_aligned(void* ptr, usz alignment)</h3><p>Return true if the pointer is aligned, false otherwise.</p><h3 id="pre-conditions-for-macros-stdcoremem-void-copyvoid-dst-void-src-usz-len-usz-dst_align-0-usz-src_align-0-bool-is_volatile-false">void copy(void<em> dst, void</em> src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)</h3><p>Copies bytes from one pointer to another. It may optionally be set as volatile,
in which case the copy may not be optimized away. Furthermore the source
and destination alignment may be used.</p><pre><code class="lang-c3">Foo* f = tmalloc(data_size);
mem::copy(f, slice.ptr, size);</code></pre><h3 id="pre-conditions-for-macros-stdcoremem-void-setvoid-dst-char-val-usz-len-usz-dst_align-0-bool-is_volatile-false">void set(void* dst, char val, usz len, usz $dst_align = 0, bool $is_volatile = false)</h3><p>Sets bytes to a value. This operation may be aligned and/or volatile. See the <code>copy</code> method.</p><h3 id="pre-conditions-for-macros-stdcoremem-void-clearvoid-dst-usz-len-usz-dst_align-0-bool-is_volatile-false">void clear(void* dst, usz len, usz $dst_align = 0, bool $is_volatile = false)</h3><p>Sets bytes to zero. This operation may be aligned and/or volatile. See the <code>copy</code> method.</p><h3 id="pre-conditions-for-macros-stdcoremem-clonevalue">@clone(&amp;value)</h3><p>Makes a shallow copy of a value using the regular allocator.</p><pre><code class="lang-c">Foo f = ...

return @clone(f);</code></pre><h3 id="pre-conditions-for-macros-stdcoremem-tclonevalue">@tclone(&amp;value)</h3><p>Same as <code>@clone</code> but uses the temporary allocator.</p><h2 id="pre-conditions-for-macros-stdcoretypes">std::core::types</h2><h3 id="pre-conditions-for-macros-stdcoretypes-bool-is_comparable_valuetype">bool is_comparable_value($Type)</h3><p>Return true if the type can be used with comparison operators.</p><h3 id="pre-conditions-for-macros-stdcoretypes-bool-is_equatable_valuevalue">bool is_equatable_value(value)</h3><p>Return <code>true</code> if the value can be compared using the <code>equals</code> macro.</p><h3 id="pre-conditions-for-macros-stdcoretypes-bool-is_equatable_valuevalue">bool is_equatable_value(value)</h3><p>Return <code>true</code> if the value can be compared using the comparison macros.</p><h3 id="pre-conditions-for-macros-stdcoretypes-kind_is_inttypekind-kind">kind_is_int(TypeKind kind)</h3><h3 id="pre-conditions-for-macros-stdcoretypes-any_to_intany-v-type">any_to_int(any* v, $Type)</h3><p>Returns an optional value of <code>$Type</code> if the any value losslessly
may be converted into the given type. Returns a <code>ConversionResult</code> otherwise.</p><pre><code class="lang-c">any* v = &amp;&amp;<span class="number">128</span>;
short y = any_to_int(v, short)!!; <span class="comment">// Works </span>
ichar z = any_to_int(v, ichar)!!; <span class="comment">// Panics VALUE_OUT_OF_RANGE</span></code></pre><h2 id="pre-conditions-for-macros-stdcorestrconv">std::core::str::conv</h2><h3 id="pre-conditions-for-macros-stdcorestrconv-usz-char32_to_utf8char32-c-char-output-usz-available">usz! char32_to_utf8(Char32 c, char* output, usz available)</h3><p>Convert a UTF32 codepoint to an UTF8 buffer. <code>size</code> has the number of
writable bytes left. It returns the number of bytes used, or 
<code>UnicodeResult.CONVERSION_FAILED</code> if the buffer is too small.</p><h3 id="pre-conditions-for-macros-stdcorestrconv-void-char32_to_utf16_unsafechar32-c-char16-output">void char32_to_utf16_unsafe(Char32 c, Char16** output)</h3><p>Convert a UTF32 codepoint to an UTF16 buffer without bounds checking,
moving the output pointer 1 or 2 steps.</p><h2 id="pre-conditions-for-macros-stdio">std::io</h2><h3 id="pre-conditions-for-macros-stdio-string-readlinestream-iostdin-allocator-allocator-allocatorheap">String! readline(stream = io::stdin(), Allocator allocator = allocator::heap())</h3><p>Read a <code>String!</code> from a file stream, which is standard input (stdin) by default, reads to the next newline character <code>\n</code> or to the end of stream. <code>Readline</code> returns an <a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">Optional</a> string.</p><pre><code class="lang-c3">import std::io;

fn void! hello_name()
{
    String! name = io::readline();
    if (catch excuse = name) 
    {
        return excuse?;
    }

    io::printfn(<span class="string">"Name was: %s."</span>, name);
}

:::Note
`\r` will be filtered from the String.
:::

<span class="comment">### String! treadline(stream = io::stdin())</span>
Read a `String!` from a file stream which is standard input (stdin) by default, Reads to the next newline character `\n` or to the end of stream. `Treadline` returns an [Optional](/language-common/optionals-essential/<span class="comment">#what-is-an-optional) string. The temporary allocator is used by `Treadline`, in contrast the `readline` defaults to the heap allocator, but is configurable to other allocators. </span>

```c
import std::io;

fn void! hello_name()
{
    String! name = io::treadline();
    if (catch excuse = name) {
        return excuse?;
    }

    io::printfn(<span class="string">"Hello %s! Hope you have a great day"</span>, name);
}</code></pre><p>:::Note
<code>\r</code> will be filtered from the String.
:::</p><h3 id="pre-conditions-for-macros-stdio-void-printx-void-printnx">void print(x), void printn(x = “”)</h3><p>Print a value to stdout works for the majority of types, including structs, which can be helpful for debugging.
The <code>printn</code> variant appends a newline.</p><pre><code class="lang-c3">import std::io;

enum Heat 
{
    WARM,
    WARMER,
    REALLY_WARM,
}

fn void main() 
{
    int[&lt;<span class="number">2</span>&gt;] vec = { <span class="number">4</span>, <span class="number">2</span> };
    Heat weather = WARM;
    int[<span class="number">5</span>] fib = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };
    String dialogue = <span class="string">"secret"</span>;

    io::print(<span class="string">"Hello"</span>);   <span class="comment">// Hello</span>
    io::print(<span class="number">20</span>);        <span class="comment">// <span class="number">20</span></span>
    io::print(<span class="number"><span class="number">2</span>.<span class="number">2</span></span>);       <span class="comment">// <span class="number"><span class="number">2</span>.<span class="number">200000</span></span></span>
    io::print(vec);       <span class="comment">// [&lt;<span class="number">4</span>, <span class="number">2</span>&gt;]</span>
    io::print(weather);   <span class="comment">// WARM</span>
    io::print(fib);       <span class="comment">// [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] </span>
    io::print(dialogue);  <span class="comment">// secret</span>
}

<span class="comment">### void eprint(x), void eprintn(x)</span>
Print any value to stderr.
The `eprintn` variant appends a newline.

See `print` for usage.

<span class="comment">### usz! printf(String format, args...) @maydiscard</span>
Regular printf functionality: `%s`, `%x`, `%d`, `%f` and `%p` are supported.
Will also print enums and vectors. Prints to stdout.

```c<span class="number">3</span>
import std::io;

enum Heat 
{
    WARM,
    WARMER,
    REALLY_WARM,
}

fn void main() 
{
    int[&lt;<span class="number">2</span>&gt;] vec = { <span class="number">4</span>, <span class="number">2</span> };
    Heat weather = REALLY_WARM;
    String dialogue = <span class="string">"Hello"</span>;

    io::printfn(<span class="string">"%s"</span>, dialogue);  <span class="comment">// Hello</span>
    io::printfn(<span class="string">"%d"</span>, <span class="number">20</span>);        <span class="comment">// <span class="number">20</span></span>
    io::printfn(<span class="string">"%f"</span>, <span class="number"><span class="number">2</span>.<span class="number">2</span></span>);       <span class="comment">// <span class="number"><span class="number">2</span>.<span class="number">200000</span></span></span>
    io::printfn(<span class="string">"%s"</span>, vec);       <span class="comment">// [&lt;<span class="number">4</span>, <span class="number">2</span>&gt;]</span>
    io::printfn(<span class="string">"%s"</span>, weather);   <span class="comment">// REALLY_WARM</span>
}

Also available as `printfn` which appends a newline.

<span class="comment">### usz! eprintf(String format, args...) @maydiscard</span>
Regular printf functionality: `%s`, `%x`, `%d`, `%f` and `%p` are supported.
Will also print enums and vectors. Prints to stderr.

Also available as `eprintfn` which appends a newline.

See `printf` for usage

<span class="comment">### char[]! bprintf(char[] buffer, String format, args...) @maydiscard</span>
Prints using a <span class="string">'printf'</span>-style formatting string, to a string buffer.

Returns a slice of the `buffer` argument with the resulting length.

<span class="comment">### usz! fprint(out, x), usz! fprintn(out, x = <span class="string">""</span>)</span>
Print a value to a stream. `out` must implement `OutStream`.
The `fprintn` variant appends a newline.

<span class="comment">### usz! fprintf(OutStream out, String format, args...)</span>
Prints to the specified OutStream using a <span class="string">'printf'</span>-style formatting string.

Returns the number of characters printed.

`fprintfn` appends a newline.

<span class="comment">### void putchar(char c) @inline</span>
Libc `putchar`, prints a single character to stdout.

<span class="comment">### usz! DString.appendf(DString* str, String format, args...) @maydiscard</span>
Same as printf but on dynamic strings.

<span class="comment">### File* stdout(), File* stdin(), File* stderr()</span>
Return stdout, stdin and stderr respectively.

<span class="comment">## std::io::file</span>

<span class="comment">### File! open(String filename, String mode)</span>
Open a file with the given file name with the given mode (r, w etc)

<span class="comment">### File! open_path(Path path, String mode)</span>
Open a file pointed to by a Path struct, with the given mode.

<span class="comment">### bool is_file(String path)</span>
See whether the given path is a file.

<span class="comment">### usz! get_size(String path)</span>
Get the size of a file.

<span class="comment">### void! delete(String filename)</span>
Delete a file.

<span class="comment">### void! File.reopen(&amp;self, String filename, String mode)</span>
Reopen a file with a new filename and mode.

<span class="comment">### usz! File.seek(&amp;self, isz offset, Seek seek_mode = Seek.SET)</span>
Seek in a file. Based on the libc function.

<span class="comment">### void! File.write_byte(&amp;self, char c) @dynamic</span>
Write a single byte to a file.

<span class="comment">### void! File.close(&amp;self) @inline @dynamic</span>
Close a file, based on the libc function.

<span class="comment">### bool File.eof(&amp;self) @inline</span>
True if EOF has been reached. Based on the libc function.

<span class="comment">### usz! File.read(&amp;self, char[] buffer)</span>
Read into a buffer, based on the libc function.

<span class="comment">### usz! File.write(&amp;self, char[] buffer)</span>
Write to a buffer, based on the libc function.

<span class="comment">### char! File.read_byte(&amp;self) @dynamic</span>
Read a single byte from a file.

<span class="comment">### char[]! load_buffer(String filename, char[] buffer)</span>
Load up to buffer.len characters into the buffer.

Returns IoError.OVERFLOW if the file is longer than the buffer.

<span class="comment">### char[]! load_new(String filename, Allocator allocator = allocator::heap())</span>
Load the entire file into a new buffer.

<span class="comment">### char[]! load_temp(String filename)</span>
Load the entire file into a buffer allocated using the temporary allocator.

<span class="comment">### void! File.flush(&amp;self) @dynamic</span>
Flush a file, based on the libc function.

<span class="comment">## std::collections::list(\&lt;Type\&gt;)</span>

Generic list module, elements are of `Type`.

```c
import std::collections::list;
def MyIntList = List(&lt;int&gt;);

...

MyIntList list;
list.push(<span class="number">123</span>);
list.free();</code></pre><h3 id="pre-conditions-for-macros-stdio-listpushlist-list-type-element-append">List.push(List *list, Type element), append(…)</h3><p>Append a single value to the list.</p><h3 id="pre-conditions-for-macros-stdio-type-listpoplist-list">Type List.pop(List* list)</h3><p>Removes and returns the last entry in the list.</p><h3 id="pre-conditions-for-macros-stdio-type-listpop_firstlist-list">Type List.pop_first(List *list)</h3><p>Removes the first entry in the list.</p><h3 id="pre-conditions-for-macros-stdio-void-listremove_atlist-list-usz-index">void List.remove_at(List *list, usz index)</h3><p>Removes the entry at <code>index</code>.</p><h3 id="pre-conditions-for-macros-stdio-void-listinsert_atlist-list-usz-index-type-type">void List.insert_at(List *list, usz index, Type type)</h3><p>Inserts a value at <code>index</code>.</p><h3 id="pre-conditions-for-macros-stdio-void-listpush_frontlist-list-type-type">void List.push_front(List *list, Type type)</h3><p>Inserts a value to the front of the list.</p><h3 id="pre-conditions-for-macros-stdio-void-listremove_lastlist-list">void List.remove_last(List* list)</h3><p>Remove the last value of the list.</p><h3 id="pre-conditions-for-macros-stdio-void-listremove_firstlist-list">void List.remove_first(List *list)</h3><p>Remove the first element in the list.</p><h3 id="pre-conditions-for-macros-stdio-type-listfirstlist-list">Type<em> List.first(List</em> list)</h3><p>Return the first element in the list if available.</p><h3 id="pre-conditions-for-macros-stdio-type-listlastlist-list">Type<em> List.last(List </em>list)</h3><p>Return the last element in the list if available.</p><h3 id="pre-conditions-for-macros-stdio-listis_emptylist-list">List.is_empty(List *list)</h3><p>Return <code>true</code> if the list is empty.</p><h3 id="pre-conditions-for-macros-stdio-usz-listlenlist-list">usz List.len(List *list)</h3><p>Return the number of elements in the list.</p><h3 id="pre-conditions-for-macros-stdio-type-listgetlist-list-usz-index">Type List.get(List *list, usz index)</h3><p>Return the value at <code>index</code>.</p><h3 id="pre-conditions-for-macros-stdio-void-listfreelist-list">void List.free(List *list)</h3><p>Free all memory associated with this list.</p><h3 id="pre-conditions-for-macros-stdio-void-listswaplist-list-usz-i-usz-j">void List.swap(List *list, usz i, usz j)</h3><p>Swap two elements in the list.</p><hr><p>title: Standard Library Reference
description: Standard Library Reference
sidebar:</p><pre><code>order: 141</code></pre><hr><h3 id="pre-conditions-for-macros-stdio-libc">libc</h3><pre><code class="lang-c3">distinct Errno = inline CInt;</code></pre><pre><code class="lang-c3">struct DivResult</code></pre><pre><code class="lang-c3">struct LongDivResult</code></pre><pre><code class="lang-c3">struct TimeSpec</code></pre><pre><code class="lang-c3">struct Timespec</code></pre><pre><code class="lang-c3">struct Tm</code></pre><pre><code class="lang-c3">fn TimeSpec Duration.to_timespec(self) @inline</code></pre><pre><code class="lang-c3">fn TimeSpec NanoDuration.to_timespec(self) @inline</code></pre><pre><code class="lang-c3">fn Errno errno()</code></pre><pre><code class="lang-c3">fn void errno_set(Errno e)</code></pre><h3 id="pre-conditions-for-macros-stdio-libc-ifenvlibc">libc @if(!env::LIBC)</h3><pre><code class="lang-c3">fn void* calloc(usz count, usz size) @weak @extern(<span class="string">"calloc"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn CFile fclose(CFile) @weak @extern(<span class="string">"fclose"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn int feof(CFile stream) @weak @extern(<span class="string">"feof"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn int fflush(CFile stream) @weak @extern(<span class="string">"fflush"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn int fgetc(CFile stream) @weak @extern(<span class="string">"fgetc"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn char* fgets(ZString str, int n, CFile stream) @weak @extern(<span class="string">"fgets"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn CFile fopen(ZString filename, ZString mode) @weak @extern(<span class="string">"fopen"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn int fputc(int c, CFile stream) @weak @extern(<span class="string">"fputc"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn usz fread(void* ptr, usz size, usz nmemb, CFile stream) @weak @extern(<span class="string">"fread"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn void* free(void*) @weak @extern(<span class="string">"free"</span>)</code></pre><pre><code class="lang-c3">fn CFile freopen(ZString filename, ZString mode, CFile stream) @weak @extern(<span class="string">"fopen"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn int fseek(CFile stream, SeekIndex offset, int whence) @weak @extern(<span class="string">"fseek"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn usz fwrite(void* ptr, usz size, usz nmemb, CFile stream) @weak @extern(<span class="string">"fwrite"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn void longjmp(JmpBuf* buffer, CInt value) @weak @extern(<span class="string">"longjmp"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn void* malloc(usz size) @weak @extern(<span class="string">"malloc"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn void* memcpy(void* dest, void* src, usz n) @weak @extern(<span class="string">"memcpy"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn void* memmove(void* dest, void* src, usz n) @weak @extern(<span class="string">"memmove"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn void* memset(void* dest, CInt value, usz n) @weak @extern(<span class="string">"memset"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn int putc(int c, CFile stream) @weak @extern(<span class="string">"putc"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn int putchar(int c) @weak @extern(<span class="string">"putchar"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn int puts(ZString str) @weak @extern(<span class="string">"puts"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn void* realloc(void* ptr, usz size) @weak @extern(<span class="string">"realloc"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn CInt setjmp(JmpBuf* buffer) @weak @extern(<span class="string">"setjmp"</span>) @nostrip</code></pre><h3 id="pre-conditions-for-macros-stdio-libc-ifenvdarwin">libc @if(env::DARWIN)</h3><pre><code class="lang-c3">struct Stat</code></pre><pre><code class="lang-c3">macro CFile stderr()</code></pre><pre><code class="lang-c3">macro CFile stdin()</code></pre><pre><code class="lang-c3">macro CFile stdout()</code></pre><h3 id="pre-conditions-for-macros-stdio-libc-ifenvlibc-envwin32-envlinux-envdarwin">libc @if(env::LIBC &amp;&amp; !env::WIN32 &amp;&amp; !env::LINUX &amp;&amp; !env::DARWIN)</h3><pre><code class="lang-c3">macro CFile stderr() { return (CFile*)(uptr)STDERR_FD; }</code></pre><pre><code class="lang-c3">macro CFile stdin() { return (CFile*)(uptr)STDIN_FD; }</code></pre><pre><code class="lang-c3">macro CFile stdout() { return (CFile*)(uptr)STDOUT_FD; }</code></pre><h3 id="pre-conditions-for-macros-stdio-libc-ifenvlinux">libc @if(env::LINUX)</h3><pre><code class="lang-c3">struct Stat @if(!env::X<span class="number">86</span>_<span class="number">64</span>)</code></pre><pre><code class="lang-c3">struct Stat @if(env::X<span class="number">86</span>_<span class="number">64</span>)</code></pre><pre><code class="lang-c3">macro usz malloc_size(void* ptr)</code></pre><pre><code class="lang-c3">macro CFile stderr()</code></pre><pre><code class="lang-c3">macro CFile stdin()</code></pre><pre><code class="lang-c3">macro CFile stdout()</code></pre><h3 id="pre-conditions-for-macros-stdio-libc-ifenvposix">libc @if(env::POSIX)</h3><pre><code class="lang-c3">struct Sigaction</code></pre><pre><code class="lang-c3">struct Stack_t</code></pre><h3 id="pre-conditions-for-macros-stdio-libc-ifenvwin32">libc @if(env::WIN32)</h3><pre><code class="lang-c3">struct SystemInfo</code></pre><pre><code class="lang-c3">macro Tm* gmtime_r(Time_t* timer, Tm* buf)</code></pre><pre><code class="lang-c3">macro Tm* localtime_r(Time_t* timer, Tm* buf)</code></pre><pre><code class="lang-c3">macro usz malloc_size(void* ptr)</code></pre><pre><code class="lang-c3">macro isz read(Fd fd, void* buffer, usz buffer_size)</code></pre><pre><code class="lang-c3">macro CInt setjmp(JmpBuf* buffer)</code></pre><pre><code class="lang-c3">macro CFile stderr()</code></pre><pre><code class="lang-c3">macro CFile stdin()</code></pre><pre><code class="lang-c3">macro CFile stdout()</code></pre><pre><code class="lang-c3">macro isz write(Fd fd, void* buffer, usz count)</code></pre><h3 id="pre-conditions-for-macros-stdio-libcos">libc::os</h3><pre><code class="lang-c3">fn int errno() @if(ERRNO_DEFAULT)</code></pre><pre><code class="lang-c3">macro int errno() @if(env::DARWIN)</code></pre><pre><code class="lang-c3">macro int errno() @if(env::LINUX)</code></pre><pre><code class="lang-c3">macro int errno() @if(env::WIN<span class="number">32</span>)</code></pre><pre><code class="lang-c3">fn void errno_set(int err) @if(ERRNO_DEFAULT)</code></pre><pre><code class="lang-c3">macro void errno_set(int err) @if(env::DARWIN)</code></pre><pre><code class="lang-c3">macro void errno_set(int err) @if(env::LINUX)</code></pre><pre><code class="lang-c3">macro void errno_set(int err) @if(env::WIN<span class="number">32</span>)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdascii">std::ascii</h3><pre><code class="lang-c3">fn char char.from_hex(char c)</code></pre><pre><code class="lang-c3">fn bool char.in_range(char c, char start, char len)</code></pre><pre><code class="lang-c3">fn bool char.is_alnum(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_alpha(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_bdigit(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_blank(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_cntrl(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_digit(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_graph(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_lower(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_odigit(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_print(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_punct(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_space(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_upper(char c)</code></pre><pre><code class="lang-c3">fn bool char.is_xdigit(char c)</code></pre><pre><code class="lang-c3">fn char char.to_lower(char c)</code></pre><pre><code class="lang-c3">fn char char.to_upper(char c)</code></pre><pre><code class="lang-c3">fn bool in_range(char c, char start, char len)</code></pre><pre><code class="lang-c3">macro bool in_range_m(c, start, len)</code></pre><pre><code class="lang-c3">fn bool is_alnum(char c)</code></pre><pre><code class="lang-c3">macro bool is_alnum_m(c)</code></pre><pre><code class="lang-c3">fn bool is_alpha(char c)</code></pre><pre><code class="lang-c3">macro bool is_alpha_m(c)</code></pre><pre><code class="lang-c3">fn bool is_bdigit(char c)</code></pre><pre><code class="lang-c3">macro bool is_bdigit_m(c)</code></pre><pre><code class="lang-c3">fn bool is_blank(char c)</code></pre><pre><code class="lang-c3">macro bool is_blank_m(c)</code></pre><pre><code class="lang-c3">fn bool is_cntrl(char c)</code></pre><pre><code class="lang-c3">macro bool is_cntrl_m(c)</code></pre><pre><code class="lang-c3">fn bool is_digit(char c)</code></pre><pre><code class="lang-c3">macro bool is_digit_m(c)</code></pre><pre><code class="lang-c3">fn bool is_graph(char c)</code></pre><pre><code class="lang-c3">macro bool is_graph_m(c)</code></pre><pre><code class="lang-c3">fn bool is_lower(char c)</code></pre><pre><code class="lang-c3">macro bool is_lower_m(c)</code></pre><pre><code class="lang-c3">fn bool is_odigit(char c)</code></pre><pre><code class="lang-c3">macro bool is_odigit_m(c)</code></pre><pre><code class="lang-c3">fn bool is_print(char c)</code></pre><pre><code class="lang-c3">macro bool is_print_m(c)</code></pre><pre><code class="lang-c3">fn bool is_punct(char c)</code></pre><pre><code class="lang-c3">macro bool is_punct_m(c)</code></pre><pre><code class="lang-c3">fn bool is_space(char c)</code></pre><pre><code class="lang-c3">macro bool is_space_m(c)</code></pre><pre><code class="lang-c3">fn bool is_upper(char c)</code></pre><pre><code class="lang-c3">macro bool is_upper_m(c)</code></pre><pre><code class="lang-c3">fn bool is_xdigit(char c)</code></pre><pre><code class="lang-c3">macro bool is_xdigit_m(c)</code></pre><pre><code class="lang-c3">fn char to_lower(char c)</code></pre><pre><code class="lang-c3">macro to_lower_m(c)</code></pre><pre><code class="lang-c3">fn char to_upper(char c)</code></pre><pre><code class="lang-c3">macro to_upper_m(c)</code></pre><pre><code class="lang-c3">fn bool uint.in_range(uint c, uint start, uint len)</code></pre><pre><code class="lang-c3">fn bool uint.is_alnum(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_alpha(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_bdigit(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_blank(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_cntrl(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_digit(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_graph(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_lower(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_odigit(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_print(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_punct(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_space(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_upper(uint c)</code></pre><pre><code class="lang-c3">fn bool uint.is_xdigit(uint c)</code></pre><pre><code class="lang-c3">fn uint uint.to_lower(uint c)</code></pre><pre><code class="lang-c3">fn uint uint.to_upper(uint c)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdatomic">std::atomic</h3><pre><code class="lang-c3">macro @__atomic_compare_exchange_ordering_failure(ptr, expected, desired, $success, failure, $alignment)</code></pre><pre><code class="lang-c3">macro @__atomic_compare_exchange_ordering_success(ptr, expected, desired, success, failure, $alignment)</code></pre><pre><code class="lang-c3">fn CInt __atomic_compare_exchange(CInt size, any ptr, any expected, any desired, CInt success, CInt failure) @extern(<span class="string">"__atomic_compare_exchange"</span>) @export</code></pre><pre><code class="lang-c3">macro fetch_add(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">macro fetch_and(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">macro fetch_div(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro fetch_max(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">macro fetch_min(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">macro fetch_mul(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro fetch_or(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">macro fetch_shift_left(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro fetch_shift_right(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro fetch_sub(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">macro fetch_xor(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">macro flag_clear(ptr, AtomicOrdering $ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro flag_set(ptr, AtomicOrdering $ordering = SEQ_CONSISTENT)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdatomictypestype">std::atomic::types(&lt;Type&gt;)</h3><pre><code class="lang-c3">struct Atomic</code></pre><pre><code class="lang-c3">macro Type Atomic.add(&amp;self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro Type Atomic.and(&amp;self, uint value, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))</code></pre><pre><code class="lang-c3">macro Type Atomic.div(&amp;self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro Type Atomic.load(&amp;self, AtomicOrdering ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro Type Atomic.max(&amp;self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro Type Atomic.min(&amp;self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro Type Atomic.mul(&amp;self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro Type Atomic.or(&amp;self, uint value, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))</code></pre><pre><code class="lang-c3">macro Type Atomic.shift_left(&amp;self, uint amount, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))</code></pre><pre><code class="lang-c3">macro Type Atomic.shift_right(&amp;self, uint amount, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))</code></pre><pre><code class="lang-c3">macro void Atomic.store(&amp;self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro Type Atomic.sub(&amp;self, Type value, AtomicOrdering ordering = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">fn Type Atomic.xor(&amp;self, uint value, AtomicOrdering ordering = SEQ_CONSISTENT) @if(!types::is_float(Type))</code></pre><h3 id="pre-conditions-for-macros-stdio-stdbits">std::bits</h3><pre><code class="lang-c3">macro bswap(i) @builtin</code></pre><pre><code class="lang-c3">macro char.clz(self)</code></pre><pre><code class="lang-c3">macro char.ctz(self)</code></pre><pre><code class="lang-c3">macro char char.fshl(hi, char lo, char shift)</code></pre><pre><code class="lang-c3">macro char char.fshr(hi, char lo, char shift)</code></pre><pre><code class="lang-c3">macro char.popcount(self)</code></pre><pre><code class="lang-c3">macro char char.rotl(self, char shift)</code></pre><pre><code class="lang-c3">macro char char.rotr(self, char shift)</code></pre><pre><code class="lang-c3">macro char[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro char[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro char[&lt;*&gt;] char[&lt;*&gt;].fshl(hi, char[&lt;*&gt;] lo, char[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro char[&lt;*&gt;] char[&lt;*&gt;].fshr(hi, char[&lt;*&gt;] lo, char[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro char[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro char[&lt;*&gt;] char[&lt;*&gt;].rotl(self, char[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro char[&lt;*&gt;] char[&lt;*&gt;].rotr(self, char[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ichar.clz(self)</code></pre><pre><code class="lang-c3">macro ichar.ctz(self)</code></pre><pre><code class="lang-c3">macro ichar ichar.fshl(hi, ichar lo, ichar shift)</code></pre><pre><code class="lang-c3">macro ichar ichar.fshr(hi, ichar lo, ichar shift)</code></pre><pre><code class="lang-c3">macro ichar.popcount(self)</code></pre><pre><code class="lang-c3">macro ichar ichar.rotl(self, ichar shift)</code></pre><pre><code class="lang-c3">macro ichar ichar.rotr(self, ichar shift)</code></pre><pre><code class="lang-c3">macro ichar[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro ichar[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro ichar[&lt;*&gt;] ichar[&lt;*&gt;].fshl(hi, ichar[&lt;*&gt;] lo, ichar[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ichar[&lt;*&gt;] ichar[&lt;*&gt;].fshr(hi, ichar[&lt;*&gt;] lo, ichar[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ichar[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro ichar[&lt;*&gt;] ichar[&lt;*&gt;].rotl(self, ichar[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ichar[&lt;*&gt;] ichar[&lt;*&gt;].rotr(self, ichar[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro int.clz(self)</code></pre><pre><code class="lang-c3">macro int.ctz(self)</code></pre><pre><code class="lang-c3">macro int int.fshl(hi, int lo, int shift)</code></pre><pre><code class="lang-c3">macro int int.fshr(hi, int lo, int shift)</code></pre><pre><code class="lang-c3">macro int.popcount(self)</code></pre><pre><code class="lang-c3">macro int int.rotl(self, int shift)</code></pre><pre><code class="lang-c3">macro int int.rotr(self, int shift)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>.clz(self)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>.ctz(self)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>.fshl(hi, int<span class="number">128</span> lo, int<span class="number">128</span> shift)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>.fshr(hi, int<span class="number">128</span> lo, int<span class="number">128</span> shift)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>.popcount(self)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>.rotl(self, int<span class="number">128</span> shift)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>.rotr(self, int<span class="number">128</span> shift)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].fshl(hi, int<span class="number">128</span>[&lt;*&gt;] lo, int<span class="number">128</span>[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].fshr(hi, int<span class="number">128</span>[&lt;*&gt;] lo, int<span class="number">128</span>[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].rotl(self, int<span class="number">128</span>[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].rotr(self, int<span class="number">128</span>[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro int[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro int[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro int[&lt;*&gt;] int[&lt;*&gt;].fshl(hi, int[&lt;*&gt;] lo, int[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro int[&lt;*&gt;] int[&lt;*&gt;].fshr(hi, int[&lt;*&gt;] lo, int[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro int[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro int[&lt;*&gt;] int[&lt;*&gt;].rotl(self, int[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro int[&lt;*&gt;] int[&lt;*&gt;].rotr(self, int[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro long.clz(self)</code></pre><pre><code class="lang-c3">macro long.ctz(self)</code></pre><pre><code class="lang-c3">macro long long.fshl(hi, long lo, long shift)</code></pre><pre><code class="lang-c3">macro long long.fshr(hi, long lo, long shift)</code></pre><pre><code class="lang-c3">macro long.popcount(self)</code></pre><pre><code class="lang-c3">macro long long.rotl(self, long shift)</code></pre><pre><code class="lang-c3">macro long long.rotr(self, long shift)</code></pre><pre><code class="lang-c3">macro long[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro long[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro long[&lt;*&gt;] long[&lt;*&gt;].fshl(hi, long[&lt;*&gt;] lo, long[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro long[&lt;*&gt;] long[&lt;*&gt;].fshr(hi, long[&lt;*&gt;] lo, long[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro long[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro long[&lt;*&gt;] long[&lt;*&gt;].rotl(self, long[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro long[&lt;*&gt;] long[&lt;*&gt;].rotr(self, long[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro reverse(i)</code></pre><pre><code class="lang-c3">macro short.clz(self)</code></pre><pre><code class="lang-c3">macro short.ctz(self)</code></pre><pre><code class="lang-c3">macro short short.fshl(hi, short lo, short shift)</code></pre><pre><code class="lang-c3">macro short short.fshr(hi, short lo, short shift)</code></pre><pre><code class="lang-c3">macro short.popcount(self)</code></pre><pre><code class="lang-c3">macro short short.rotl(self, short shift)</code></pre><pre><code class="lang-c3">macro short short.rotr(self, short shift)</code></pre><pre><code class="lang-c3">macro short[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro short[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro short[&lt;*&gt;] short[&lt;*&gt;].fshl(hi, short[&lt;*&gt;] lo, short[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro short[&lt;*&gt;] short[&lt;*&gt;].fshr(hi, short[&lt;*&gt;] lo, short[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro short[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro short[&lt;*&gt;] short[&lt;*&gt;].rotl(self, short[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro short[&lt;*&gt;] short[&lt;*&gt;].rotr(self, short[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro uint.clz(self)</code></pre><pre><code class="lang-c3">macro uint.ctz(self)</code></pre><pre><code class="lang-c3">macro uint uint.fshl(hi, uint lo, uint shift)</code></pre><pre><code class="lang-c3">macro uint uint.fshr(hi, uint lo, uint shift)</code></pre><pre><code class="lang-c3">macro uint.popcount(self)</code></pre><pre><code class="lang-c3">macro uint uint.rotl(self, uint shift)</code></pre><pre><code class="lang-c3">macro uint uint.rotr(self, uint shift)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>.clz(self)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>.ctz(self)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>.fshl(hi, uint<span class="number">128</span> lo, uint<span class="number">128</span> shift)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>.fshr(hi, uint<span class="number">128</span> lo, uint<span class="number">128</span> shift)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>.popcount(self)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>.rotl(self, uint<span class="number">128</span> shift)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>.rotr(self, uint<span class="number">128</span> shift)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].fshl(hi, uint<span class="number">128</span>[&lt;*&gt;] lo, uint<span class="number">128</span>[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].fshr(hi, uint<span class="number">128</span>[&lt;*&gt;] lo, uint<span class="number">128</span>[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].rotl(self, uint<span class="number">128</span>[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].rotr(self, uint<span class="number">128</span>[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro uint[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro uint[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro uint[&lt;*&gt;] uint[&lt;*&gt;].fshl(hi, uint[&lt;*&gt;] lo, uint[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro uint[&lt;*&gt;] uint[&lt;*&gt;].fshr(hi, uint[&lt;*&gt;] lo, uint[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro uint[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro uint[&lt;*&gt;] uint[&lt;*&gt;].rotl(self, uint[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro uint[&lt;*&gt;] uint[&lt;*&gt;].rotr(self, uint[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ulong.clz(self)</code></pre><pre><code class="lang-c3">macro ulong.ctz(self)</code></pre><pre><code class="lang-c3">macro ulong ulong.fshl(hi, ulong lo, ulong shift)</code></pre><pre><code class="lang-c3">macro ulong ulong.fshr(hi, ulong lo, ulong shift)</code></pre><pre><code class="lang-c3">macro ulong.popcount(self)</code></pre><pre><code class="lang-c3">macro ulong ulong.rotl(self, ulong shift)</code></pre><pre><code class="lang-c3">macro ulong ulong.rotr(self, ulong shift)</code></pre><pre><code class="lang-c3">macro ulong[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro ulong[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro ulong[&lt;*&gt;] ulong[&lt;*&gt;].fshl(hi, ulong[&lt;*&gt;] lo, ulong[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ulong[&lt;*&gt;] ulong[&lt;*&gt;].fshr(hi, ulong[&lt;*&gt;] lo, ulong[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ulong[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro ulong[&lt;*&gt;] ulong[&lt;*&gt;].rotl(self, ulong[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ulong[&lt;*&gt;] ulong[&lt;*&gt;].rotr(self, ulong[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ushort.clz(self)</code></pre><pre><code class="lang-c3">macro ushort.ctz(self)</code></pre><pre><code class="lang-c3">macro ushort ushort.fshl(hi, ushort lo, ushort shift)</code></pre><pre><code class="lang-c3">macro ushort ushort.fshr(hi, ushort lo, ushort shift)</code></pre><pre><code class="lang-c3">macro ushort.popcount(self)</code></pre><pre><code class="lang-c3">macro ushort ushort.rotl(self, ushort shift)</code></pre><pre><code class="lang-c3">macro ushort ushort.rotr(self, ushort shift)</code></pre><pre><code class="lang-c3">macro ushort[&lt;*&gt;].clz(self)</code></pre><pre><code class="lang-c3">macro ushort[&lt;*&gt;].ctz(self)</code></pre><pre><code class="lang-c3">macro ushort[&lt;*&gt;] ushort[&lt;*&gt;].fshl(hi, ushort[&lt;*&gt;] lo, ushort[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ushort[&lt;*&gt;] ushort[&lt;*&gt;].fshr(hi, ushort[&lt;*&gt;] lo, ushort[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ushort[&lt;*&gt;].popcount(self)</code></pre><pre><code class="lang-c3">macro ushort[&lt;*&gt;] ushort[&lt;*&gt;].rotl(self, ushort[&lt;*&gt;] shift)</code></pre><pre><code class="lang-c3">macro ushort[&lt;*&gt;] ushort[&lt;*&gt;].rotr(self, ushort[&lt;*&gt;] shift)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsanylist">std::collections::anylist</h3><pre><code class="lang-c3">struct AnyList (Printable)</code></pre><pre><code class="lang-c3">macro any AnyList.@item_at(&amp;self, usz index) @operator([])</code></pre><pre><code class="lang-c3">fn void AnyList.add_all(&amp;self, AnyList* other_list)</code></pre><pre><code class="lang-c3">fn any[] AnyList.array_view(&amp;self)</code></pre><pre><code class="lang-c3">fn void AnyList.clear(&amp;self)</code></pre><pre><code class="lang-c3">macro AnyList.first(&amp;self, $Type)</code></pre><pre><code class="lang-c3">fn any! AnyList.first_any(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn void AnyList.free(&amp;self)</code></pre><pre><code class="lang-c3">fn void AnyList.free_element(&amp;self, any element) @inline</code></pre><pre><code class="lang-c3">macro AnyList.get(&amp;self, usz index, $Type)</code></pre><pre><code class="lang-c3">fn any AnyList.get_any(&amp;self, usz index) @inline</code></pre><pre><code class="lang-c3">fn bool AnyList.is_empty(&amp;self) @inline</code></pre><pre><code class="lang-c3">macro AnyList.last(&amp;self, $Type)</code></pre><pre><code class="lang-c3">fn any! AnyList.last_any(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn usz AnyList.len(&amp;self) @operator(len) @inline</code></pre><pre><code class="lang-c3">fn AnyList* AnyList.new_init(&amp;self, usz initial_capacity = <span class="number">16</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn any! AnyList.new_pop(&amp;self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn any! AnyList.new_pop_first(&amp;self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">macro AnyList.pop(&amp;self, $Type)</code></pre><pre><code class="lang-c3">macro AnyList.pop_first(&amp;self, $Type)</code></pre><pre><code class="lang-c3">fn any! AnyList.pop_first_retained(&amp;self)</code></pre><pre><code class="lang-c3">fn any! AnyList.pop_retained(&amp;self)</code></pre><pre><code class="lang-c3">macro void AnyList.push(&amp;self, element)</code></pre><pre><code class="lang-c3">macro void AnyList.push_front(&amp;self, type)</code></pre><pre><code class="lang-c3">fn void AnyList.remove_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn void AnyList.remove_first(&amp;self)</code></pre><pre><code class="lang-c3">fn usz AnyList.remove_if(&amp;self, AnyPredicate filter)</code></pre><pre><code class="lang-c3">fn void AnyList.remove_last(&amp;self)</code></pre><pre><code class="lang-c3">fn usz AnyList.remove_using_test(&amp;self, AnyTest filter, any context)</code></pre><pre><code class="lang-c3">fn void AnyList.reserve(&amp;self, usz min_capacity)</code></pre><pre><code class="lang-c3">fn usz AnyList.retain_if(&amp;self, AnyPredicate selection)</code></pre><pre><code class="lang-c3">fn usz AnyList.retain_using_test(&amp;self, AnyTest filter, any context)</code></pre><pre><code class="lang-c3">fn void AnyList.reverse(&amp;self)</code></pre><pre><code class="lang-c3">macro void AnyList.set(&amp;self, usz index, value)</code></pre><pre><code class="lang-c3">fn void AnyList.swap(&amp;self, usz i, usz j)</code></pre><pre><code class="lang-c3">fn AnyList* AnyList.temp_init(&amp;self, usz initial_capacity = <span class="number">16</span>)</code></pre><pre><code class="lang-c3">fn any! AnyList.temp_pop(&amp;self)</code></pre><pre><code class="lang-c3">fn any! AnyList.temp_pop_first(&amp;self)</code></pre><pre><code class="lang-c3">fn usz! AnyList.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn String AnyList.to_new_string(&amp;self, Allocator allocator = allocator::heap()) @dynamic</code></pre><pre><code class="lang-c3">fn String AnyList.to_tstring(&amp;self)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsbitsetsize">std::collections::bitset(&lt;SIZE&gt;)</h3><pre><code class="lang-c3">struct BitSet</code></pre><pre><code class="lang-c3">fn usz BitSet.cardinality(&amp;self)</code></pre><pre><code class="lang-c3">fn bool BitSet.get(&amp;self, usz i) @operator([]) @inline</code></pre><pre><code class="lang-c3">fn usz BitSet.len(&amp;self) @operator(len) @inline</code></pre><pre><code class="lang-c3">fn void BitSet.set(&amp;self, usz i)</code></pre><pre><code class="lang-c3">fn void BitSet.set_bool(&amp;self, usz i, bool value) @operator([]=) @inline</code></pre><pre><code class="lang-c3">fn void BitSet.unset(&amp;self, usz i)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsenummapenum-valuetype">std::collections::enummap(&lt;Enum, ValueType&gt;)</h3><pre><code class="lang-c3">struct EnumMap (Printable)</code></pre><pre><code class="lang-c3">fn ValueType EnumMap.get(&amp;self, Enum key) @operator([]) @inline</code></pre><pre><code class="lang-c3">fn ValueType* EnumMap.get_ref(&amp;self, Enum key) @operator(&amp;[]) @inline</code></pre><pre><code class="lang-c3">fn void EnumMap.init(&amp;self, ValueType init_value)</code></pre><pre><code class="lang-c3">fn usz EnumMap.len(&amp;self) @operator(len) @inline</code></pre><pre><code class="lang-c3">fn void EnumMap.set(&amp;self, Enum key, ValueType value) @operator([]=) @inline</code></pre><pre><code class="lang-c3">fn usz! EnumMap.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn String EnumMap.to_new_string(&amp;self, Allocator allocator = allocator::heap()) @dynamic</code></pre><pre><code class="lang-c3">fn String EnumMap.to_tstring(&amp;self) @dynamic</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsenumsetenum">std::collections::enumset(&lt;Enum&gt;)</h3><pre><code class="lang-c3">distinct EnumSet (Printable) = EnumSetType;</code></pre><pre><code class="lang-c3">fn void EnumSet.add(&amp;self, Enum v)</code></pre><pre><code class="lang-c3">fn void EnumSet.add_all(&amp;self, EnumSet s)</code></pre><pre><code class="lang-c3">fn EnumSet EnumSet.and_of(&amp;self, EnumSet s)</code></pre><pre><code class="lang-c3">fn void EnumSet.clear(&amp;self)</code></pre><pre><code class="lang-c3">fn EnumSet EnumSet.diff_of(&amp;self, EnumSet s)</code></pre><pre><code class="lang-c3">fn bool EnumSet.has(&amp;self, Enum v)</code></pre><pre><code class="lang-c3">fn EnumSet EnumSet.or_of(&amp;self, EnumSet s)</code></pre><pre><code class="lang-c3">fn bool EnumSet.remove(&amp;self, Enum v)</code></pre><pre><code class="lang-c3">fn void EnumSet.remove_all(&amp;self, EnumSet s)</code></pre><pre><code class="lang-c3">fn void EnumSet.retain_all(&amp;self, EnumSet s)</code></pre><pre><code class="lang-c3">fn usz! EnumSet.to_format(&amp;set, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn String EnumSet.to_new_string(&amp;set, Allocator allocator = allocator::heap()) @dynamic</code></pre><pre><code class="lang-c3">fn String EnumSet.to_tstring(&amp;set) @dynamic</code></pre><pre><code class="lang-c3">fn EnumSet EnumSet.xor_of(&amp;self, EnumSet s)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsenumsetprivate">std::collections::enumset::private</h3><pre><code class="lang-c3">macro typeid type_for_enum_elements(usz $elements)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsgrowablebitsettype">std::collections::growablebitset(&lt;Type&gt;)</h3><pre><code class="lang-c3">struct GrowableBitSet</code></pre><pre><code class="lang-c3">fn usz GrowableBitSet.cardinality(&amp;self)</code></pre><pre><code class="lang-c3">fn void GrowableBitSet.free(&amp;self)</code></pre><pre><code class="lang-c3">fn bool GrowableBitSet.get(&amp;self, usz i) @operator([]) @inline</code></pre><pre><code class="lang-c3">fn usz GrowableBitSet.len(&amp;self) @operator(len)</code></pre><pre><code class="lang-c3">fn GrowableBitSet* GrowableBitSet.new_init(&amp;self, usz initial_capacity = <span class="number">1</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn void GrowableBitSet.set(&amp;self, usz i)</code></pre><pre><code class="lang-c3">fn void GrowableBitSet.set_bool(&amp;self, usz i, bool value) @operator([]=) @inline</code></pre><pre><code class="lang-c3">fn GrowableBitSet* GrowableBitSet.temp_init(&amp;self, usz initial_capacity = <span class="number">1</span>)</code></pre><pre><code class="lang-c3">fn void GrowableBitSet.unset(&amp;self, usz i)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionslinkedlisttype">std::collections::linkedlist(&lt;Type&gt;)</h3><pre><code class="lang-c3">struct LinkedList</code></pre><pre><code class="lang-c3">fn void LinkedList.clear(&amp;self)</code></pre><pre><code class="lang-c3">fn Type! LinkedList.first(&amp;self)</code></pre><pre><code class="lang-c3">fn void LinkedList.free(&amp;self)</code></pre><pre><code class="lang-c3">fn Type LinkedList.get(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn void LinkedList.insert_at(&amp;self, usz index, Type element)</code></pre><pre><code class="lang-c3">fn Type! LinkedList.last(&amp;self)</code></pre><pre><code class="lang-c3">fn usz LinkedList.len(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn LinkedList* LinkedList.new_init(&amp;self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">macro Node* LinkedList.node_at_index(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn Type! LinkedList.peek(&amp;self)</code></pre><pre><code class="lang-c3">fn Type! LinkedList.peek_last(&amp;self)</code></pre><pre><code class="lang-c3">fn Type! LinkedList.pop(&amp;self)</code></pre><pre><code class="lang-c3">fn Type! LinkedList.pop_front(&amp;self)</code></pre><pre><code class="lang-c3">fn void LinkedList.push(&amp;self, Type value)</code></pre><pre><code class="lang-c3">fn void LinkedList.push_front(&amp;self, Type value)</code></pre><pre><code class="lang-c3">fn usz LinkedList.remove(&amp;self, Type t) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn void LinkedList.remove_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn void! LinkedList.remove_first(&amp;self) @maydiscard</code></pre><pre><code class="lang-c3">fn bool LinkedList.remove_first_match(&amp;self, Type t) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn void! LinkedList.remove_last(&amp;self) @maydiscard</code></pre><pre><code class="lang-c3">fn bool LinkedList.remove_last_match(&amp;self, Type t)  @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn void LinkedList.set(&amp;self, usz index, Type element)</code></pre><pre><code class="lang-c3">fn LinkedList* LinkedList.temp_init(&amp;self)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionslisttype">std::collections::list(&lt;Type&gt;)</h3><pre><code class="lang-c3">struct List (Printable)</code></pre><pre><code class="lang-c3">macro Type List.@item_at(&amp;self, usz index) @operator([])</code></pre><pre><code class="lang-c3">fn void List.add_all(&amp;self, List* other_list)</code></pre><pre><code class="lang-c3">fn void List.add_array(&amp;self, Type[] array)</code></pre><pre><code class="lang-c3">fn Type[] List.array_view(&amp;self)</code></pre><pre><code class="lang-c3">fn usz List.byte_size(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn void List.clear(&amp;self)</code></pre><pre><code class="lang-c3">fn usz List.compact(&amp;self) @if(ELEMENT_IS_POINTER)</code></pre><pre><code class="lang-c3">fn usz List.compact_count(&amp;self) @if(ELEMENT_IS_POINTER)</code></pre><pre><code class="lang-c3">fn bool List.contains(&amp;self, Type value) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn bool List.equals(&amp;self, List other_list) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn Type! List.first(&amp;self)</code></pre><pre><code class="lang-c3">fn void List.free(&amp;self)</code></pre><pre><code class="lang-c3">fn Type List.get(&amp;self, usz index) @inline</code></pre><pre><code class="lang-c3">fn Type* List.get_ref(&amp;self, usz index) @operator(&amp;[]) @inline</code></pre><pre><code class="lang-c3">fn usz! List.index_of(&amp;self, Type type) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn void List.init_wrapping_array(&amp;self, Type[] types, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn void List.insert_at(&amp;self, usz index, Type type)</code></pre><pre><code class="lang-c3">fn bool List.is_empty(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn Type! List.last(&amp;self)</code></pre><pre><code class="lang-c3">fn usz List.len(&amp;self) @operator(len) @inline</code></pre><pre><code class="lang-c3">fn List* List.new_init(&amp;self, usz initial_capacity = <span class="number">16</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Type! List.pop(&amp;self)</code></pre><pre><code class="lang-c3">fn Type! List.pop_first(&amp;self)</code></pre><pre><code class="lang-c3">fn void List.push(&amp;self, Type element) @inline</code></pre><pre><code class="lang-c3">fn void List.push_front(&amp;self, Type type) @inline</code></pre><pre><code class="lang-c3">fn void List.remove_all_from(&amp;self, List* other_list) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn usz List.remove_all_matches(&amp;self, Type value) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn void List.remove_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn void! List.remove_first(&amp;self) @maydiscard</code></pre><pre><code class="lang-c3">fn bool List.remove_first_match(&amp;self, Type value) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn usz List.remove_if(&amp;self, ElementPredicate filter)</code></pre><pre><code class="lang-c3">fn void! List.remove_last(&amp;self) @maydiscard</code></pre><pre><code class="lang-c3">fn bool List.remove_last_match(&amp;self, Type value) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn usz List.remove_using_test(&amp;self, ElementTest filter, any context)</code></pre><pre><code class="lang-c3">fn void List.reserve(&amp;self, usz min_capacity)</code></pre><pre><code class="lang-c3">fn usz List.retain_if(&amp;self, ElementPredicate selection)</code></pre><pre><code class="lang-c3">fn usz List.retain_using_test(&amp;self, ElementTest filter, any context)</code></pre><pre><code class="lang-c3">fn void List.reverse(&amp;self)</code></pre><pre><code class="lang-c3">fn usz! List.rindex_of(&amp;self, Type type) @if(ELEMENT_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn void List.set(&amp;self, usz index, Type value) @operator([]=)</code></pre><pre><code class="lang-c3">fn void List.set_at(&amp;self, usz index, Type type)</code></pre><pre><code class="lang-c3">fn void List.swap(&amp;self, usz i, usz j)</code></pre><pre><code class="lang-c3">fn List* List.temp_init(&amp;self, usz initial_capacity = <span class="number">16</span>)</code></pre><pre><code class="lang-c3">fn usz! List.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn Type[] List.to_new_array(&amp;self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String List.to_new_string(&amp;self, Allocator allocator = allocator::heap()) @dynamic</code></pre><pre><code class="lang-c3">fn Type[] List.to_tarray(&amp;self)</code></pre><pre><code class="lang-c3">fn String List.to_tstring(&amp;self)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsmapkey-value">std::collections::map(&lt;Key, Value&gt;)</h3><pre><code class="lang-c3">struct Entry</code></pre><pre><code class="lang-c3">struct HashMap</code></pre><pre><code class="lang-c3">macro HashMap.@each(map; @body(key, value))</code></pre><pre><code class="lang-c3">macro HashMap.@each_entry(map; @body(entry))</code></pre><pre><code class="lang-c3">macro Value HashMap.@get_or_set(&amp;map, Key key, Value <span class="comment">#expr)</span></code></pre><pre><code class="lang-c3">fn void HashMap.clear(&amp;map)</code></pre><pre><code class="lang-c3">fn void HashMap.free(&amp;map)</code></pre><pre><code class="lang-c3">fn Value! HashMap.get(&amp;map, Key key) @operator([])</code></pre><pre><code class="lang-c3">fn Entry*! HashMap.get_entry(&amp;map, Key key)</code></pre><pre><code class="lang-c3">fn Value*! HashMap.get_ref(&amp;map, Key key)</code></pre><pre><code class="lang-c3">fn bool HashMap.has_key(&amp;map, Key key)</code></pre><pre><code class="lang-c3">fn bool HashMap.has_value(&amp;map, Value v) @if(VALUE_IS_EQUATABLE)</code></pre><pre><code class="lang-c3">fn bool HashMap.is_empty(&amp;map) @inline</code></pre><pre><code class="lang-c3">fn bool HashMap.is_initialized(&amp;map)</code></pre><pre><code class="lang-c3">fn Key[] HashMap.key_new_list(&amp;map, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Key[] HashMap.key_tlist(&amp;map)</code></pre><pre><code class="lang-c3">fn usz HashMap.len(&amp;map) @inline</code></pre><pre><code class="lang-c3">fn HashMap* HashMap.new_init(&amp;self, uint capacity = DEFAULT_INITIAL_CAPACITY, float load_factor = DEFAULT_LOAD_FACTOR, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn HashMap* HashMap.new_init_from_map(&amp;self, HashMap* other_map, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn void! HashMap.remove(&amp;map, Key key) @maydiscard</code></pre><pre><code class="lang-c3">fn bool HashMap.set(&amp;map, Key key, Value value) @operator([]=)</code></pre><pre><code class="lang-c3">fn HashMap* HashMap.temp_init(&amp;self, uint capacity = DEFAULT_INITIAL_CAPACITY, float load_factor = DEFAULT_LOAD_FACTOR)</code></pre><pre><code class="lang-c3">fn HashMap* HashMap.temp_init_from_map(&amp;map, HashMap* other_map)</code></pre><pre><code class="lang-c3">fn Value[] HashMap.value_new_list(&amp;map, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Value[] HashMap.value_tlist(&amp;map)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsmaybetype">std::collections::maybe(&lt;Type&gt;)</h3><pre><code class="lang-c3">struct Maybe</code></pre><pre><code class="lang-c3">macro Type! Maybe.get(self)</code></pre><pre><code class="lang-c3">fn Maybe value(Type val)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsobject">std::collections::object</h3><pre><code class="lang-c3">struct Object (Printable)</code></pre><pre><code class="lang-c3">fn void Object.free(&amp;self)</code></pre><pre><code class="lang-c3">fn Object*! Object.get(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn Object* Object.get_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn bool! Object.get_bool(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn bool! Object.get_bool_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn char! Object.get_char(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn char! Object.get_char_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">macro String! Object.get_enum(&amp;self, $EnumType, String key)</code></pre><pre><code class="lang-c3">macro String! Object.get_enum_at(&amp;self, $EnumType, usz index)</code></pre><pre><code class="lang-c3">fn double! Object.get_float(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn double! Object.get_float_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn ichar! Object.get_ichar(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn ichar! Object.get_ichar_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn int! Object.get_int(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span>! Object.get_int<span class="number">128</span>(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span>! Object.get_int<span class="number">128</span>_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn int! Object.get_int_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn usz Object.get_len(&amp;self)</code></pre><pre><code class="lang-c3">fn long! Object.get_long(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn long! Object.get_long_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn Object* Object.get_or_create_obj(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn short! Object.get_short(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn short! Object.get_short_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn String! Object.get_string(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn String! Object.get_string_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn uint! Object.get_uint(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span>! Object.get_uint<span class="number">128</span>(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span>! Object.get_uint<span class="number">128</span>_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn uint! Object.get_uint_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn ulong! Object.get_ulong(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn ulong! Object.get_ulong_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn short! Object.get_ushort(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn ushort! Object.get_ushort_at(&amp;self, usz index)</code></pre><pre><code class="lang-c3">fn bool Object.has_key(&amp;self, String key)</code></pre><pre><code class="lang-c3">fn bool Object.is_array(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn bool Object.is_bool(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn bool Object.is_empty(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn bool Object.is_float(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn bool Object.is_indexable(&amp;self)</code></pre><pre><code class="lang-c3">fn bool Object.is_int(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn bool Object.is_keyable(&amp;self)</code></pre><pre><code class="lang-c3">fn bool Object.is_map(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn bool Object.is_null(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn bool Object.is_string(&amp;self) @inline</code></pre><pre><code class="lang-c3">macro Object* Object.push(&amp;self, value)</code></pre><pre><code class="lang-c3">fn void Object.push_object(&amp;self, Object* to_append)</code></pre><pre><code class="lang-c3">macro Object* Object.set(&amp;self, String key, value)</code></pre><pre><code class="lang-c3">macro Object* Object.set_at(&amp;self, usz index, String key, value)</code></pre><pre><code class="lang-c3">fn void Object.set_object_at(&amp;self, usz index, Object* to_set)</code></pre><pre><code class="lang-c3">fn usz! Object.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">macro get_integer_value(Object* value, $Type)</code></pre><pre><code class="lang-c3">fn Object* new_bool(bool b)</code></pre><pre><code class="lang-c3">macro Object* new_enum(e, Allocator allocator)</code></pre><pre><code class="lang-c3">fn Object* new_float(double f, Allocator allocator)</code></pre><pre><code class="lang-c3">fn Object* new_int(int<span class="number">128</span> i, Allocator allocator)</code></pre><pre><code class="lang-c3">fn Object* new_null()</code></pre><pre><code class="lang-c3">fn Object* new_obj(Allocator allocator)</code></pre><pre><code class="lang-c3">fn Object* new_string(String s, Allocator allocator)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionspriorityqueuetype">std::collections::priorityqueue(&lt;Type&gt;)</h3><pre><code class="lang-c3">distinct PriorityQueue = inline PrivatePriorityQueue(&lt;Type, false&gt;);</code></pre><pre><code class="lang-c3">distinct PriorityQueueMax = inline PrivatePriorityQueue(&lt;Type, true&gt;);</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionspriorityqueueprivatetype-max">std::collections::priorityqueue::private(&lt;Type, MAX&gt;)</h3><pre><code class="lang-c3">struct PrivatePriorityQueue (Printable)</code></pre><pre><code class="lang-c3">fn Type! PrivatePriorityQueue.first(&amp;self)</code></pre><pre><code class="lang-c3">fn void PrivatePriorityQueue.free(&amp;self)</code></pre><pre><code class="lang-c3">fn Type PrivatePriorityQueue.get(&amp;self, usz index) @operator([])</code></pre><pre><code class="lang-c3">fn bool PrivatePriorityQueue.is_empty(&amp;self)</code></pre><pre><code class="lang-c3">fn usz PrivatePriorityQueue.len(&amp;self) @operator(len)</code></pre><pre><code class="lang-c3">fn void PrivatePriorityQueue.new_init(&amp;self, usz initial_capacity = <span class="number">16</span>, Allocator allocator = allocator::heap()) @inline</code></pre><pre><code class="lang-c3">fn Type! PrivatePriorityQueue.pop(&amp;self)</code></pre><pre><code class="lang-c3">fn void PrivatePriorityQueue.push(&amp;self, Type element)</code></pre><pre><code class="lang-c3">fn void PrivatePriorityQueue.temp_init(&amp;self, usz initial_capacity = <span class="number">16</span>) @inline</code></pre><pre><code class="lang-c3">fn usz! PrivatePriorityQueue.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn String PrivatePriorityQueue.to_new_string(&amp;self, Allocator allocator = allocator::heap()) @dynamic</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsrangetype">std::collections::range(&lt;Type&gt;)</h3><pre><code class="lang-c3">struct ExclusiveRange (Printable)</code></pre><pre><code class="lang-c3">struct Range (Printable)</code></pre><pre><code class="lang-c3">fn bool ExclusiveRange.contains(&amp;self, Type value) @inline</code></pre><pre><code class="lang-c3">fn Type ExclusiveRange.get(&amp;self, usz index) @operator([])</code></pre><pre><code class="lang-c3">fn usz ExclusiveRange.len(&amp;self) @operator(len)</code></pre><pre><code class="lang-c3">fn usz! ExclusiveRange.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn String ExclusiveRange.to_new_string(&amp;self, Allocator allocator = allocator::heap()) @dynamic</code></pre><pre><code class="lang-c3">fn String ExclusiveRange.to_tstring(&amp;self)</code></pre><pre><code class="lang-c3">fn bool Range.contains(&amp;self, Type value) @inline</code></pre><pre><code class="lang-c3">fn Type Range.get(&amp;self, usz index) @operator([])</code></pre><pre><code class="lang-c3">fn usz Range.len(&amp;self) @operator(len)</code></pre><pre><code class="lang-c3">fn usz! Range.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn String Range.to_new_string(&amp;self, Allocator allocator = allocator::heap()) @dynamic</code></pre><pre><code class="lang-c3">fn String Range.to_tstring(&amp;self)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionsringbuffertype-size">std::collections::ringbuffer(&lt;Type, SIZE&gt;)</h3><pre><code class="lang-c3">struct RingBuffer</code></pre><pre><code class="lang-c3">fn Type RingBuffer.get(&amp;self, usz index) @operator([])</code></pre><pre><code class="lang-c3">fn void RingBuffer.init(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn Type! RingBuffer.pop(&amp;self)</code></pre><pre><code class="lang-c3">fn void RingBuffer.push(&amp;self, Type c)</code></pre><pre><code class="lang-c3">fn usz RingBuffer.read(&amp;self, usz index, Type[] buffer)</code></pre><pre><code class="lang-c3">fn void RingBuffer.write(&amp;self, Type[] buffer)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionstripletype1-type2-type3">std::collections::triple(&lt;Type1, Type2, Type3&gt;)</h3><pre><code class="lang-c3">struct Triple</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcollectionstupletype1-type2">std::collections::tuple(&lt;Type1, Type2&gt;)</h3><pre><code class="lang-c3">struct Tuple</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorearray">std::core::array</h3><pre><code class="lang-c3">macro concat_new(arr<span class="number">1</span>, arr<span class="number">2</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">macro index_of(array, element)</code></pre><pre><code class="lang-c3">macro rindex_of(array, element)</code></pre><pre><code class="lang-c3">macro slice<span class="number">2</span>d(array, x = <span class="number">0</span>, xlen = <span class="number">0</span>, y = <span class="number">0</span>, ylen = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">macro tconcat(arr<span class="number">1</span>, arr<span class="number">2</span>)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorearrayslicetype">std::core::array::slice(&lt;Type&gt;)</h3><pre><code class="lang-c3">struct Slice<span class="number">2</span>d</code></pre><pre><code class="lang-c3">macro void Slice<span class="number">2</span>d.@each(&amp;self; @body(usz[&lt;<span class="number">2</span>&gt;], Type))</code></pre><pre><code class="lang-c3">macro void Slice<span class="number">2</span>d.@each_ref(&amp;self; @body(usz[&lt;<span class="number">2</span>&gt;], Type*))</code></pre><pre><code class="lang-c3">fn usz Slice<span class="number">2</span>d.count(&amp;self)</code></pre><pre><code class="lang-c3">macro Type[] Slice<span class="number">2</span>d.get(self, usz idy) @operator([])</code></pre><pre><code class="lang-c3">fn usz Slice<span class="number">2</span>d.len(&amp;self) @operator(len)</code></pre><pre><code class="lang-c3">fn Slice<span class="number">2</span>d Slice<span class="number">2</span>d.slice(&amp;self, isz x = <span class="number">0</span>, isz xlen = <span class="number">0</span>, isz y = <span class="number">0</span>, isz ylen = <span class="number">0</span>)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorebitorder">std::core::bitorder</h3><pre><code class="lang-c3">macro bool is_array_or_slice_of_char(bytes)</code></pre><pre><code class="lang-c3">macro bool is_arrayptr_or_slice_of_char(bytes)</code></pre><pre><code class="lang-c3">macro is_bitorder($Type)</code></pre><pre><code class="lang-c3">macro read(bytes, $Type)</code></pre><pre><code class="lang-c3">macro write(x, bytes, $Type)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorebuiltin">std::core::builtin</h3><pre><code class="lang-c3">enum PrefetchLocality</code></pre><pre><code class="lang-c3">fault CastResult</code></pre><pre><code class="lang-c3">fault IteratorResult</code></pre><pre><code class="lang-c3">fault SearchResult</code></pre><pre><code class="lang-c3">macro char[] @as_char_view(&amp;value) @builtin</code></pre><pre><code class="lang-c3">macro anyfault @catch(<span class="comment">#expr) @builtin</span></code></pre><pre><code class="lang-c3">macro @expect(<span class="comment">#value, expected, $probability = <span class="number"><span class="number">1</span>.<span class="number">0</span></span>) @builtin</span></code></pre><pre><code class="lang-c3">macro bool @likely(bool <span class="comment">#value, $probability = <span class="number"><span class="number">1</span>.<span class="number">0</span></span>) @builtin</span></code></pre><pre><code class="lang-c3">macro bool @ok(<span class="comment">#expr) @builtin</span></code></pre><pre><code class="lang-c3">macro @prefetch(void* ptr, PrefetchLocality $locality = VERY_NEAR, bool $write = false) @builtin</code></pre><pre><code class="lang-c3">macro void @scope(&amp;variable; @body) @builtin</code></pre><pre><code class="lang-c3">macro void @swap(&amp;a, &amp;b) @builtin</code></pre><pre><code class="lang-c3">macro bool @unlikely(bool <span class="comment">#value, $probability = <span class="number"><span class="number">1</span>.<span class="number">0</span></span>) @builtin</span></code></pre><pre><code class="lang-c3">macro uint String.hash(String c)</code></pre><pre><code class="lang-c3">macro any.as_inner(&amp;self)</code></pre><pre><code class="lang-c3">macro any.retype_to(&amp;self, typeid type)</code></pre><pre><code class="lang-c3">macro any_make(void* ptr, typeid type) @builtin</code></pre><pre><code class="lang-c3">macro anycast(any v, $Type) @builtin</code></pre><pre><code class="lang-c3">macro bitcast(expr, $Type) @builtin</code></pre><pre><code class="lang-c3">macro uint bool.hash(bool b)</code></pre><pre><code class="lang-c3">macro uint char.hash(char c)</code></pre><pre><code class="lang-c3">macro uint char[].hash(char[] c)</code></pre><pre><code class="lang-c3">macro int compare_to(a, b) @builtin</code></pre><pre><code class="lang-c3">fn void default_panic(String message, String file, String function, uint line) @if(!env::NATIVE_STACKTRACE)</code></pre><pre><code class="lang-c3">fn void default_panic(String message, String file, String function, uint line) @if(env::NATIVE_STACKTRACE)</code></pre><pre><code class="lang-c3">macro enum_by_name($Type, String enum_name) @builtin</code></pre><pre><code class="lang-c3">macro bool equals(a, b) @builtin</code></pre><pre><code class="lang-c3">macro void* get_frameaddress(int n)</code></pre><pre><code class="lang-c3">macro void* get_returnaddress(int n)</code></pre><pre><code class="lang-c3">macro greater(a, b) @builtin</code></pre><pre><code class="lang-c3">macro greater_eq(a, b) @builtin</code></pre><pre><code class="lang-c3">macro uint ichar.hash(ichar c)</code></pre><pre><code class="lang-c3">macro uint int.hash(int i)</code></pre><pre><code class="lang-c3">macro uint int<span class="number">128</span>.hash(int<span class="number">128</span> i)</code></pre><pre><code class="lang-c3">macro less(a, b) @builtin</code></pre><pre><code class="lang-c3">macro less_eq(a, b) @builtin</code></pre><pre><code class="lang-c3">macro uint long.hash(long i)</code></pre><pre><code class="lang-c3">macro max(x, ...) @builtin</code></pre><pre><code class="lang-c3">macro min(x, ...) @builtin</code></pre><pre><code class="lang-c3">fn void panicf(String fmt, String file, String function, uint line, args...)</code></pre><pre><code class="lang-c3">fn bool print_backtrace(String message, int backtraces_to_ignore) @if(env::NATIVE_STACKTRACE)</code></pre><pre><code class="lang-c3">macro uint short.hash(short s)</code></pre><pre><code class="lang-c3">macro swizzle(v, ...) @builtin</code></pre><pre><code class="lang-c3">macro swizzle<span class="number">2</span>(v, v<span class="number">2</span>, ...) @builtin</code></pre><pre><code class="lang-c3">macro uint typeid.hash(typeid t)</code></pre><pre><code class="lang-c3">macro uint uint.hash(uint i)</code></pre><pre><code class="lang-c3">macro uint uint<span class="number">128</span>.hash(uint<span class="number">128</span> i)</code></pre><pre><code class="lang-c3">macro uint ulong.hash(ulong i)</code></pre><pre><code class="lang-c3">macro void unreachable(String string = <span class="string">"Unreachable statement reached."</span>, ...) @builtin @noreturn</code></pre><pre><code class="lang-c3">macro void unsupported(String string = <span class="string">"Unsupported function invoked"</span>) @builtin @noreturn</code></pre><pre><code class="lang-c3">macro uint ushort.hash(ushort s)</code></pre><pre><code class="lang-c3">macro uint void*.hash(void* ptr)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorebuiltin-ifenvlinux-envdarwin-envcompiler_safe_mode-envdebug_symbols">std::core::builtin @if((env::LINUX || env::DARWIN) &amp;&amp; env::COMPILER_SAFE_MODE &amp;&amp; env::DEBUG_SYMBOLS)</h3><pre><code class="lang-c3">fn void sig_bus_error(CInt i)</code></pre><pre><code class="lang-c3">fn void sig_panic(String message)</code></pre><pre><code class="lang-c3">fn void sig_segmentation_fault(CInt i)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcoredstring">std::core::dstring</h3><pre><code class="lang-c3">distinct DString (OutStream) = void*;</code></pre><pre><code class="lang-c3">macro void DString.append(&amp;self, value)</code></pre><pre><code class="lang-c3">fn void DString.append_char(&amp;self, char c)</code></pre><pre><code class="lang-c3">fn void DString.append_char<span class="number">32</span>(&amp;self, Char<span class="number">32</span> c)</code></pre><pre><code class="lang-c3">fn void DString.append_chars(&amp;self, String str)</code></pre><pre><code class="lang-c3">fn void DString.append_repeat(&amp;self, char c, usz times)</code></pre><pre><code class="lang-c3">fn void DString.append_string(&amp;self, DString str)</code></pre><pre><code class="lang-c3">fn void DString.append_utf<span class="number">32</span>(&amp;self, Char<span class="number">32</span>[] chars)</code></pre><pre><code class="lang-c3">fn usz! DString.appendf(&amp;self, String format, args...) @maydiscard</code></pre><pre><code class="lang-c3">fn usz! DString.appendfn(&amp;self, String format, args...) @maydiscard</code></pre><pre><code class="lang-c3">fn usz DString.capacity(self)</code></pre><pre><code class="lang-c3">fn void DString.chop(self, usz new_size)</code></pre><pre><code class="lang-c3">fn void DString.clear(self)</code></pre><pre><code class="lang-c3">fn DString DString.copy(self, Allocator allocator = null)</code></pre><pre><code class="lang-c3">fn String DString.copy_str(self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Char<span class="number">32</span>[] DString.copy_utf<span class="number">32</span>(&amp;self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn ZString DString.copy_zstr(self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn void DString.delete(&amp;self, usz start, usz len = <span class="number">1</span>)</code></pre><pre><code class="lang-c3">fn void DString.delete_range(&amp;self, usz start, usz end)</code></pre><pre><code class="lang-c3">fn bool DString.equals(self, DString other_string)</code></pre><pre><code class="lang-c3">fn void DString.free(&amp;self)</code></pre><pre><code class="lang-c3">fn void DString.insert_at(&amp;self, usz index, String s)</code></pre><pre><code class="lang-c3">fn usz DString.len(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn bool DString.less(self, DString other_string)</code></pre><pre><code class="lang-c3">fn DString DString.new_concat(self, DString b, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn DString DString.new_init(&amp;self, usz capacity = MIN_CAPACITY, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn usz! DString.read_from_stream(&amp;self, InStream reader)</code></pre><pre><code class="lang-c3">fn void DString.reserve(&amp;self, usz addition)</code></pre><pre><code class="lang-c3">fn void DString.set(self, usz index, char c)</code></pre><pre><code class="lang-c3">fn String DString.str_view(self)</code></pre><pre><code class="lang-c3">fn DString DString.tcopy(&amp;self)</code></pre><pre><code class="lang-c3">fn String DString.tcopy_str(self)</code></pre><pre><code class="lang-c3">fn DString DString.temp_concat(self, DString b)</code></pre><pre><code class="lang-c3">fn DString DString.temp_init(&amp;self, usz capacity = MIN_CAPACITY)</code></pre><pre><code class="lang-c3">fn usz! DString.write(&amp;self, char[] buffer) @dynamic</code></pre><pre><code class="lang-c3">fn void! DString.write_byte(&amp;self, char c) @dynamic</code></pre><pre><code class="lang-c3">fn ZString DString.zstr_view(&amp;self)</code></pre><pre><code class="lang-c3">fn DString new(String c = <span class="string">""</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn DString new_join(String[] s, String joiner, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn DString new_with_capacity(usz capacity, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn DString temp_new(String s = <span class="string">""</span>)</code></pre><pre><code class="lang-c3">fn DString temp_with_capacity(usz capacity)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcoreenv">std::core::env</h3><pre><code class="lang-c3">enum ArchType</code></pre><pre><code class="lang-c3">enum CompilerOptLevel</code></pre><pre><code class="lang-c3">enum MemoryEnvironment</code></pre><pre><code class="lang-c3">enum OsType</code></pre><pre><code class="lang-c3">macro bool os_is_darwin()</code></pre><pre><code class="lang-c3">macro bool os_is_posix()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcoremem">std::core::mem</h3><pre><code class="lang-c3">enum AtomicOrdering : int</code></pre><pre><code class="lang-c3">struct TempState</code></pre><pre><code class="lang-c3">macro @atomic_load(&amp;x, AtomicOrdering $ordering = SEQ_CONSISTENT, $volatile = false) @builtin</code></pre><pre><code class="lang-c3">macro void @atomic_store(&amp;x, value, AtomicOrdering $ordering = SEQ_CONSISTENT, $volatile = false) @builtin</code></pre><pre><code class="lang-c3">macro @clone(value) @builtin @nodiscard</code></pre><pre><code class="lang-c3">macro @gather_aligned(ptrvec, bool[&lt;*&gt;] mask, passthru, usz $alignment)</code></pre><pre><code class="lang-c3">macro @masked_load_aligned(ptr, bool[&lt;*&gt;] mask, passthru, usz $alignment)</code></pre><pre><code class="lang-c3">macro @masked_store_aligned(ptr, value, bool[&lt;*&gt;] mask, usz $alignment)</code></pre><pre><code class="lang-c3">macro void @pool(TempAllocator* <span class="comment">#other_temp = null; @body) @builtin</span></code></pre><pre><code class="lang-c3">macro void @report_heap_allocs_in_scope(;@body())</code></pre><pre><code class="lang-c3">macro @scatter_aligned(ptrvec, value, bool[&lt;*&gt;] mask, usz $alignment)</code></pre><pre><code class="lang-c3">macro void @scoped(Allocator allocator; @body())</code></pre><pre><code class="lang-c3">macro void @stack_mem(usz $size; @body(Allocator mem)) @builtin</code></pre><pre><code class="lang-c3">macro void @stack_pool(usz $size; @body) @builtin</code></pre><pre><code class="lang-c3">macro @tclone(value) @builtin @nodiscard</code></pre><pre><code class="lang-c3">macro @volatile_load(&amp;x) @builtin</code></pre><pre><code class="lang-c3">macro @volatile_store(&amp;x, y) @builtin</code></pre><pre><code class="lang-c3">fn usz aligned_offset(usz offset, usz alignment)</code></pre><pre><code class="lang-c3">macro void* aligned_pointer(void* ptr, usz alignment)</code></pre><pre><code class="lang-c3">macro alloc($Type) @nodiscard</code></pre><pre><code class="lang-c3">macro alloc_aligned($Type) @nodiscard</code></pre><pre><code class="lang-c3">macro alloc_array($Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">macro alloc_array_aligned($Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">fn void* calloc(usz size) @builtin @inline @nodiscard</code></pre><pre><code class="lang-c3">fn void* calloc_aligned(usz size, usz alignment) @builtin @inline @nodiscard</code></pre><pre><code class="lang-c3">macro void clear(void* dst, usz len, usz $dst_align = <span class="number">0</span>, bool $is_volatile = false, bool $inlined = false)</code></pre><pre><code class="lang-c3">macro void clear_inline(void* dst, usz $len, usz $dst_align = <span class="number">0</span>, bool $is_volatile = false)</code></pre><pre><code class="lang-c3">macro compare_exchange(ptr, compare, value, AtomicOrdering $success = SEQ_CONSISTENT, AtomicOrdering $failure = SEQ_CONSISTENT, bool $volatile = true, bool $weak = false, usz $alignment = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">macro compare_exchange_volatile(ptr, compare, value, AtomicOrdering $success = SEQ_CONSISTENT, AtomicOrdering $failure = SEQ_CONSISTENT)</code></pre><pre><code class="lang-c3">macro void copy(void* dst, void* src, usz len, usz $dst_align = <span class="number">0</span>, usz $src_align = <span class="number">0</span>, bool $is_volatile = false, bool $inlined = false)</code></pre><pre><code class="lang-c3">macro void copy_inline(void* dst, void* src, usz $len, usz $dst_align = <span class="number">0</span>, usz $src_align = <span class="number">0</span>, bool $is_volatile = false)</code></pre><pre><code class="lang-c3">macro bool equals(a, b, isz len = -<span class="number">1</span>, usz $align = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">fn void free(void* ptr) @builtin @inline</code></pre><pre><code class="lang-c3">fn void free_aligned(void* ptr) @builtin @inline</code></pre><pre><code class="lang-c3">macro gather(ptrvec, bool[&lt;*&gt;] mask, passthru)</code></pre><pre><code class="lang-c3">macro TrackingEnv* get_tracking_env()</code></pre><pre><code class="lang-c3">fn void* malloc(usz size) @builtin @inline @nodiscard</code></pre><pre><code class="lang-c3">macro masked_load(ptr, bool[&lt;*&gt;] mask, passthru)</code></pre><pre><code class="lang-c3">macro masked_store(ptr, value, bool[&lt;*&gt;] mask)</code></pre><pre><code class="lang-c3">macro void move(void* dst, void* src, usz len, usz $dst_align = <span class="number">0</span>, usz $src_align = <span class="number">0</span>, bool $is_volatile = false)</code></pre><pre><code class="lang-c3">macro new($Type, ...) @nodiscard</code></pre><pre><code class="lang-c3">macro new_aligned($Type, ...) @nodiscard</code></pre><pre><code class="lang-c3">macro new_array($Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">macro new_array_aligned($Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">fn bool ptr_is_aligned(void* ptr, usz alignment) @inline</code></pre><pre><code class="lang-c3">fn void* realloc(void *ptr, usz new_size) @builtin @inline @nodiscard</code></pre><pre><code class="lang-c3">fn void* realloc_aligned(void *ptr, usz new_size, usz alignment) @builtin @inline @nodiscard</code></pre><pre><code class="lang-c3">macro scatter(ptrvec, value, bool[&lt;*&gt;] mask)</code></pre><pre><code class="lang-c3">macro void set(void* dst, char val, usz len, usz $dst_align = <span class="number">0</span>, bool $is_volatile = false)</code></pre><pre><code class="lang-c3">macro void set_inline(void* dst, char val, usz $len, usz $dst_align = <span class="number">0</span>, bool $is_volatile = false)</code></pre><pre><code class="lang-c3">fn void* tcalloc(usz size, usz alignment = <span class="number">0</span>) @builtin @inline @nodiscard</code></pre><pre><code class="lang-c3">macro temp_alloc($Type) @nodiscard</code></pre><pre><code class="lang-c3">macro temp_alloc_array($Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">macro temp_new($Type, ...) @nodiscard</code></pre><pre><code class="lang-c3">macro temp_new_array($Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">fn void temp_pop(TempState old_state)</code></pre><pre><code class="lang-c3">fn TempState temp_push(TempAllocator* other = null)</code></pre><pre><code class="lang-c3">fn void* tmalloc(usz size, usz alignment = <span class="number">0</span>) @builtin @inline @nodiscard</code></pre><pre><code class="lang-c3">fn void* trealloc(void* ptr, usz size, usz alignment = mem::DEFAULT_MEM_ALIGNMENT) @builtin @inline @nodiscard</code></pre><pre><code class="lang-c3">macro type_alloc_must_be_aligned($Type)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorememallocator">std::core::mem::allocator</h3><pre><code class="lang-c3">distinct LibcAllocator (Allocator) = uptr;</code></pre><pre><code class="lang-c3">enum AllocInitType</code></pre><pre><code class="lang-c3">fault AllocationFailure</code></pre><pre><code class="lang-c3">interface Allocator</code></pre><pre><code class="lang-c3">struct AlignedBlock</code></pre><pre><code class="lang-c3">struct Allocation</code></pre><pre><code class="lang-c3">struct ArenaAllocator (Allocator)</code></pre><pre><code class="lang-c3">struct DynamicArenaAllocator (Allocator)</code></pre><pre><code class="lang-c3">struct OnStackAllocator (Allocator)</code></pre><pre><code class="lang-c3">struct OnStackAllocatorHeader</code></pre><pre><code class="lang-c3">struct SimpleHeapAllocator (Allocator)</code></pre><pre><code class="lang-c3">struct TempAllocator (Allocator)</code></pre><pre><code class="lang-c3">struct TempAllocatorPage</code></pre><pre><code class="lang-c3">struct TrackingAllocator (Allocator)</code></pre><pre><code class="lang-c3">struct TrackingEnv</code></pre><pre><code class="lang-c3">struct WasmMemory</code></pre><pre><code class="lang-c3">macro void*! @aligned_alloc(<span class="comment">#alloc_fn, usz bytes, usz alignment)</span></code></pre><pre><code class="lang-c3">macro void! @aligned_free(<span class="comment">#free_fn, void* old_pointer)</span></code></pre><pre><code class="lang-c3">macro void*! @aligned_realloc(<span class="comment">#calloc_fn, #free_fn, void* old_pointer, usz bytes, usz alignment)</span></code></pre><pre><code class="lang-c3">fn void*! ArenaAllocator.acquire(&amp;self, usz size, AllocInitType init_type, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void ArenaAllocator.clear(&amp;self)</code></pre><pre><code class="lang-c3">fn void ArenaAllocator.init(&amp;self, char[] data)</code></pre><pre><code class="lang-c3">fn usz ArenaAllocator.mark(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void ArenaAllocator.release(&amp;self, void* ptr, bool) @dynamic</code></pre><pre><code class="lang-c3">fn void ArenaAllocator.reset(&amp;self, usz mark) @dynamic</code></pre><pre><code class="lang-c3">fn void*! ArenaAllocator.resize(&amp;self, void *old_pointer, usz size, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void*! DynamicArenaAllocator.acquire(&amp;self, usz size, AllocInitType init_type, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void DynamicArenaAllocator.free(&amp;self)</code></pre><pre><code class="lang-c3">fn void DynamicArenaAllocator.init(&amp;self, usz page_size, Allocator allocator)</code></pre><pre><code class="lang-c3">fn void DynamicArenaAllocator.release(&amp;self, void* ptr, bool) @dynamic</code></pre><pre><code class="lang-c3">fn void DynamicArenaAllocator.reset(&amp;self, usz mark = <span class="number">0</span>) @dynamic</code></pre><pre><code class="lang-c3">fn void*! DynamicArenaAllocator.resize(&amp;self, void* old_pointer, usz size, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void*! OnStackAllocator.acquire(&amp;self, usz size, AllocInitType init_type, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void OnStackAllocator.free(&amp;self)</code></pre><pre><code class="lang-c3">fn void OnStackAllocator.init(&amp;self, char[] data, Allocator allocator)</code></pre><pre><code class="lang-c3">fn void OnStackAllocator.release(&amp;self, void* old_pointer, bool aligned) @dynamic</code></pre><pre><code class="lang-c3">fn void*! OnStackAllocator.resize(&amp;self, void* old_pointer, usz size, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void*! SimpleHeapAllocator.acquire(&amp;self, usz size, AllocInitType init_type, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void SimpleHeapAllocator.init(&amp;self, MemoryAllocFn allocator)</code></pre><pre><code class="lang-c3">fn void SimpleHeapAllocator.release(&amp;self, void* old_pointer, bool aligned) @dynamic</code></pre><pre><code class="lang-c3">fn void*! SimpleHeapAllocator.resize(&amp;self, void* old_pointer, usz size, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void*! TempAllocator.acquire(&amp;self, usz size, AllocInitType init_type, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn usz TempAllocator.mark(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void! TempAllocator.print_pages(&amp;self, File* f)</code></pre><pre><code class="lang-c3">fn void TempAllocator.release(&amp;self, void* old_pointer, bool) @dynamic</code></pre><pre><code class="lang-c3">fn void TempAllocator.reset(&amp;self, usz mark) @dynamic</code></pre><pre><code class="lang-c3">fn void*! TempAllocator.resize(&amp;self, void* pointer, usz size, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">macro bool TempAllocatorPage.is_aligned(&amp;self)</code></pre><pre><code class="lang-c3">macro usz TempAllocatorPage.pagesize(&amp;self)</code></pre><pre><code class="lang-c3">fn void*! TrackingAllocator.acquire(&amp;self, usz size, AllocInitType init_type, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn usz TrackingAllocator.allocated(&amp;self)</code></pre><pre><code class="lang-c3">fn usz TrackingAllocator.allocation_count(&amp;self)</code></pre><pre><code class="lang-c3">fn Allocation[] TrackingAllocator.allocations_tlist(&amp;self, Allocator allocator)</code></pre><pre><code class="lang-c3">fn void TrackingAllocator.clear(&amp;self)</code></pre><pre><code class="lang-c3">fn void! TrackingAllocator.fprint_report(&amp;self, OutStream out)</code></pre><pre><code class="lang-c3">fn void TrackingAllocator.free(&amp;self)</code></pre><pre><code class="lang-c3">fn void TrackingAllocator.init(&amp;self, Allocator allocator)</code></pre><pre><code class="lang-c3">fn void TrackingAllocator.print_report(&amp;self)</code></pre><pre><code class="lang-c3">fn void TrackingAllocator.release(&amp;self, void* old_pointer, bool is_aligned) @dynamic</code></pre><pre><code class="lang-c3">fn void*! TrackingAllocator.resize(&amp;self, void* old_pointer, usz size, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn usz TrackingAllocator.total_allocated(&amp;self)</code></pre><pre><code class="lang-c3">fn usz TrackingAllocator.total_allocation_count(&amp;self)</code></pre><pre><code class="lang-c3">fn char[]! WasmMemory.allocate_block(&amp;self, usz bytes)</code></pre><pre><code class="lang-c3">macro alloc(Allocator allocator, $Type) @nodiscard</code></pre><pre><code class="lang-c3">macro alloc_array(Allocator allocator, $Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">macro alloc_array_aligned(Allocator allocator, $Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">macro alloc_array_try(Allocator allocator, $Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">macro alloc_try(Allocator allocator, $Type) @nodiscard</code></pre><pre><code class="lang-c3">macro alloc_with_padding(Allocator allocator, $Type, usz padding) @nodiscard</code></pre><pre><code class="lang-c3">macro void* calloc(Allocator allocator, usz size) @nodiscard</code></pre><pre><code class="lang-c3">macro void*! calloc_aligned(Allocator allocator, usz size, usz alignment) @nodiscard</code></pre><pre><code class="lang-c3">macro void*! calloc_try(Allocator allocator, usz size) @nodiscard</code></pre><pre><code class="lang-c3">macro clone(Allocator allocator, value) @nodiscard</code></pre><pre><code class="lang-c3">fn any clone_any(Allocator allocator, any value) @nodiscard</code></pre><pre><code class="lang-c3">macro void free(Allocator allocator, void* ptr)</code></pre><pre><code class="lang-c3">macro void free_aligned(Allocator allocator, void* ptr)</code></pre><pre><code class="lang-c3">macro Allocator heap()</code></pre><pre><code class="lang-c3">macro void* malloc(Allocator allocator, usz size) @nodiscard</code></pre><pre><code class="lang-c3">macro void*! malloc_aligned(Allocator allocator, usz size, usz alignment) @nodiscard</code></pre><pre><code class="lang-c3">macro void*! malloc_try(Allocator allocator, usz size) @nodiscard</code></pre><pre><code class="lang-c3">macro new(Allocator allocator, $Type, ...) @nodiscard</code></pre><pre><code class="lang-c3">macro new_array(Allocator allocator, $Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">macro new_array_aligned(Allocator allocator, $Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">macro new_array_try(Allocator allocator, $Type, usz elements) @nodiscard</code></pre><pre><code class="lang-c3">fn TempAllocator*! new_temp_allocator(usz size, Allocator allocator)</code></pre><pre><code class="lang-c3">macro new_try(Allocator allocator, $Type, ...) @nodiscard</code></pre><pre><code class="lang-c3">macro new_with_padding(Allocator allocator, $Type, usz padding) @nodiscard</code></pre><pre><code class="lang-c3">macro void* realloc(Allocator allocator, void* ptr, usz new_size) @nodiscard</code></pre><pre><code class="lang-c3">macro void*! realloc_aligned(Allocator allocator, void* ptr, usz new_size, usz alignment) @nodiscard</code></pre><pre><code class="lang-c3">macro void*! realloc_try(Allocator allocator, void* ptr, usz new_size) @nodiscard</code></pre><pre><code class="lang-c3">macro TempAllocator* temp()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorememallocator-ifenvwin32-envposix">std::core::mem::allocator @if(!env::WIN32 &amp;&amp; !env::POSIX)</h3><pre><code class="lang-c3">fn void*! LibcAllocator.acquire(&amp;self, usz bytes, AllocInitType init_type, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void LibcAllocator.release(&amp;self, void* old_ptr, bool aligned) @dynamic</code></pre><pre><code class="lang-c3">fn void*! LibcAllocator.resize(&amp;self, void* old_ptr, usz new_bytes, usz alignment) @dynamic</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorememallocator-ifenvposix">std::core::mem::allocator @if(env::POSIX)</h3><pre><code class="lang-c3">fn void*! LibcAllocator.acquire(&amp;self, usz bytes, AllocInitType init_type, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void LibcAllocator.release(&amp;self, void* old_ptr, bool aligned) @dynamic</code></pre><pre><code class="lang-c3">fn void*! LibcAllocator.resize(&amp;self, void* old_ptr, usz new_bytes, usz alignment) @dynamic</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorememallocator-ifenvwin32">std::core::mem::allocator @if(env::WIN32)</h3><pre><code class="lang-c3">fn void*! LibcAllocator.acquire(&amp;self, usz bytes, AllocInitType init_type, usz alignment) @dynamic</code></pre><pre><code class="lang-c3">fn void LibcAllocator.release(&amp;self, void* old_ptr, bool aligned) @dynamic</code></pre><pre><code class="lang-c3">fn void*! LibcAllocator.resize(&amp;self, void* old_ptr, usz new_bytes, usz alignment) @dynamic</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcoreruntime">std::core::runtime</h3><pre><code class="lang-c3">struct AnyRaw</code></pre><pre><code class="lang-c3">struct BenchmarkUnit</code></pre><pre><code class="lang-c3">struct SliceRaw</code></pre><pre><code class="lang-c3">struct TestContext</code></pre><pre><code class="lang-c3">struct TestUnit</code></pre><pre><code class="lang-c3">fn BenchmarkUnit[] benchmark_collection_create(Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn int cmp_test_unit(TestUnit a, TestUnit b)</code></pre><pre><code class="lang-c3">fn bool default_benchmark_runner()</code></pre><pre><code class="lang-c3">fn bool default_test_runner()</code></pre><pre><code class="lang-c3">fn bool run_benchmarks(BenchmarkUnit[] benchmarks)</code></pre><pre><code class="lang-c3">fn bool run_tests(TestUnit[] tests)</code></pre><pre><code class="lang-c3">fn void set_benchmark_max_iterations(uint value) @builtin</code></pre><pre><code class="lang-c3">fn void set_benchmark_warmup_iterations(uint value) @builtin</code></pre><pre><code class="lang-c3">fn TestUnit[] test_collection_create(Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn void test_panic(String message, String file, String function, uint line)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcoreruntime-ifwasm_nolibc">std::core::runtime @if(WASM_NOLIBC)</h3><pre><code class="lang-c3">fn void wasm_initialize() @extern(<span class="string">"_initialize"</span>) @wasm</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorestring">std::core::string</h3><pre><code class="lang-c3">distinct WString = inline Char<span class="number">16</span>*;</code></pre><pre><code class="lang-c3">distinct ZString = inline char*;</code></pre><pre><code class="lang-c3">fault NumberConversion</code></pre><pre><code class="lang-c3">fault UnicodeResult</code></pre><pre><code class="lang-c3">struct Splitter</code></pre><pre><code class="lang-c3">fn String! Splitter.next(&amp;self)</code></pre><pre><code class="lang-c3">fn void Splitter.reset(&amp;self)</code></pre><pre><code class="lang-c3">fn String String.concat(s<span class="number">1</span>, String s<span class="number">2</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn bool String.contains(s, String needle)</code></pre><pre><code class="lang-c3">fn void String.convert_ascii_to_lower(s)</code></pre><pre><code class="lang-c3">fn void String.convert_ascii_to_upper(s)</code></pre><pre><code class="lang-c3">fn String String.copy(s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn bool String.ends_with(string, String needle)</code></pre><pre><code class="lang-c3">fn void String.free(&amp;s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn usz! String.index_of(s, String needle)</code></pre><pre><code class="lang-c3">fn usz! String.index_of_char(s, char needle)</code></pre><pre><code class="lang-c3">fn StringIterator String.iterator(s)</code></pre><pre><code class="lang-c3">fn String String.new_ascii_to_lower(s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String String.new_ascii_to_upper(s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn usz! String.rindex_of(s, String needle)</code></pre><pre><code class="lang-c3">fn usz! String.rindex_of_char(s, char needle)</code></pre><pre><code class="lang-c3">fn String[] String.split(s, String needle, usz max = <span class="number">0</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Splitter String.splitter(self, String split)</code></pre><pre><code class="lang-c3">fn bool String.starts_with(string, String needle)</code></pre><pre><code class="lang-c3">fn String String.strip(string, String needle)</code></pre><pre><code class="lang-c3">fn String String.strip_end(string, String needle)</code></pre><pre><code class="lang-c3">fn String String.tconcat(s<span class="number">1</span>, String s<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn String String.tcopy(s)</code></pre><pre><code class="lang-c3">fn String String.temp_ascii_to_lower(s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String String.temp_ascii_to_upper(s)</code></pre><pre><code class="lang-c3">fn double! String.to_double(s)</code></pre><pre><code class="lang-c3">fn float! String.to_float(s)</code></pre><pre><code class="lang-c3">fn ichar! String.to_ichar(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn int! String.to_int(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span>! String.to_int<span class="number">128</span>(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">macro String.to_integer(string, $Type, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn long! String.to_long(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn Char<span class="number">16</span>[]! String.to_new_utf<span class="number">16</span>(s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Char<span class="number">32</span>[]! String.to_new_utf<span class="number">32</span>(s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn WString! String.to_new_wstring(s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn short! String.to_short(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn Char<span class="number">16</span>[]! String.to_temp_utf<span class="number">16</span>(s)</code></pre><pre><code class="lang-c3">fn Char<span class="number">32</span>[]! String.to_temp_utf<span class="number">32</span>(s)</code></pre><pre><code class="lang-c3">fn WString! String.to_temp_wstring(s)</code></pre><pre><code class="lang-c3">fn char! String.to_uchar(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn uint! String.to_uint(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span>! String.to_uint<span class="number">128</span>(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn ulong! String.to_ulong(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn ushort! String.to_ushort(s, int base = <span class="number">10</span>)</code></pre><pre><code class="lang-c3">fn String String.trim(string, String to_trim = <span class="string">"\t\n\r "</span>)</code></pre><pre><code class="lang-c3">fn String[] String.tsplit(s, String needle, usz max = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">fn usz String.utf<span class="number">8</span>_codepoints(s)</code></pre><pre><code class="lang-c3">fn ZString String.zstr_copy(s, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn ZString String.zstr_tcopy(s)</code></pre><pre><code class="lang-c3">fn usz ZString.char_len(str)</code></pre><pre><code class="lang-c3">fn String ZString.copy(z, Allocator allocator = allocator::temp())</code></pre><pre><code class="lang-c3">fn usz ZString.len(str)</code></pre><pre><code class="lang-c3">fn String ZString.str_view(str)</code></pre><pre><code class="lang-c3">fn String ZString.tcopy(z)</code></pre><pre><code class="lang-c3">macro bool char_in_set(char c, String set)</code></pre><pre><code class="lang-c3">macro double! decfloat(char[] chars, int $bits, int $emin, int sign)</code></pre><pre><code class="lang-c3">macro double! hexfloat(char[] chars, int $bits, int $emin, int sign)</code></pre><pre><code class="lang-c3">fn String join_new(String[] s, String joiner, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">macro String new_format(String fmt, ..., Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String! new_from_utf<span class="number">16</span>(Char<span class="number">16</span>[] utf<span class="number">16</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String! new_from_utf<span class="number">32</span>(Char<span class="number">32</span>[] utf<span class="number">32</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String! new_from_wstring(WString wstring, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String! temp_from_utf<span class="number">16</span>(Char<span class="number">16</span>[] utf<span class="number">16</span>)</code></pre><pre><code class="lang-c3">fn String! temp_from_wstring(WString wstring)</code></pre><pre><code class="lang-c3">macro String tformat(String fmt, ...)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorestringconv">std::core::string::conv</h3><pre><code class="lang-c3">fn void! char<span class="number">16</span>_to_utf<span class="number">8</span>_unsafe(Char<span class="number">16</span> *ptr, usz *available, char** output)</code></pre><pre><code class="lang-c3">fn void char<span class="number">32</span>_to_utf<span class="number">16</span>_unsafe(Char<span class="number">32</span> c, Char<span class="number">16</span>** output)</code></pre><pre><code class="lang-c3">fn usz! char<span class="number">32</span>_to_utf<span class="number">8</span>(Char<span class="number">32</span> c, char[] output)</code></pre><pre><code class="lang-c3">fn usz char<span class="number">32</span>_to_utf<span class="number">8</span>_unsafe(Char<span class="number">32</span> c, char** output)</code></pre><pre><code class="lang-c3">fn usz utf<span class="number">16</span>len_for_utf<span class="number">32</span>(Char<span class="number">32</span>[] utf<span class="number">32</span>)</code></pre><pre><code class="lang-c3">fn usz utf<span class="number">16</span>len_for_utf<span class="number">8</span>(String utf<span class="number">8</span>)</code></pre><pre><code class="lang-c3">fn void! utf<span class="number">16</span>to<span class="number">8</span>_unsafe(Char<span class="number">16</span>[] utf<span class="number">16</span>, char* utf<span class="number">8</span>_buffer)</code></pre><pre><code class="lang-c3">fn usz! utf<span class="number">32</span>to<span class="number">8</span>(Char<span class="number">32</span>[] utf<span class="number">32</span>, char[] utf<span class="number">8</span>_buffer)</code></pre><pre><code class="lang-c3">fn void utf<span class="number">32</span>to<span class="number">8</span>_unsafe(Char<span class="number">32</span>[] utf<span class="number">32</span>, char* utf<span class="number">8</span>_buffer)</code></pre><pre><code class="lang-c3">fn usz utf<span class="number">8</span>_codepoints(String utf<span class="number">8</span>)</code></pre><pre><code class="lang-c3">fn Char<span class="number">32</span>! utf<span class="number">8</span>_to_char<span class="number">32</span>(char* ptr, usz* size)</code></pre><pre><code class="lang-c3">fn usz utf<span class="number">8</span>len_for_utf<span class="number">16</span>(Char<span class="number">16</span>[] utf<span class="number">16</span>)</code></pre><pre><code class="lang-c3">fn usz utf<span class="number">8</span>len_for_utf<span class="number">32</span>(Char<span class="number">32</span>[] utf<span class="number">32</span>)</code></pre><pre><code class="lang-c3">fn void! utf<span class="number">8</span>to<span class="number">16</span>_unsafe(String utf<span class="number">8</span>, Char<span class="number">16</span>* utf<span class="number">16</span>_buffer)</code></pre><pre><code class="lang-c3">fn usz! utf<span class="number">8</span>to<span class="number">32</span>(String utf<span class="number">8</span>, Char<span class="number">32</span>[] utf<span class="number">32</span>_buffer)</code></pre><pre><code class="lang-c3">fn void! utf<span class="number">8</span>to<span class="number">32</span>_unsafe(String utf<span class="number">8</span>, Char<span class="number">32</span>* utf<span class="number">32</span>_buffer)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorestringiterator">std::core::string::iterator</h3><pre><code class="lang-c3">struct StringIterator</code></pre><pre><code class="lang-c3">fn Char<span class="number">32</span>! StringIterator.next(&amp;self)</code></pre><pre><code class="lang-c3">fn void StringIterator.reset(&amp;self)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcoretypes">std::core::types</h3><pre><code class="lang-c3">enum TypeKind : char</code></pre><pre><code class="lang-c3">fault ConversionResult</code></pre><pre><code class="lang-c3">struct TypeEnum</code></pre><pre><code class="lang-c3">macro bool @has_same(<span class="comment">#a, #b, ...)</span></code></pre><pre><code class="lang-c3">fn bool TypeKind.is_int(kind) @inline</code></pre><pre><code class="lang-c3">macro any_to_int(any v, $Type)</code></pre><pre><code class="lang-c3">macro bool implements_copy($Type)</code></pre><pre><code class="lang-c3">macro TypeKind inner_kind($Type)</code></pre><pre><code class="lang-c3">macro bool is_bool($Type)</code></pre><pre><code class="lang-c3">macro bool is_comparable_value(value)</code></pre><pre><code class="lang-c3">macro bool is_equatable_type($Type)</code></pre><pre><code class="lang-c3">macro bool is_equatable_value(value)</code></pre><pre><code class="lang-c3">macro bool is_float($Type)</code></pre><pre><code class="lang-c3">macro bool is_floatlike($Type)</code></pre><pre><code class="lang-c3">macro bool is_int($Type)</code></pre><pre><code class="lang-c3">macro bool is_intlike($Type)</code></pre><pre><code class="lang-c3">macro bool is_numerical($Type)</code></pre><pre><code class="lang-c3">macro bool is_promotable_to_float($Type)</code></pre><pre><code class="lang-c3">macro bool is_promotable_to_floatlike($Type)</code></pre><pre><code class="lang-c3">macro bool is_same($TypeA, $TypeB)</code></pre><pre><code class="lang-c3">macro bool is_same_vector_type($Type<span class="number">1</span>, $Type<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro bool is_slice_convertable($Type)</code></pre><pre><code class="lang-c3">macro bool is_subtype_of($Type, $OtherType)</code></pre><pre><code class="lang-c3">macro bool is_underlying_int($Type)</code></pre><pre><code class="lang-c3">macro bool is_vector($Type)</code></pre><pre><code class="lang-c3">macro lower_to_atomic_compatible_type($Type)</code></pre><pre><code class="lang-c3">macro bool may_load_atomic($Type)</code></pre><pre><code class="lang-c3">fn bool typeid.is_subtype_of(self, typeid other)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcorevalues">std::core::values</h3><pre><code class="lang-c3">macro bool @assign_to(<span class="comment">#value<span class="number">1</span>, #value<span class="number">2</span>)</span></code></pre><pre><code class="lang-c3">macro TypeKind @inner_kind(<span class="comment">#value)</span></code></pre><pre><code class="lang-c3">macro bool @is_bool(<span class="comment">#value)</span></code></pre><pre><code class="lang-c3">macro bool @is_float(<span class="comment">#value)</span></code></pre><pre><code class="lang-c3">macro bool @is_floatlike(<span class="comment">#value)</span></code></pre><pre><code class="lang-c3">macro bool @is_int(<span class="comment">#value)</span></code></pre><pre><code class="lang-c3">macro bool @is_promotable_to_float(<span class="comment">#value)</span></code></pre><pre><code class="lang-c3">macro bool @is_promotable_to_floatlike(<span class="comment">#value)</span></code></pre><pre><code class="lang-c3">macro bool @is_same_type(<span class="comment">#value<span class="number">1</span>, #value<span class="number">2</span>)</span></code></pre><pre><code class="lang-c3">macro bool @is_same_vector_type(<span class="comment">#value<span class="number">1</span>, #value<span class="number">2</span>)</span></code></pre><pre><code class="lang-c3">macro bool @is_vector(<span class="comment">#value)</span></code></pre><pre><code class="lang-c3">macro typeid @typeid(<span class="comment">#value) @builtin</span></code></pre><pre><code class="lang-c3">macro bool @typeis(<span class="comment">#value, $Type) @builtin</span></code></pre><pre><code class="lang-c3">macro TypeKind @typekind(<span class="comment">#value) @builtin</span></code></pre><pre><code class="lang-c3">macro promote_int(x)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdcryptorc4">std::crypto::rc4</h3><pre><code class="lang-c3">struct Rc<span class="number">4</span></code></pre><pre><code class="lang-c3">fn void Rc<span class="number">4</span>.crypt(&amp;self, char[] in, char[] out)</code></pre><pre><code class="lang-c3">fn void Rc<span class="number">4</span>.destroy(&amp;self)</code></pre><pre><code class="lang-c3">fn void Rc<span class="number">4</span>.init(&amp;self, char[] key)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdencodingbase64">std::encoding::base64</h3><pre><code class="lang-c3">fault Base<span class="number">64</span>Error</code></pre><pre><code class="lang-c3">struct Base<span class="number">64</span>Decoder</code></pre><pre><code class="lang-c3">struct Base<span class="number">64</span>Encoder</code></pre><pre><code class="lang-c3">fn usz! Base<span class="number">64</span>Decoder.decode(&amp;self, char[] src, char[] dst)</code></pre><pre><code class="lang-c3">fn usz! Base<span class="number">64</span>Decoder.decode_len(&amp;self, usz n)</code></pre><pre><code class="lang-c3">fn void! Base<span class="number">64</span>Decoder.init(&amp;self, String alphabet, int padding = <span class="string">'='</span>)</code></pre><pre><code class="lang-c3">fn usz! Base<span class="number">64</span>Encoder.encode(&amp;self, char[] src, char[] dst)</code></pre><pre><code class="lang-c3">fn usz Base<span class="number">64</span>Encoder.encode_len(&amp;self, usz n)</code></pre><pre><code class="lang-c3">fn void! Base<span class="number">64</span>Encoder.init(&amp;self, String alphabet, int padding = <span class="string">'='</span>)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdencodingcsv">std::encoding::csv</h3><pre><code class="lang-c3">struct CsvReader</code></pre><pre><code class="lang-c3">macro CsvReader.@each_row(self, int rows = int.max; @body(String[] row))</code></pre><pre><code class="lang-c3">fn void CsvReader.init(&amp;self, InStream stream, String separator = <span class="string">","</span>)</code></pre><pre><code class="lang-c3">fn String[]! CsvReader.read_new_row(self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String[]! CsvReader.read_new_row_with_allocator(self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String[]! CsvReader.read_temp_row(self)</code></pre><pre><code class="lang-c3">fn void! CsvReader.skip_row(self) @maydiscard</code></pre><h3 id="pre-conditions-for-macros-stdio-stdencodingjson">std::encoding::json</h3><pre><code class="lang-c3">fault JsonParsingError</code></pre><pre><code class="lang-c3">fn JsonTokenType! lex_string(JsonContext* context)</code></pre><pre><code class="lang-c3">fn Object*! parse(InStream s, Allocator allocator = allocator::heap())</code></pre><h3 id="pre-conditions-for-macros-stdio-stdhashadler32">std::hash::adler32</h3><pre><code class="lang-c3">struct Adler<span class="number">32</span></code></pre><pre><code class="lang-c3">fn uint Adler<span class="number">32</span>.final(&amp;self)</code></pre><pre><code class="lang-c3">fn void Adler<span class="number">32</span>.init(&amp;self)</code></pre><pre><code class="lang-c3">fn void Adler<span class="number">32</span>.update(&amp;self, char[] data)</code></pre><pre><code class="lang-c3">fn void Adler<span class="number">32</span>.updatec(&amp;self, char c)</code></pre><pre><code class="lang-c3">fn uint encode(char[] data)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdhashcrc32">std::hash::crc32</h3><pre><code class="lang-c3">struct Crc<span class="number">32</span></code></pre><pre><code class="lang-c3">fn uint Crc<span class="number">32</span>.final(&amp;self)</code></pre><pre><code class="lang-c3">fn void Crc<span class="number">32</span>.init(&amp;self, uint seed = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">fn void Crc<span class="number">32</span>.update(&amp;self, char[] data)</code></pre><pre><code class="lang-c3">fn void Crc<span class="number">32</span>.updatec(&amp;self, char c)</code></pre><pre><code class="lang-c3">fn uint encode(char[] data)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdhashcrc64">std::hash::crc64</h3><pre><code class="lang-c3">struct Crc<span class="number">64</span></code></pre><pre><code class="lang-c3">fn ulong Crc<span class="number">64</span>.final(&amp;self)</code></pre><pre><code class="lang-c3">fn void Crc<span class="number">64</span>.init(&amp;self, uint seed = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">fn void Crc<span class="number">64</span>.update(&amp;self, char[] data)</code></pre><pre><code class="lang-c3">fn void Crc<span class="number">64</span>.updatec(&amp;self, char c)</code></pre><pre><code class="lang-c3">fn ulong encode(char[] data)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdhashfnv32a">std::hash::fnv32a</h3><pre><code class="lang-c3">distinct Fnv<span class="number">32</span>a = uint;</code></pre><pre><code class="lang-c3">fn void Fnv<span class="number">32</span>a.init(&amp;self)</code></pre><pre><code class="lang-c3">fn void Fnv<span class="number">32</span>a.update(&amp;self, char[] data)</code></pre><pre><code class="lang-c3">macro void Fnv<span class="number">32</span>a.update_char(&amp;self, char c)</code></pre><pre><code class="lang-c3">fn uint encode(char[] data)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdhashfnv64a">std::hash::fnv64a</h3><pre><code class="lang-c3">distinct Fnv<span class="number">64</span>a = ulong;</code></pre><pre><code class="lang-c3">fn void Fnv<span class="number">64</span>a.init(&amp;self)</code></pre><pre><code class="lang-c3">fn void Fnv<span class="number">64</span>a.update(&amp;self, char[] data)</code></pre><pre><code class="lang-c3">macro void Fnv<span class="number">64</span>a.update_char(&amp;self, char c)</code></pre><pre><code class="lang-c3">fn ulong encode(char[] data)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdhashsha1">std::hash::sha1</h3><pre><code class="lang-c3">struct Sha<span class="number">1</span></code></pre><pre><code class="lang-c3">fn char[<span class="number">20</span>] Sha<span class="number">1</span>.final(&amp;self)</code></pre><pre><code class="lang-c3">fn void Sha<span class="number">1</span>.init(&amp;self)</code></pre><pre><code class="lang-c3">fn void Sha<span class="number">1</span>.update(&amp;self, char[] data)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdio">std::io</h3><pre><code class="lang-c3">enum Seek</code></pre><pre><code class="lang-c3">fault FormattingFault</code></pre><pre><code class="lang-c3">fault IoError</code></pre><pre><code class="lang-c3">fault PrintFault</code></pre><pre><code class="lang-c3">interface InStream</code></pre><pre><code class="lang-c3">interface OutStream</code></pre><pre><code class="lang-c3">interface Printable</code></pre><pre><code class="lang-c3">struct BitReader</code></pre><pre><code class="lang-c3">struct BitWriter</code></pre><pre><code class="lang-c3">struct ByteBuffer (InStream, OutStream)</code></pre><pre><code class="lang-c3">struct ByteReader (InStream)</code></pre><pre><code class="lang-c3">struct ByteWriter (OutStream)</code></pre><pre><code class="lang-c3">struct File (InStream, OutStream)</code></pre><pre><code class="lang-c3">struct Formatter</code></pre><pre><code class="lang-c3">struct LimitReader (InStream)</code></pre><pre><code class="lang-c3">struct ReadBuffer (InStream)</code></pre><pre><code class="lang-c3">struct Scanner (InStream)</code></pre><pre><code class="lang-c3">struct WriteBuffer (OutStream)</code></pre><pre><code class="lang-c3">macro bool @is_instream(<span class="comment">#expr)</span></code></pre><pre><code class="lang-c3">macro bool @is_outstream(<span class="comment">#expr)</span></code></pre><pre><code class="lang-c3">macro void! @pushback_using_seek(&amp;s)</code></pre><pre><code class="lang-c3">macro char! @read_byte_using_read(&amp;s)</code></pre><pre><code class="lang-c3">macro usz! @read_using_read_byte(&amp;s, char[] buffer)</code></pre><pre><code class="lang-c3">macro void! @write_byte_using_write(&amp;s, char c)</code></pre><pre><code class="lang-c3">macro usz! @write_using_write_byte(&amp;s, char[] bytes)</code></pre><pre><code class="lang-c3">fn void BitReader.clear(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn void BitReader.init(&amp;self, InStream byte_reader)</code></pre><pre><code class="lang-c3">fn char! BitReader.read_bits(&amp;self, uint nbits)</code></pre><pre><code class="lang-c3">fn void! BitWriter.flush(&amp;self)</code></pre><pre><code class="lang-c3">fn void BitWriter.init(&amp;self, OutStream byte_writer)</code></pre><pre><code class="lang-c3">fn void! BitWriter.write_bits(&amp;self, uint bits, uint nbits)</code></pre><pre><code class="lang-c3">fn usz! ByteBuffer.available(&amp;self) @inline @dynamic</code></pre><pre><code class="lang-c3">fn void ByteBuffer.free(&amp;self)</code></pre><pre><code class="lang-c3">fn void! ByteBuffer.grow(&amp;self, usz n)</code></pre><pre><code class="lang-c3">fn ByteBuffer*! ByteBuffer.init_with_buffer(&amp;self, char[] buf)</code></pre><pre><code class="lang-c3">fn ByteBuffer*! ByteBuffer.new_init(&amp;self, usz max_read, usz initial_capacity = <span class="number">16</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn void! ByteBuffer.pushback_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn usz! ByteBuffer.read(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn char! ByteBuffer.read_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn usz! ByteBuffer.seek(&amp;self, isz offset, Seek seek) @dynamic</code></pre><pre><code class="lang-c3">macro ByteBuffer.shrink(&amp;self)</code></pre><pre><code class="lang-c3">fn ByteBuffer*! ByteBuffer.temp_init(&amp;self, usz max_read, usz initial_capacity = <span class="number">16</span>)</code></pre><pre><code class="lang-c3">fn usz! ByteBuffer.write(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn void! ByteBuffer.write_byte(&amp;self, char c) @dynamic</code></pre><pre><code class="lang-c3">fn usz! ByteReader.available(&amp;self) @inline @dynamic</code></pre><pre><code class="lang-c3">fn ByteReader* ByteReader.init(&amp;self, char[] bytes)</code></pre><pre><code class="lang-c3">fn usz ByteReader.len(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void! ByteReader.pushback_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn usz! ByteReader.read(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn char! ByteReader.read_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn usz! ByteReader.seek(&amp;self, isz offset, Seek seek) @dynamic</code></pre><pre><code class="lang-c3">fn usz! ByteReader.write_to(&amp;self, OutStream writer) @dynamic</code></pre><pre><code class="lang-c3">fn void! ByteWriter.destroy(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void! ByteWriter.ensure_capacity(&amp;self, usz len) @inline</code></pre><pre><code class="lang-c3">fn ByteWriter* ByteWriter.init_with_buffer(&amp;self, char[] data)</code></pre><pre><code class="lang-c3">fn ByteWriter* ByteWriter.new_init(&amp;self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn usz! ByteWriter.read_from(&amp;self, InStream reader) @dynamic</code></pre><pre><code class="lang-c3">fn String ByteWriter.str_view(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn ByteWriter* ByteWriter.temp_init(&amp;self)</code></pre><pre><code class="lang-c3">fn usz! ByteWriter.write(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn void! ByteWriter.write_byte(&amp;self, char c) @dynamic</code></pre><pre><code class="lang-c3">fn void Formatter.init(&amp;self, OutputFn out_fn, void* data = null)</code></pre><pre><code class="lang-c3">fn usz! Formatter.print(&amp;self, String str)</code></pre><pre><code class="lang-c3">fn usz! Formatter.print_with_function(&amp;self, Printable arg)</code></pre><pre><code class="lang-c3">fn usz! Formatter.printf(&amp;self, String format, args...)</code></pre><pre><code class="lang-c3">fn usz! Formatter.vprintf(&amp;self, String format, any[] anys)</code></pre><pre><code class="lang-c3">fn usz! LimitReader.available(&amp;self) @inline @dynamic</code></pre><pre><code class="lang-c3">fn void! LimitReader.close(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn LimitReader* LimitReader.init(&amp;self, InStream wrapped_stream, usz limit)</code></pre><pre><code class="lang-c3">fn usz! LimitReader.read(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn char! LimitReader.read_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void! ReadBuffer.close(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ReadBuffer* ReadBuffer.init(&amp;self, InStream wrapped_stream, char[] bytes)</code></pre><pre><code class="lang-c3">fn usz! ReadBuffer.read(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn char! ReadBuffer.read_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn String ReadBuffer.str_view(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn void! Scanner.close(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char[] Scanner.flush(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Scanner.init(&amp;self, InStream stream, char[] buffer)</code></pre><pre><code class="lang-c3">fn usz! Scanner.read(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn char! Scanner.read_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char[]! Scanner.scan(&amp;self, String pattern = <span class="string">"\n"</span>)</code></pre><pre><code class="lang-c3">fn void! WriteBuffer.close(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void! WriteBuffer.flush(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn WriteBuffer* WriteBuffer.init(&amp;self, OutStream wrapped_stream, char[] bytes)</code></pre><pre><code class="lang-c3">fn String WriteBuffer.str_view(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn usz! WriteBuffer.write(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn void! WriteBuffer.write_byte(&amp;self, char c) @dynamic</code></pre><pre><code class="lang-c3">fn usz! available(InStream s)</code></pre><pre><code class="lang-c3">fn char[]! bprintf(char[] buffer, String format, args...) @maydiscard</code></pre><pre><code class="lang-c3">fn usz! copy_to(InStream in, OutStream dst, char[] buffer = {})</code></pre><pre><code class="lang-c3">macro void eprint(x)</code></pre><pre><code class="lang-c3">fn usz! eprintf(String format, args...) @maydiscard</code></pre><pre><code class="lang-c3">fn usz! eprintfn(String format, args...) @maydiscard</code></pre><pre><code class="lang-c3">macro void eprintn(x)</code></pre><pre><code class="lang-c3">macro usz! fprint(out, x)</code></pre><pre><code class="lang-c3">fn usz! fprintf(OutStream out, String format, args...)</code></pre><pre><code class="lang-c3">fn usz! fprintfn(OutStream out, String format, args...) @maydiscard</code></pre><pre><code class="lang-c3">macro usz! fprintn(out, x = <span class="string">""</span>)</code></pre><pre><code class="lang-c3">macro void print(x)</code></pre><pre><code class="lang-c3">fn usz! printf(String format, args...) @maydiscard</code></pre><pre><code class="lang-c3">fn usz! printfn(String format, args...) @maydiscard</code></pre><pre><code class="lang-c3">macro void printn(x = <span class="string">""</span>)</code></pre><pre><code class="lang-c3">macro usz! read_all(stream, char[] buffer)</code></pre><pre><code class="lang-c3">macro usz! read_any(stream, any ref)</code></pre><pre><code class="lang-c3">macro usz! read_varint(stream, x_ptr)</code></pre><pre><code class="lang-c3">macro String! readline(stream = io::stdin(), Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">macro String! treadline(stream = io::stdin())</code></pre><pre><code class="lang-c3">macro usz! write_all(stream, char[] buffer)</code></pre><pre><code class="lang-c3">macro usz! write_any(stream, any ref)</code></pre><pre><code class="lang-c3">macro usz! write_varint(stream, x)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdio-if-envlibc">std::io @if (env::LIBC)</h3><pre><code class="lang-c3">fn void putchar(char c) @inline</code></pre><pre><code class="lang-c3">fn File* stderr()</code></pre><pre><code class="lang-c3">fn File* stdin()</code></pre><pre><code class="lang-c3">fn File* stdout()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdio-ifenvlibc">std::io @if(!env::LIBC)</h3><pre><code class="lang-c3">fn void putchar(char c) @inline</code></pre><pre><code class="lang-c3">fn File* stderr()</code></pre><pre><code class="lang-c3">fn File* stdin()</code></pre><pre><code class="lang-c3">fn File* stdout()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdiofile">std::io::file</h3><pre><code class="lang-c3">fn void! File.close(&amp;self) @inline @dynamic</code></pre><pre><code class="lang-c3">fn bool File.eof(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn void! File.flush(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void! File.memopen(File* file, char[] data, String mode)</code></pre><pre><code class="lang-c3">fn usz! File.read(&amp;self, char[] buffer) @dynamic</code></pre><pre><code class="lang-c3">fn char! File.read_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void! File.reopen(&amp;self, String filename, String mode)</code></pre><pre><code class="lang-c3">fn usz! File.seek(&amp;self, isz offset, Seek seek_mode = Seek.SET) @dynamic</code></pre><pre><code class="lang-c3">fn usz! File.write(&amp;self, char[] buffer) @dynamic</code></pre><pre><code class="lang-c3">fn void! File.write_byte(&amp;self, char c) @dynamic</code></pre><pre><code class="lang-c3">fn void! delete(String filename)</code></pre><pre><code class="lang-c3">fn File from_handle(CFile file)</code></pre><pre><code class="lang-c3">fn usz! get_size(String path)</code></pre><pre><code class="lang-c3">fn bool is_file(String path)</code></pre><pre><code class="lang-c3">fn char[]! load_buffer(String filename, char[] buffer)</code></pre><pre><code class="lang-c3">fn char[]! load_new(String filename, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn char[]! load_temp(String filename)</code></pre><pre><code class="lang-c3">fn File! open(String filename, String mode)</code></pre><pre><code class="lang-c3">fn File! open_path(Path path, String mode)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdioos">std::io::os</h3><pre><code class="lang-c3">macro String! getcwd(Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">macro void! native_chdir(Path path)</code></pre><pre><code class="lang-c3">fn bool native_file_or_dir_exists(String path)</code></pre><pre><code class="lang-c3">fn usz! native_file_size(String path) @if(!env::WIN<span class="number">32</span> &amp;&amp; !env::DARWIN)</code></pre><pre><code class="lang-c3">fn usz! native_file_size(String path) @if(env::DARWIN)</code></pre><pre><code class="lang-c3">fn usz! native_file_size(String path) @if(env::WIN<span class="number">32</span>)</code></pre><pre><code class="lang-c3">fn bool native_is_dir(String path)</code></pre><pre><code class="lang-c3">fn bool native_is_file(String path)</code></pre><pre><code class="lang-c3">macro bool! native_mkdir(Path path, MkdirPermissions permissions)</code></pre><pre><code class="lang-c3">macro bool! native_rmdir(Path path)</code></pre><pre><code class="lang-c3">fn void! native_stat(Stat* stat, String path) @if(env::DARWIN || env::LINUX)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdioos-ifenvlibc">std::io::os @if(env::LIBC)</h3><pre><code class="lang-c3">fn void*! native_fopen(String filename, String mode) @inline</code></pre><pre><code class="lang-c3">fn usz! native_fread(CFile file, char[] buffer) @inline</code></pre><pre><code class="lang-c3">fn void*! native_freopen(void* file, String filename, String mode) @inline</code></pre><pre><code class="lang-c3">fn void! native_fseek(void* file, isz offset, Seek seek_mode) @inline</code></pre><pre><code class="lang-c3">fn usz! native_ftell(CFile file) @inline</code></pre><pre><code class="lang-c3">fn usz! native_fwrite(CFile file, char[] buffer) @inline</code></pre><pre><code class="lang-c3">fn void! native_remove(String filename)</code></pre><pre><code class="lang-c3">fn Path! native_temp_directory(Allocator allocator = allocator::heap()) @if(!env::WIN<span class="number">32</span>)</code></pre><pre><code class="lang-c3">fn Path! native_temp_directory(Allocator allocator = allocator::heap()) @if(env::WIN<span class="number">32</span>)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdioos-ifenvno_libc">std::io::os @if(env::NO_LIBC)</h3><pre><code class="lang-c3">fn void*! native_fopen(String filename, String mode) @inline</code></pre><pre><code class="lang-c3">fn usz! native_fread(CFile file, char[] buffer) @inline</code></pre><pre><code class="lang-c3">fn void*! native_freopen(void* file, String filename, String mode) @inline</code></pre><pre><code class="lang-c3">fn void! native_fseek(void* file, isz offset, Seek seek_mode) @inline</code></pre><pre><code class="lang-c3">fn usz! native_ftell(CFile file) @inline</code></pre><pre><code class="lang-c3">fn usz! native_fwrite(CFile file, char[] buffer) @inline</code></pre><pre><code class="lang-c3">fn void! native_remove(String filename) @inline</code></pre><pre><code class="lang-c3">macro Path! native_temp_directory(Allocator allocator = allocator::heap())</code></pre><h3 id="pre-conditions-for-macros-stdio-stdioos-ifenvposix">std::io::os @if(env::POSIX)</h3><pre><code class="lang-c3">fn PathList! native_ls(Path dir, bool no_dirs, bool no_symlinks, String mask, Allocator allocator)</code></pre><pre><code class="lang-c3">fn void! native_rmtree(Path dir)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdioos-ifenvwin32">std::io::os @if(env::WIN32)</h3><pre><code class="lang-c3">fn PathList! native_ls(Path dir, bool no_dirs, bool no_symlinks, String mask, Allocator allocator)</code></pre><pre><code class="lang-c3">fn void! native_rmtree(Path path)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdiopath">std::io::path</h3><pre><code class="lang-c3">enum MkdirPermissions</code></pre><pre><code class="lang-c3">enum PathEnv</code></pre><pre><code class="lang-c3">fault PathResult</code></pre><pre><code class="lang-c3">struct Path (Printable)</code></pre><pre><code class="lang-c3">fn Path! Path.absolute(self, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Path! Path.append(self, String filename, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn ZString Path.as_zstr(self)</code></pre><pre><code class="lang-c3">fn String Path.basename(self)</code></pre><pre><code class="lang-c3">fn String Path.dirname(self)</code></pre><pre><code class="lang-c3">fn bool Path.equals(self, Path p<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn String! Path.extension(self)</code></pre><pre><code class="lang-c3">fn void Path.free(self)</code></pre><pre><code class="lang-c3">fn bool Path.has_suffix(self, String str)</code></pre><pre><code class="lang-c3">fn bool! Path.is_absolute(self)</code></pre><pre><code class="lang-c3">fn Path! Path.parent(self)</code></pre><pre><code class="lang-c3">fn String Path.root_directory(self)</code></pre><pre><code class="lang-c3">fn String Path.str_view(self) @inline</code></pre><pre><code class="lang-c3">fn Path! Path.tappend(self, String filename)</code></pre><pre><code class="lang-c3">fn usz! Path.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn String Path.to_new_string(&amp;self, Allocator allocator = allocator::heap()) @dynamic</code></pre><pre><code class="lang-c3">fn String Path.volume_name(self)</code></pre><pre><code class="lang-c3">fn bool! Path.walk(self, PathWalker w, void* data)</code></pre><pre><code class="lang-c3">fn void! chdir(Path path)</code></pre><pre><code class="lang-c3">fn void! delete(Path path)</code></pre><pre><code class="lang-c3">fn bool exists(Path path)</code></pre><pre><code class="lang-c3">fn usz! file_size(Path path)</code></pre><pre><code class="lang-c3">fn Path! getcwd(Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn bool is_dir(Path path)</code></pre><pre><code class="lang-c3">fn bool is_file(Path path)</code></pre><pre><code class="lang-c3">macro bool is_posix_separator(char c)</code></pre><pre><code class="lang-c3">macro bool is_reserved_path_char(char c, PathEnv path_env = DEFAULT_PATH_ENV)</code></pre><pre><code class="lang-c3">macro bool is_reserved_win<span class="number">32</span>_path_char(char c)</code></pre><pre><code class="lang-c3">macro bool is_separator(char c, PathEnv path_env = DEFAULT_PATH_ENV)</code></pre><pre><code class="lang-c3">macro bool is_win<span class="number">32</span>_separator(char c)</code></pre><pre><code class="lang-c3">fn PathList! ls(Path dir, bool no_dirs = false, bool no_symlinks = false, String mask = <span class="string">""</span>, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn bool! mkdir(Path path, bool recursive = false, MkdirPermissions permissions = NORMAL)</code></pre><pre><code class="lang-c3">fn Path! new(String path, Allocator allocator = allocator::heap(), PathEnv path_env = DEFAULT_PATH_ENV)</code></pre><pre><code class="lang-c3">fn Path! new_posix(String path, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Path! new_win<span class="number">32</span>_wstring(WString path, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Path! new_windows(String path, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String! normalize(String path_str, PathEnv path_env = DEFAULT_PATH_ENV)</code></pre><pre><code class="lang-c3">fn bool! rmdir(Path path)</code></pre><pre><code class="lang-c3">fn void! rmtree(Path path)</code></pre><pre><code class="lang-c3">fn Path! temp_directory(Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Path! temp_new(String path, PathEnv path_env = DEFAULT_PATH_ENV)</code></pre><pre><code class="lang-c3">fn Path! tgetcwd()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdmath">std::math</h3><pre><code class="lang-c3">enum RoundingMode : int</code></pre><pre><code class="lang-c3">fault MathError</code></pre><pre><code class="lang-c3">fault MatrixError</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span> __ashlti<span class="number">3</span>(int<span class="number">128</span> a, uint b) @extern(<span class="string">"__ashlti<span class="number">3</span>"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span> __ashrti<span class="number">3</span>(int<span class="number">128</span> a, uint b) @extern(<span class="string">"__ashrti<span class="number">3</span>"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span> __divti<span class="number">3</span>(int<span class="number">128</span> a, int<span class="number">128</span> b) @extern(<span class="string">"__divti<span class="number">3</span>"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span> __fixdfti(double a) @weak @extern(<span class="string">"__fixdfti"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span> __fixsfti(float a) @weak @extern(<span class="string">"__fixsfti"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> __fixunsdfti(double a) @weak @extern(<span class="string">"__fixunsdfti"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> __fixunssfti(float a) @weak @extern(<span class="string">"__fixunssfti"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn double __floattidf(int<span class="number">128</span> a) @extern(<span class="string">"__floattidf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float __floattisf(int<span class="number">128</span> a) @extern(<span class="string">"__floattisf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double __floatuntidf(uint<span class="number">128</span> a) @extern(<span class="string">"__floatuntidf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float __floatuntisf(uint<span class="number">128</span> a) @extern(<span class="string">"__floatuntisf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> __lshrti<span class="number">3</span>(uint<span class="number">128</span> a, uint b) @extern(<span class="string">"__lshrti<span class="number">3</span>"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span> __modti<span class="number">3</span>(int<span class="number">128</span> a, int<span class="number">128</span> b) @extern(<span class="string">"__modti<span class="number">3</span>"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn int<span class="number">128</span> __multi<span class="number">3</span>(int<span class="number">128</span> a, int<span class="number">128</span> b) @extern(<span class="string">"__multi<span class="number">3</span>"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double __roundeven(double d) @extern(<span class="string">"roundeven"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float __roundevenf(float f) @extern(<span class="string">"roundevenf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> __udivti<span class="number">3</span>(uint<span class="number">128</span> n, uint<span class="number">128</span> d) @extern(<span class="string">"__udivti<span class="number">3</span>"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> __umodti<span class="number">3</span>(uint<span class="number">128</span> n, uint<span class="number">128</span> d) @extern(<span class="string">"__umodti<span class="number">3</span>"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double _frexp(double x, int* e)</code></pre><pre><code class="lang-c3">fn float _frexpf(float x, int* e)</code></pre><pre><code class="lang-c3">macro abs(x)</code></pre><pre><code class="lang-c3">macro acos(x)</code></pre><pre><code class="lang-c3">macro acosh(x)</code></pre><pre><code class="lang-c3">macro asin(x)</code></pre><pre><code class="lang-c3">macro asinh(x)</code></pre><pre><code class="lang-c3">macro atan(x)</code></pre><pre><code class="lang-c3">macro atan<span class="number">2</span>(x, y)</code></pre><pre><code class="lang-c3">macro atanh(x)</code></pre><pre><code class="lang-c3">macro bool bool[&lt;*&gt;].and(bool[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] bool[&lt;*&gt;].comp_eq(bool[&lt;*&gt;] x, bool[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] bool[&lt;*&gt;].comp_ge(bool[&lt;*&gt;] x, bool[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] bool[&lt;*&gt;].comp_gt(bool[&lt;*&gt;] x, bool[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] bool[&lt;*&gt;].comp_le(bool[&lt;*&gt;] x, bool[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] bool[&lt;*&gt;].comp_lt(bool[&lt;*&gt;] x, bool[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] bool[&lt;*&gt;].comp_ne(bool[&lt;*&gt;] x, bool[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool bool[&lt;*&gt;].max(bool[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool bool[&lt;*&gt;].min(bool[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool bool[&lt;*&gt;].or(bool[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool bool[&lt;*&gt;].product(bool[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool bool[&lt;*&gt;].sum(bool[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool bool[&lt;*&gt;].xor(bool[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ceil(x)</code></pre><pre><code class="lang-c3">macro bool char.is_even(char x)</code></pre><pre><code class="lang-c3">macro bool char.is_odd(char x)</code></pre><pre><code class="lang-c3">macro char! char.overflow_add(char x, char y)</code></pre><pre><code class="lang-c3">macro char! char.overflow_mul(char x, char y)</code></pre><pre><code class="lang-c3">macro char! char.overflow_sub(char x, char y)</code></pre><pre><code class="lang-c3">macro char char.sat_add(char x, char y)</code></pre><pre><code class="lang-c3">macro char char.sat_mul(char x, char y)</code></pre><pre><code class="lang-c3">macro char char.sat_shl(char x, char y)</code></pre><pre><code class="lang-c3">macro char char.sat_sub(char x, char y)</code></pre><pre><code class="lang-c3">macro char char[&lt;*&gt;].and(char[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] char[&lt;*&gt;].comp_eq(char[&lt;*&gt;] x, char[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] char[&lt;*&gt;].comp_ge(char[&lt;*&gt;] x, char[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] char[&lt;*&gt;].comp_gt(char[&lt;*&gt;] x, char[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] char[&lt;*&gt;].comp_le(char[&lt;*&gt;] x, char[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] char[&lt;*&gt;].comp_lt(char[&lt;*&gt;] x, char[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] char[&lt;*&gt;].comp_ne(char[&lt;*&gt;] x, char[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro char char[&lt;*&gt;].max(char[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro char char[&lt;*&gt;].min(char[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro char char[&lt;*&gt;].or(char[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro char char[&lt;*&gt;].product(char[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro char char[&lt;*&gt;].sum(char[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro char char[&lt;*&gt;].xor(char[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro clamp(x, lower, upper)</code></pre><pre><code class="lang-c3">macro copysign(mag, sgn)</code></pre><pre><code class="lang-c3">macro cos(x)</code></pre><pre><code class="lang-c3">macro cosec(x)</code></pre><pre><code class="lang-c3">macro cosech(x)</code></pre><pre><code class="lang-c3">macro cosh(x)</code></pre><pre><code class="lang-c3">macro cotan(x)</code></pre><pre><code class="lang-c3">macro cotanh(x)</code></pre><pre><code class="lang-c3">macro deg_to_rad(x)</code></pre><pre><code class="lang-c3">macro double double.ceil(double x)</code></pre><pre><code class="lang-c3">macro double double.clamp(double x, double lower, double upper)</code></pre><pre><code class="lang-c3">macro double double.copysign(double mag, double sgn)</code></pre><pre><code class="lang-c3">macro double double.floor(double x)</code></pre><pre><code class="lang-c3">macro double double.fma(double a, double b, double c)</code></pre><pre><code class="lang-c3">macro uint double.high_word(double d)</code></pre><pre><code class="lang-c3">macro uint double.low_word(double d)</code></pre><pre><code class="lang-c3">macro double double.muladd(double a, double b, double c)</code></pre><pre><code class="lang-c3">macro double double.nearbyint(double x)</code></pre><pre><code class="lang-c3">macro double double.pow(double x, exp)</code></pre><pre><code class="lang-c3">macro double double.rint(double x)</code></pre><pre><code class="lang-c3">macro double double.round(double x)</code></pre><pre><code class="lang-c3">macro double double.roundeven(double x)</code></pre><pre><code class="lang-c3">macro double double.trunc(double x)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].ceil(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].clamp(double[&lt;*&gt;] x, double[&lt;*&gt;] lower, double[&lt;*&gt;] upper)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] double[&lt;*&gt;].comp_eq(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] double[&lt;*&gt;].comp_ge(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] double[&lt;*&gt;].comp_gt(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] double[&lt;*&gt;].comp_le(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] double[&lt;*&gt;].comp_lt(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] double[&lt;*&gt;].comp_ne(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].copysign(double[&lt;*&gt;] mag, double[&lt;*&gt;] sgn)</code></pre><pre><code class="lang-c3">macro double double[&lt;*&gt;].distance(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro double double[&lt;*&gt;].dot(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool double[&lt;*&gt;].equals(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].floor(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].fma(double[&lt;*&gt;] a, double[&lt;*&gt;] b, double[&lt;*&gt;] c)</code></pre><pre><code class="lang-c3">macro double double[&lt;*&gt;].length(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].lerp(double[&lt;*&gt;] x, double[&lt;*&gt;] y, double amount)</code></pre><pre><code class="lang-c3">macro double double[&lt;*&gt;].max(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double double[&lt;*&gt;].min(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].nearbyint(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].normalize(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].pow(double[&lt;*&gt;] x, exp)</code></pre><pre><code class="lang-c3">macro double double[&lt;*&gt;].product(double[&lt;*&gt;] x, double start = <span class="number"><span class="number">1</span>.<span class="number">0</span></span>)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].reflect(double[&lt;*&gt;] x, double[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].rint(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].round(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].roundeven(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro double double[&lt;*&gt;].sum(double[&lt;*&gt;] x, double start = <span class="number"><span class="number">0</span>.<span class="number">0</span></span>)</code></pre><pre><code class="lang-c3">macro double[&lt;*&gt;] double[&lt;*&gt;].trunc(double[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro exp(x)</code></pre><pre><code class="lang-c3">macro exp<span class="number">2</span>(x)</code></pre><pre><code class="lang-c3">macro float float.ceil(float x)</code></pre><pre><code class="lang-c3">macro float float.clamp(float x, float lower, float upper)</code></pre><pre><code class="lang-c3">macro float float.copysign(float mag, float sgn)</code></pre><pre><code class="lang-c3">macro float float.floor(float x)</code></pre><pre><code class="lang-c3">macro float float.fma(float a, float b, float c)</code></pre><pre><code class="lang-c3">macro float float.muladd(float a, float b, float c)</code></pre><pre><code class="lang-c3">macro float float.nearbyint(float x)</code></pre><pre><code class="lang-c3">macro float float.pow(float x, exp)</code></pre><pre><code class="lang-c3">macro float float.rint(float x)</code></pre><pre><code class="lang-c3">macro float float.round(float x)</code></pre><pre><code class="lang-c3">macro float float.roundeven(float x)</code></pre><pre><code class="lang-c3">macro float float.trunc(float x)</code></pre><pre><code class="lang-c3">macro uint float.word(float d)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].ceil(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].clamp(float[&lt;*&gt;] x, float[&lt;*&gt;] lower, float[&lt;*&gt;] upper)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] float[&lt;*&gt;].comp_eq(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] float[&lt;*&gt;].comp_ge(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] float[&lt;*&gt;].comp_gt(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] float[&lt;*&gt;].comp_le(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] float[&lt;*&gt;].comp_lt(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] float[&lt;*&gt;].comp_ne(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].copysign(float[&lt;*&gt;] mag, float[&lt;*&gt;] sgn)</code></pre><pre><code class="lang-c3">macro float float[&lt;*&gt;].distance(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro float float[&lt;*&gt;].dot(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool float[&lt;*&gt;].equals(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].floor(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].fma(float[&lt;*&gt;] a, float[&lt;*&gt;] b, float[&lt;*&gt;] c)</code></pre><pre><code class="lang-c3">macro float float[&lt;*&gt;].length(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].lerp(float[&lt;*&gt;] x, float[&lt;*&gt;] y, float amount)</code></pre><pre><code class="lang-c3">macro float float[&lt;*&gt;].max(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float float[&lt;*&gt;].min(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].nearbyint(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].normalize(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].pow(float[&lt;*&gt;] x, exp)</code></pre><pre><code class="lang-c3">macro float float[&lt;*&gt;].product(float[&lt;*&gt;] x, float start = <span class="number"><span class="number">1</span>.<span class="number">0</span></span>)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].reflect(float[&lt;*&gt;] x, float[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].rint(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].round(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].roundeven(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro float float[&lt;*&gt;].sum(float[&lt;*&gt;] x, float start = <span class="number"><span class="number">0</span>.<span class="number">0</span></span>)</code></pre><pre><code class="lang-c3">macro float[&lt;*&gt;] float[&lt;*&gt;].trunc(float[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro floor(x)</code></pre><pre><code class="lang-c3">macro fma(a, b, c)</code></pre><pre><code class="lang-c3">macro frexp(x, int* e)</code></pre><pre><code class="lang-c3">macro hypot(x, y)</code></pre><pre><code class="lang-c3">macro bool ichar.is_even(ichar x)</code></pre><pre><code class="lang-c3">macro bool ichar.is_odd(ichar x)</code></pre><pre><code class="lang-c3">macro ichar! ichar.overflow_add(ichar x, ichar y)</code></pre><pre><code class="lang-c3">macro ichar! ichar.overflow_mul(ichar x, ichar y)</code></pre><pre><code class="lang-c3">macro ichar! ichar.overflow_sub(ichar x, ichar y)</code></pre><pre><code class="lang-c3">macro ichar ichar.sat_add(ichar x, ichar y)</code></pre><pre><code class="lang-c3">macro ichar ichar.sat_mul(ichar x, ichar y)</code></pre><pre><code class="lang-c3">macro ichar ichar.sat_shl(ichar x, ichar y)</code></pre><pre><code class="lang-c3">macro ichar ichar.sat_sub(ichar x, ichar y)</code></pre><pre><code class="lang-c3">macro ichar ichar[&lt;*&gt;].and(ichar[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ichar[&lt;*&gt;].comp_eq(ichar[&lt;*&gt;] x, ichar[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ichar[&lt;*&gt;].comp_ge(ichar[&lt;*&gt;] x, ichar[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ichar[&lt;*&gt;].comp_gt(ichar[&lt;*&gt;] x, ichar[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ichar[&lt;*&gt;].comp_le(ichar[&lt;*&gt;] x, ichar[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ichar[&lt;*&gt;].comp_lt(ichar[&lt;*&gt;] x, ichar[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ichar[&lt;*&gt;].comp_ne(ichar[&lt;*&gt;] x, ichar[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro ichar ichar[&lt;*&gt;].max(ichar[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ichar ichar[&lt;*&gt;].min(ichar[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ichar ichar[&lt;*&gt;].or(ichar[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ichar ichar[&lt;*&gt;].product(ichar[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ichar ichar[&lt;*&gt;].sum(ichar[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ichar ichar[&lt;*&gt;].xor(ichar[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool int.is_even(int x)</code></pre><pre><code class="lang-c3">macro bool int.is_odd(int x)</code></pre><pre><code class="lang-c3">macro int! int.overflow_add(int x, int y)</code></pre><pre><code class="lang-c3">macro int! int.overflow_mul(int x, int y)</code></pre><pre><code class="lang-c3">macro int! int.overflow_sub(int x, int y)</code></pre><pre><code class="lang-c3">macro int int.sat_add(int x, int y)</code></pre><pre><code class="lang-c3">macro int int.sat_mul(int x, int y)</code></pre><pre><code class="lang-c3">macro int int.sat_shl(int x, int y)</code></pre><pre><code class="lang-c3">macro int int.sat_sub(int x, int y)</code></pre><pre><code class="lang-c3">macro bool int<span class="number">128</span>.is_even(int<span class="number">128</span> x)</code></pre><pre><code class="lang-c3">macro bool int<span class="number">128</span>.is_odd(int<span class="number">128</span> x)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>! int<span class="number">128</span>.overflow_add(int<span class="number">128</span> x, int<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>! int<span class="number">128</span>.overflow_mul(int<span class="number">128</span> x, int<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span>! int<span class="number">128</span>.overflow_sub(int<span class="number">128</span> x, int<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>.sat_add(int<span class="number">128</span> x, int<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>.sat_mul(int<span class="number">128</span> x, int<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>.sat_shl(int<span class="number">128</span> x, int<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>.sat_sub(int<span class="number">128</span> x, int<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>[&lt;*&gt;].and(int<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].comp_eq(int<span class="number">128</span>[&lt;*&gt;] x, int<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].comp_ge(int<span class="number">128</span>[&lt;*&gt;] x, int<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].comp_gt(int<span class="number">128</span>[&lt;*&gt;] x, int<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].comp_le(int<span class="number">128</span>[&lt;*&gt;] x, int<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].comp_lt(int<span class="number">128</span>[&lt;*&gt;] x, int<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int<span class="number">128</span>[&lt;*&gt;].comp_ne(int<span class="number">128</span>[&lt;*&gt;] x, int<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>[&lt;*&gt;].max(int<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>[&lt;*&gt;].min(int<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>[&lt;*&gt;].or(int<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>[&lt;*&gt;].product(int<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>[&lt;*&gt;].sum(int<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int<span class="number">128</span> int<span class="number">128</span>[&lt;*&gt;].xor(int<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int int[&lt;*&gt;].and(int[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int[&lt;*&gt;].comp_eq(int[&lt;*&gt;] x, int[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int[&lt;*&gt;].comp_ge(int[&lt;*&gt;] x, int[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int[&lt;*&gt;].comp_gt(int[&lt;*&gt;] x, int[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int[&lt;*&gt;].comp_le(int[&lt;*&gt;] x, int[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int[&lt;*&gt;].comp_lt(int[&lt;*&gt;] x, int[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] int[&lt;*&gt;].comp_ne(int[&lt;*&gt;] x, int[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro int int[&lt;*&gt;].max(int[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int int[&lt;*&gt;].min(int[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int int[&lt;*&gt;].or(int[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int int[&lt;*&gt;].product(int[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int int[&lt;*&gt;].sum(int[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro int int[&lt;*&gt;].xor(int[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool is_even(x)</code></pre><pre><code class="lang-c3">macro bool is_finite(x)</code></pre><pre><code class="lang-c3">macro is_inf(x)</code></pre><pre><code class="lang-c3">macro is_nan(x)</code></pre><pre><code class="lang-c3">macro bool is_odd(x)</code></pre><pre><code class="lang-c3">macro bool is_power_of_<span class="number">2</span>(x)</code></pre><pre><code class="lang-c3">macro ln(x)</code></pre><pre><code class="lang-c3">macro log(x, base)</code></pre><pre><code class="lang-c3">macro log<span class="number">10</span>(x)</code></pre><pre><code class="lang-c3">macro log<span class="number">2</span>(x)</code></pre><pre><code class="lang-c3">macro bool long.is_even(long x)</code></pre><pre><code class="lang-c3">macro bool long.is_odd(long x)</code></pre><pre><code class="lang-c3">macro long! long.overflow_add(long x, long y)</code></pre><pre><code class="lang-c3">macro long! long.overflow_mul(long x, long y)</code></pre><pre><code class="lang-c3">macro long! long.overflow_sub(long x, long y)</code></pre><pre><code class="lang-c3">macro long long.sat_add(long x, long y)</code></pre><pre><code class="lang-c3">macro long long.sat_mul(long x, long y)</code></pre><pre><code class="lang-c3">macro long long.sat_shl(long x, long y)</code></pre><pre><code class="lang-c3">macro long long.sat_sub(long x, long y)</code></pre><pre><code class="lang-c3">macro long long[&lt;*&gt;].and(long[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] long[&lt;*&gt;].comp_eq(long[&lt;*&gt;] x, long[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] long[&lt;*&gt;].comp_ge(long[&lt;*&gt;] x, long[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] long[&lt;*&gt;].comp_gt(long[&lt;*&gt;] x, long[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] long[&lt;*&gt;].comp_le(long[&lt;*&gt;] x, long[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] long[&lt;*&gt;].comp_lt(long[&lt;*&gt;] x, long[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] long[&lt;*&gt;].comp_ne(long[&lt;*&gt;] x, long[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro long long[&lt;*&gt;].max(long[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro long long[&lt;*&gt;].min(long[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro long long[&lt;*&gt;].or(long[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro long long[&lt;*&gt;].product(long[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro long long[&lt;*&gt;].sum(long[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro long long[&lt;*&gt;].xor(long[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro max(x, y, ...)</code></pre><pre><code class="lang-c3">macro min(x, y, ...)</code></pre><pre><code class="lang-c3">macro muladd(a, b, c)</code></pre><pre><code class="lang-c3">macro nearbyint(x)</code></pre><pre><code class="lang-c3">macro next_power_of_<span class="number">2</span>(x)</code></pre><pre><code class="lang-c3">macro pow(x, exp)</code></pre><pre><code class="lang-c3">macro rint(x)</code></pre><pre><code class="lang-c3">macro round(x)</code></pre><pre><code class="lang-c3">macro round_to_decimals(x, int decimal_places)</code></pre><pre><code class="lang-c3">macro roundeven(x)</code></pre><pre><code class="lang-c3">macro double scalbn(double x, int n)</code></pre><pre><code class="lang-c3">macro sec(x)</code></pre><pre><code class="lang-c3">macro sech(x)</code></pre><pre><code class="lang-c3">macro select(bool[&lt;*&gt;] mask, then_value, else_value)</code></pre><pre><code class="lang-c3">macro bool short.is_even(short x)</code></pre><pre><code class="lang-c3">macro bool short.is_odd(short x)</code></pre><pre><code class="lang-c3">macro short! short.overflow_add(short x, short y)</code></pre><pre><code class="lang-c3">macro short! short.overflow_mul(short x, short y)</code></pre><pre><code class="lang-c3">macro short! short.overflow_sub(short x, short y)</code></pre><pre><code class="lang-c3">macro short short.sat_add(short x, short y)</code></pre><pre><code class="lang-c3">macro short short.sat_mul(short x, short y)</code></pre><pre><code class="lang-c3">macro short short.sat_shl(short x, short y)</code></pre><pre><code class="lang-c3">macro short short.sat_sub(short x, short y)</code></pre><pre><code class="lang-c3">macro short short[&lt;*&gt;].and(short[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] short[&lt;*&gt;].comp_eq(short[&lt;*&gt;] x, short[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] short[&lt;*&gt;].comp_ge(short[&lt;*&gt;] x, short[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] short[&lt;*&gt;].comp_gt(short[&lt;*&gt;] x, short[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] short[&lt;*&gt;].comp_le(short[&lt;*&gt;] x, short[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] short[&lt;*&gt;].comp_lt(short[&lt;*&gt;] x, short[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] short[&lt;*&gt;].comp_ne(short[&lt;*&gt;] x, short[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro short short[&lt;*&gt;].max(short[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro short short[&lt;*&gt;].min(short[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro short short[&lt;*&gt;].or(short[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro short short[&lt;*&gt;].product(short[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro short short[&lt;*&gt;].sum(short[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro short short[&lt;*&gt;].xor(short[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro sign(x)</code></pre><pre><code class="lang-c3">macro int signbit(x)</code></pre><pre><code class="lang-c3">macro sin(x)</code></pre><pre><code class="lang-c3">macro sincos(x, y)</code></pre><pre><code class="lang-c3">macro sinh(x)</code></pre><pre><code class="lang-c3">macro sqr(x)</code></pre><pre><code class="lang-c3">macro sqrt(x)</code></pre><pre><code class="lang-c3">macro tan(x)</code></pre><pre><code class="lang-c3">macro tanh(x)</code></pre><pre><code class="lang-c3">macro trunc(x)</code></pre><pre><code class="lang-c3">macro bool uint.is_even(uint x)</code></pre><pre><code class="lang-c3">macro bool uint.is_odd(uint x)</code></pre><pre><code class="lang-c3">macro uint! uint.overflow_add(uint x, uint y)</code></pre><pre><code class="lang-c3">macro uint! uint.overflow_mul(uint x, uint y)</code></pre><pre><code class="lang-c3">macro uint! uint.overflow_sub(uint x, uint y)</code></pre><pre><code class="lang-c3">macro uint uint.sat_add(uint x, uint y)</code></pre><pre><code class="lang-c3">macro uint uint.sat_mul(uint x, uint y)</code></pre><pre><code class="lang-c3">macro uint uint.sat_shl(uint x, uint y)</code></pre><pre><code class="lang-c3">macro uint uint.sat_sub(uint x, uint y)</code></pre><pre><code class="lang-c3">macro bool uint<span class="number">128</span>.is_even(uint<span class="number">128</span> x)</code></pre><pre><code class="lang-c3">macro bool uint<span class="number">128</span>.is_odd(uint<span class="number">128</span> x)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>! uint<span class="number">128</span>.overflow_add(uint<span class="number">128</span> x, uint<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>! uint<span class="number">128</span>.overflow_mul(uint<span class="number">128</span> x, uint<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span>! uint<span class="number">128</span>.overflow_sub(uint<span class="number">128</span> x, uint<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>.sat_add(uint<span class="number">128</span> x, uint<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>.sat_mul(uint<span class="number">128</span> x, uint<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>.sat_shl(uint<span class="number">128</span> x, uint<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>.sat_sub(uint<span class="number">128</span> x, uint<span class="number">128</span> y)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>[&lt;*&gt;].and(uint<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].comp_eq(uint<span class="number">128</span>[&lt;*&gt;] x, uint<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].comp_ge(uint<span class="number">128</span>[&lt;*&gt;] x, uint<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].comp_gt(uint<span class="number">128</span>[&lt;*&gt;] x, uint<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].comp_le(uint<span class="number">128</span>[&lt;*&gt;] x, uint<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].comp_lt(uint<span class="number">128</span>[&lt;*&gt;] x, uint<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint<span class="number">128</span>[&lt;*&gt;].comp_ne(uint<span class="number">128</span>[&lt;*&gt;] x, uint<span class="number">128</span>[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>[&lt;*&gt;].max(uint<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>[&lt;*&gt;].min(uint<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>[&lt;*&gt;].or(uint<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>[&lt;*&gt;].product(uint<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>[&lt;*&gt;].sum(uint<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> uint<span class="number">128</span>[&lt;*&gt;].xor(uint<span class="number">128</span>[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint uint[&lt;*&gt;].and(uint[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint[&lt;*&gt;].comp_eq(uint[&lt;*&gt;] x, uint[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint[&lt;*&gt;].comp_ge(uint[&lt;*&gt;] x, uint[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint[&lt;*&gt;].comp_gt(uint[&lt;*&gt;] x, uint[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint[&lt;*&gt;].comp_le(uint[&lt;*&gt;] x, uint[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint[&lt;*&gt;].comp_lt(uint[&lt;*&gt;] x, uint[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] uint[&lt;*&gt;].comp_ne(uint[&lt;*&gt;] x, uint[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro uint uint[&lt;*&gt;].max(uint[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint uint[&lt;*&gt;].min(uint[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint uint[&lt;*&gt;].or(uint[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint uint[&lt;*&gt;].product(uint[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint uint[&lt;*&gt;].sum(uint[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro uint uint[&lt;*&gt;].xor(uint[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool ulong.is_even(ulong x)</code></pre><pre><code class="lang-c3">macro bool ulong.is_odd(ulong x)</code></pre><pre><code class="lang-c3">macro ulong! ulong.overflow_add(ulong x, ulong y)</code></pre><pre><code class="lang-c3">macro ulong! ulong.overflow_mul(ulong x, ulong y)</code></pre><pre><code class="lang-c3">macro ulong! ulong.overflow_sub(ulong x, ulong y)</code></pre><pre><code class="lang-c3">macro ulong ulong.sat_add(ulong x, ulong y)</code></pre><pre><code class="lang-c3">macro ulong ulong.sat_mul(ulong x, ulong y)</code></pre><pre><code class="lang-c3">macro ulong ulong.sat_shl(ulong x, ulong y)</code></pre><pre><code class="lang-c3">macro ulong ulong.sat_sub(ulong x, ulong y)</code></pre><pre><code class="lang-c3">macro ulong ulong[&lt;*&gt;].and(ulong[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ulong[&lt;*&gt;].comp_eq(ulong[&lt;*&gt;] x, ulong[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ulong[&lt;*&gt;].comp_ge(ulong[&lt;*&gt;] x, ulong[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ulong[&lt;*&gt;].comp_gt(ulong[&lt;*&gt;] x, ulong[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ulong[&lt;*&gt;].comp_le(ulong[&lt;*&gt;] x, ulong[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ulong[&lt;*&gt;].comp_lt(ulong[&lt;*&gt;] x, ulong[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ulong[&lt;*&gt;].comp_ne(ulong[&lt;*&gt;] x, ulong[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro ulong ulong[&lt;*&gt;].max(ulong[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ulong ulong[&lt;*&gt;].min(ulong[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ulong ulong[&lt;*&gt;].or(ulong[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ulong ulong[&lt;*&gt;].product(ulong[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ulong ulong[&lt;*&gt;].sum(ulong[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ulong ulong[&lt;*&gt;].xor(ulong[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool ushort.is_even(ushort x)</code></pre><pre><code class="lang-c3">macro bool ushort.is_odd(ushort x)</code></pre><pre><code class="lang-c3">macro ushort! ushort.overflow_add(ushort x, ushort y)</code></pre><pre><code class="lang-c3">macro ushort! ushort.overflow_mul(ushort x, ushort y)</code></pre><pre><code class="lang-c3">macro ushort! ushort.overflow_sub(ushort x, ushort y)</code></pre><pre><code class="lang-c3">macro ushort ushort.sat_add(ushort x, ushort y)</code></pre><pre><code class="lang-c3">macro ushort ushort.sat_mul(ushort x, ushort y)</code></pre><pre><code class="lang-c3">macro ushort ushort.sat_shl(ushort x, ushort y)</code></pre><pre><code class="lang-c3">macro ushort ushort.sat_sub(ushort x, ushort y)</code></pre><pre><code class="lang-c3">macro ushort ushort[&lt;*&gt;].and(ushort[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ushort[&lt;*&gt;].comp_eq(ushort[&lt;*&gt;] x, ushort[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ushort[&lt;*&gt;].comp_ge(ushort[&lt;*&gt;] x, ushort[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ushort[&lt;*&gt;].comp_gt(ushort[&lt;*&gt;] x, ushort[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ushort[&lt;*&gt;].comp_le(ushort[&lt;*&gt;] x, ushort[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ushort[&lt;*&gt;].comp_lt(ushort[&lt;*&gt;] x, ushort[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro bool[&lt;*&gt;] ushort[&lt;*&gt;].comp_ne(ushort[&lt;*&gt;] x, ushort[&lt;*&gt;] y)</code></pre><pre><code class="lang-c3">macro ushort ushort[&lt;*&gt;].max(ushort[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ushort ushort[&lt;*&gt;].min(ushort[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ushort ushort[&lt;*&gt;].or(ushort[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ushort ushort[&lt;*&gt;].product(ushort[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ushort ushort[&lt;*&gt;].sum(ushort[&lt;*&gt;] x)</code></pre><pre><code class="lang-c3">macro ushort ushort[&lt;*&gt;].xor(ushort[&lt;*&gt;] x)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdmathcomplexreal">std::math::complex(&lt;Real&gt;)</h3><pre><code class="lang-c3">macro Complex Complex.add(self, Complex b)</code></pre><pre><code class="lang-c3">macro Complex Complex.add_each(self, Real b)</code></pre><pre><code class="lang-c3">macro Complex Complex.div(self, Complex b)</code></pre><pre><code class="lang-c3">macro Complex Complex.mul(self, Complex b)</code></pre><pre><code class="lang-c3">macro Complex Complex.scale(self, Real s)</code></pre><pre><code class="lang-c3">macro Complex Complex.sub(self, Complex b)</code></pre><pre><code class="lang-c3">macro Complex Complex.sub_each(self, Real b)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdmatheasing">std::math::easing</h3><pre><code class="lang-c3">fn float back_in(float t, float b, float c, float d, float s = <span class="number"><span class="number">1</span>.<span class="number">70158</span></span>f) @inline</code></pre><pre><code class="lang-c3">fn float back_inout(float t, float b, float c, float d, float s = <span class="number"><span class="number">1</span>.<span class="number">70158</span></span>f) @inline</code></pre><pre><code class="lang-c3">fn float back_out(float t, float b, float c, float d, float s = <span class="number"><span class="number">1</span>.<span class="number">70158</span></span>f) @inline</code></pre><pre><code class="lang-c3">fn float bounce_in(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float bounce_inout(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float bounce_out(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float circ_in(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float circ_inout(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float circ_out(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float cubic_in(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float cubic_inout(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float cubic_out(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float elastic_in(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float elastic_inout(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float elastic_out(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float expo_in(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float expo_inout(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float expo_out(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float linear_in(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float linear_inout(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float linear_none(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float linear_out(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float quad_in(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float quad_inout(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float quad_out(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float sine_in(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float sine_inout(float t, float b, float c, float d) @inline</code></pre><pre><code class="lang-c3">fn float sine_out(float t, float b, float c, float d) @inline</code></pre><h3 id="pre-conditions-for-macros-stdio-stdmathmatrixreal">std::math::matrix(&lt;Real&gt;)</h3><pre><code class="lang-c3">struct Matrix<span class="number">2</span>x<span class="number">2</span></code></pre><pre><code class="lang-c3">struct Matrix<span class="number">3</span>x<span class="number">3</span></code></pre><pre><code class="lang-c3">struct Matrix<span class="number">4</span>x<span class="number">4</span></code></pre><pre><code class="lang-c3">fn Matrix<span class="number">2</span>x<span class="number">2</span> Matrix<span class="number">2</span>x<span class="number">2</span>.add(&amp;self, Matrix<span class="number">2</span>x<span class="number">2</span> mat<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">2</span>x<span class="number">2</span> Matrix<span class="number">2</span>x<span class="number">2</span>.adjoint(&amp;self)</code></pre><pre><code class="lang-c3">fn Real[&lt;<span class="number">2</span>&gt;] Matrix<span class="number">2</span>x<span class="number">2</span>.apply(&amp;self, Real[&lt;<span class="number">2</span>&gt;] vec)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">2</span>x<span class="number">2</span> Matrix<span class="number">2</span>x<span class="number">2</span>.component_mul(&amp;self, Real s)</code></pre><pre><code class="lang-c3">fn Real Matrix<span class="number">2</span>x<span class="number">2</span>.determinant(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">2</span>x<span class="number">2</span>! Matrix<span class="number">2</span>x<span class="number">2</span>.inverse(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">2</span>x<span class="number">2</span> Matrix<span class="number">2</span>x<span class="number">2</span>.mul(&amp;self, Matrix<span class="number">2</span>x<span class="number">2</span> b)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">2</span>x<span class="number">2</span> Matrix<span class="number">2</span>x<span class="number">2</span>.sub(&amp;self, Matrix<span class="number">2</span>x<span class="number">2</span> mat<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn Real Matrix<span class="number">2</span>x<span class="number">2</span>.trace(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">2</span>x<span class="number">2</span> Matrix<span class="number">2</span>x<span class="number">2</span>.transpose(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span> Matrix<span class="number">3</span>x<span class="number">3</span>.add(&amp;self, Matrix<span class="number">3</span>x<span class="number">3</span> mat<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span> Matrix<span class="number">3</span>x<span class="number">3</span>.adjoint(&amp;self)</code></pre><pre><code class="lang-c3">fn Real[&lt;<span class="number">3</span>&gt;] Matrix<span class="number">3</span>x<span class="number">3</span>.apply(&amp;self, Real[&lt;<span class="number">3</span>&gt;] vec)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span> Matrix<span class="number">3</span>x<span class="number">3</span>.component_mul(&amp;self, Real s)</code></pre><pre><code class="lang-c3">fn Real Matrix<span class="number">3</span>x<span class="number">3</span>.determinant(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span>! Matrix<span class="number">3</span>x<span class="number">3</span>.inverse(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span> Matrix<span class="number">3</span>x<span class="number">3</span>.mul(&amp;self, Matrix<span class="number">3</span>x<span class="number">3</span> b)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span> Matrix<span class="number">3</span>x<span class="number">3</span>.rotate(&amp;self, Real r)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span> Matrix<span class="number">3</span>x<span class="number">3</span>.scale(&amp;self, Real[&lt;<span class="number">2</span>&gt;] v)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span> Matrix<span class="number">3</span>x<span class="number">3</span>.sub(&amp;self, Matrix<span class="number">3</span>x<span class="number">3</span> mat<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn Real Matrix<span class="number">3</span>x<span class="number">3</span>.trace(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span> Matrix<span class="number">3</span>x<span class="number">3</span>.translate(&amp;self, Real[&lt;<span class="number">2</span>&gt;] v)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">3</span>x<span class="number">3</span> Matrix<span class="number">3</span>x<span class="number">3</span>.transpose(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.add(&amp;self, Matrix<span class="number">4</span>x<span class="number">4</span> mat<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.adjoint(&amp;self)</code></pre><pre><code class="lang-c3">fn Real[&lt;<span class="number">4</span>&gt;] Matrix<span class="number">4</span>x<span class="number">4</span>.apply(&amp;self, Real[&lt;<span class="number">4</span>&gt;] vec)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.component_mul(&amp;self, Real s)</code></pre><pre><code class="lang-c3">fn Real Matrix<span class="number">4</span>x<span class="number">4</span>.determinant(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span>! Matrix<span class="number">4</span>x<span class="number">4</span>.inverse(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.mul(Matrix<span class="number">4</span>x<span class="number">4</span>* a, Matrix<span class="number">4</span>x<span class="number">4</span> b)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.rotate_x(&amp;self, Real r)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.rotate_y(&amp;self, Real r)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.rotate_z(&amp;self, Real r)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.scale(&amp;self, Real[&lt;<span class="number">3</span>&gt;] v)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.sub(&amp;self, Matrix<span class="number">4</span>x<span class="number">4</span> mat<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn Real Matrix<span class="number">4</span>x<span class="number">4</span>.trace(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.translate(&amp;self, Real[&lt;<span class="number">3</span>&gt;] v)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> Matrix<span class="number">4</span>x<span class="number">4</span>.transpose(&amp;self)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> ortho(Real left, Real right, Real top, Real bottom, Real near, Real far)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>x<span class="number">4</span> perspective(Real fov, Real aspect_ratio, Real near, Real far)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdmathnolibc">std::math::nolibc</h3><pre><code class="lang-c3">macro double __math_oflow(ulong sign)</code></pre><pre><code class="lang-c3">macro float __math_oflowf(uint sign)</code></pre><pre><code class="lang-c3">macro double __math_uflow(ulong sign)</code></pre><pre><code class="lang-c3">macro float __math_uflowf(uint sign)</code></pre><pre><code class="lang-c3">macro __math_xflow(sign, v)</code></pre><pre><code class="lang-c3">macro force_eval_add(x, v)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdmathnolibc-ifenvno_libc">std::math::nolibc @if(env::NO_LIBC)</h3><pre><code class="lang-c3">fn double __cos(double x, double y) @extern(<span class="string">"__cos"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float __cosdf(double x) @extern(<span class="string">"__cosdf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn int __rem_pio<span class="number">2</span>(double x, double *y)</code></pre><pre><code class="lang-c3">fn int __rem_pio<span class="number">2</span>_large(double* x, double* y, int e<span class="number">0</span>, int nx, int prec)</code></pre><pre><code class="lang-c3">fn int __rem_pio<span class="number">2</span>f(float x, double *y)</code></pre><pre><code class="lang-c3">fn double __sin(double x, double y, int iy) @extern(<span class="string">"__sin"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float __sindf(double x) @extern(<span class="string">"__sindf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double __tan(double x, double y, int odd) @extern(<span class="string">"__tan"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float __tandf(double x, int odd) @extern(<span class="string">"__tandf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double _atan(double x) @weak @extern(<span class="string">"atan"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn double _atan<span class="number">2</span>(double y, double x) @weak @extern(<span class="string">"atan<span class="number">2</span>"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn float _atan<span class="number">2</span>f(float y, float x) @weak @extern(<span class="string">"atan<span class="number">2</span>f"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn float _atanf(float x) @weak @extern(<span class="string">"atanf"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn double _ceil(double x) @weak @extern(<span class="string">"ceil"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn float _ceilf(float x) @weak @extern(<span class="string">"ceilf"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn double _cos(double x) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float _cosf(float x) @extern(<span class="string">"cosf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double _exp<span class="number">2</span>(double x) @extern(<span class="string">"exp<span class="number">2</span>"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float _exp<span class="number">2</span>f(float x) @extern(<span class="string">"exp<span class="number">2</span>f"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double _floor(double x) @weak @extern(<span class="string">"floor"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn float _floorf(float x) @weak @extern(<span class="string">"floorf"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn double _round(double x) @extern(<span class="string">"round"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float _roundf(float x) @extern(<span class="string">"roundf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double _scalbn(double x, int n) @weak @extern(<span class="string">"scalbn"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn float _sinf(float x) @weak @extern(<span class="string">"sinf"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn double _trunc(double x) @weak @extern(<span class="string">"trunc"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn float _truncf(float x) @weak @extern(<span class="string">"truncf"</span>) @nostrip</code></pre><pre><code class="lang-c3">fn double pow_broken(double x, double y) @extern(<span class="string">"pow"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float powf_broken(float x, float f) @extern(<span class="string">"powf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double sin(double x) @extern(<span class="string">"sin"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn void sincos(double x, double *sin, double *cos) @extern(<span class="string">"sincos"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double sincos_broken(double x) @extern(<span class="string">"sincos"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn void sincosf(float x, float *sin, float *cos) @extern(<span class="string">"sincosf"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn double tan(double x) @extern(<span class="string">"tan"</span>) @weak @nostrip</code></pre><pre><code class="lang-c3">fn float tanf(float x) @extern(<span class="string">"tanf"</span>) @weak @nostrip</code></pre><h3 id="pre-conditions-for-macros-stdio-stdmathquaternionreal">std::math::quaternion(&lt;Real&gt;)</h3><pre><code class="lang-c3">macro Quaternion Quaternion.add(Quaternion a, Quaternion b)</code></pre><pre><code class="lang-c3">macro Quaternion Quaternion.add_each(Quaternion a, Real b)</code></pre><pre><code class="lang-c3">fn Quaternion Quaternion.invert(q)</code></pre><pre><code class="lang-c3">macro Real Quaternion.length(Quaternion q)</code></pre><pre><code class="lang-c3">macro Quaternion Quaternion.lerp(Quaternion q<span class="number">1</span>, Quaternion q<span class="number">2</span>, Real amount)</code></pre><pre><code class="lang-c3">fn Quaternion Quaternion.mul(a, Quaternion b)</code></pre><pre><code class="lang-c3">fn Quaternion Quaternion.nlerp(Quaternion q<span class="number">1</span>, Quaternion q<span class="number">2</span>, Real amount)</code></pre><pre><code class="lang-c3">macro Quaternion Quaternion.normalize(Quaternion q)</code></pre><pre><code class="lang-c3">macro Quaternion Quaternion.scale(Quaternion a, Real s)</code></pre><pre><code class="lang-c3">fn Quaternion Quaternion.slerp(q<span class="number">1</span>, Quaternion q<span class="number">2</span>, Real amount)</code></pre><pre><code class="lang-c3">macro Quaternion Quaternion.sub(Quaternion a, Quaternion b)</code></pre><pre><code class="lang-c3">macro Quaternion Quaternion.sub_each(Quaternion a, Real b)</code></pre><pre><code class="lang-c3">macro Matrix<span class="number">4</span> Quaternion.to_matrix(Quaternion* q)</code></pre><pre><code class="lang-c3">macro Matrix<span class="number">4</span>f Quaternion.to_matrixf(Quaternion* q)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdmathrandom">std::math::random</h3><pre><code class="lang-c3">distinct Lcg<span class="number">128</span>Random (Random) = uint<span class="number">128</span>;</code></pre><pre><code class="lang-c3">distinct Lcg<span class="number">16</span>Random (Random) = ushort;</code></pre><pre><code class="lang-c3">distinct Lcg<span class="number">32</span>Random (Random) = uint;</code></pre><pre><code class="lang-c3">distinct Lcg<span class="number">64</span>Random (Random) = ulong;</code></pre><pre><code class="lang-c3">distinct Mcg<span class="number">128</span>Random (Random) = uint<span class="number">128</span>;</code></pre><pre><code class="lang-c3">distinct Mcg<span class="number">16</span>Random (Random) = ushort;</code></pre><pre><code class="lang-c3">distinct Mcg<span class="number">32</span>Random (Random) = uint;</code></pre><pre><code class="lang-c3">distinct Mcg<span class="number">64</span>Random (Random) = ulong;</code></pre><pre><code class="lang-c3">distinct Pcg<span class="number">128</span>Random (Random) = uint<span class="number">128</span>;</code></pre><pre><code class="lang-c3">distinct Pcg<span class="number">16</span>Random (Random) = ushort;</code></pre><pre><code class="lang-c3">distinct Pcg<span class="number">32</span>Random (Random) = uint;</code></pre><pre><code class="lang-c3">distinct Pcg<span class="number">64</span>Random (Random) = ulong;</code></pre><pre><code class="lang-c3">distinct Sfc<span class="number">128</span>Random (Random) = uint<span class="number">128</span>[<span class="number">4</span>];</code></pre><pre><code class="lang-c3">distinct Sfc<span class="number">16</span>Random (Random) = ushort[<span class="number">4</span>];</code></pre><pre><code class="lang-c3">distinct Sfc<span class="number">32</span>Random (Random) = uint[<span class="number">4</span>];</code></pre><pre><code class="lang-c3">distinct Sfc<span class="number">64</span>Random (Random) = ulong[<span class="number">4</span>];</code></pre><pre><code class="lang-c3">distinct Sfc<span class="number">8</span>Random (Random) = char[<span class="number">4</span>];</code></pre><pre><code class="lang-c3">distinct SimpleRandom (Random) = ulong;</code></pre><pre><code class="lang-c3">interface Random</code></pre><pre><code class="lang-c3">struct Msws<span class="number">128</span>Random (Random)</code></pre><pre><code class="lang-c3">struct Msws<span class="number">16</span>Random (Random)</code></pre><pre><code class="lang-c3">struct Msws<span class="number">32</span>Random (Random)</code></pre><pre><code class="lang-c3">struct Msws<span class="number">64</span>Random (Random)</code></pre><pre><code class="lang-c3">struct Msws<span class="number">8</span>Random (Random)</code></pre><pre><code class="lang-c3">fn void  Msws<span class="number">16</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn void  Msws<span class="number">32</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn void  Msws<span class="number">64</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn void  Msws<span class="number">8</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn void  Pcg<span class="number">128</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn void  Sfc<span class="number">128</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn void  Sfc<span class="number">16</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn void  Sfc<span class="number">32</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn void  Sfc<span class="number">64</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn void  Sfc<span class="number">8</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn char[<span class="number">8</span> * <span class="number">4</span>] entropy()</code></pre><pre><code class="lang-c3">macro ushort @char_to_short(<span class="comment">#function)</span></code></pre><pre><code class="lang-c3">macro ulong @int_to_long(<span class="comment">#function)</span></code></pre><pre><code class="lang-c3">macro uint<span class="number">128</span> @long_to_int<span class="number">128</span>(<span class="comment">#function)</span></code></pre><pre><code class="lang-c3">macro @random_value_to_bytes(<span class="comment">#function, char[] bytes)</span></code></pre><pre><code class="lang-c3">macro uint @short_to_int(<span class="comment">#function)</span></code></pre><pre><code class="lang-c3">fn char Lcg<span class="number">128</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Lcg<span class="number">128</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Lcg<span class="number">128</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Lcg<span class="number">128</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Lcg<span class="number">128</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Lcg<span class="number">128</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Lcg<span class="number">128</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn char Lcg<span class="number">16</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Lcg<span class="number">16</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Lcg<span class="number">16</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Lcg<span class="number">16</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Lcg<span class="number">16</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Lcg<span class="number">16</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Lcg<span class="number">16</span>Random.set_seed(&amp;self, char[] seed) @dynamic</code></pre><pre><code class="lang-c3">fn char Lcg<span class="number">32</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Lcg<span class="number">32</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Lcg<span class="number">32</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Lcg<span class="number">32</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Lcg<span class="number">32</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Lcg<span class="number">32</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Lcg<span class="number">32</span>Random.set_seed(&amp;self, char[] seed) @dynamic</code></pre><pre><code class="lang-c3">fn char Lcg<span class="number">64</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Lcg<span class="number">64</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Lcg<span class="number">64</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Lcg<span class="number">64</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Lcg<span class="number">64</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Lcg<span class="number">64</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Lcg<span class="number">64</span>Random.set_seed(&amp;self, char[] seed) @dynamic</code></pre><pre><code class="lang-c3">fn char Mcg<span class="number">128</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Mcg<span class="number">128</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Mcg<span class="number">128</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Mcg<span class="number">128</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Mcg<span class="number">128</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Mcg<span class="number">128</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Mcg<span class="number">128</span>Random.set_seed(&amp;self, char[] seed) @dynamic</code></pre><pre><code class="lang-c3">fn char Mcg<span class="number">16</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Mcg<span class="number">16</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Mcg<span class="number">16</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Mcg<span class="number">16</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Mcg<span class="number">16</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Mcg<span class="number">16</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Mcg<span class="number">16</span>Random.set_seed(&amp;self, char[] seed) @dynamic</code></pre><pre><code class="lang-c3">fn char Mcg<span class="number">32</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Mcg<span class="number">32</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Mcg<span class="number">32</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Mcg<span class="number">32</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Mcg<span class="number">32</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Mcg<span class="number">32</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Mcg<span class="number">32</span>Random.set_seed(&amp;self, char[] seed) @dynamic</code></pre><pre><code class="lang-c3">fn char Mcg<span class="number">64</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Mcg<span class="number">64</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Mcg<span class="number">64</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Mcg<span class="number">64</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Mcg<span class="number">64</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Mcg<span class="number">64</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Mcg<span class="number">64</span>Random.set_seed(&amp;self, char[] seed) @dynamic</code></pre><pre><code class="lang-c3">fn char Msws<span class="number">128</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Msws<span class="number">128</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Msws<span class="number">128</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Msws<span class="number">128</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Msws<span class="number">128</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Msws<span class="number">128</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Msws<span class="number">128</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn char Msws<span class="number">16</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Msws<span class="number">16</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Msws<span class="number">16</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Msws<span class="number">16</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Msws<span class="number">16</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Msws<span class="number">16</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char Msws<span class="number">32</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Msws<span class="number">32</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Msws<span class="number">32</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Msws<span class="number">32</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Msws<span class="number">32</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Msws<span class="number">32</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char Msws<span class="number">64</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Msws<span class="number">64</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Msws<span class="number">64</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Msws<span class="number">64</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Msws<span class="number">64</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Msws<span class="number">64</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char Msws<span class="number">8</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Msws<span class="number">8</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Msws<span class="number">8</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Msws<span class="number">8</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Msws<span class="number">8</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Msws<span class="number">8</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char Pcg<span class="number">128</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Pcg<span class="number">128</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Pcg<span class="number">128</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Pcg<span class="number">128</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Pcg<span class="number">128</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Pcg<span class="number">128</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char Pcg<span class="number">16</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Pcg<span class="number">16</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Pcg<span class="number">16</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Pcg<span class="number">16</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Pcg<span class="number">16</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Pcg<span class="number">16</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Pcg<span class="number">16</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn char Pcg<span class="number">32</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Pcg<span class="number">32</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Pcg<span class="number">32</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Pcg<span class="number">32</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Pcg<span class="number">32</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Pcg<span class="number">32</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Pcg<span class="number">32</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn char Pcg<span class="number">64</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Pcg<span class="number">64</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Pcg<span class="number">64</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Pcg<span class="number">64</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Pcg<span class="number">64</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Pcg<span class="number">64</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Pcg<span class="number">64</span>Random.set_seed(&amp;self, char[] input) @dynamic</code></pre><pre><code class="lang-c3">fn char Sfc<span class="number">128</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Sfc<span class="number">128</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Sfc<span class="number">128</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Sfc<span class="number">128</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Sfc<span class="number">128</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Sfc<span class="number">128</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char Sfc<span class="number">16</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Sfc<span class="number">16</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Sfc<span class="number">16</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Sfc<span class="number">16</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Sfc<span class="number">16</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Sfc<span class="number">16</span>Random.next_short(&amp;seed) @dynamic</code></pre><pre><code class="lang-c3">fn char Sfc<span class="number">32</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Sfc<span class="number">32</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Sfc<span class="number">32</span>Random.next_int(&amp;sfc) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Sfc<span class="number">32</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Sfc<span class="number">32</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Sfc<span class="number">32</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char Sfc<span class="number">64</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Sfc<span class="number">64</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Sfc<span class="number">64</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Sfc<span class="number">64</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Sfc<span class="number">64</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Sfc<span class="number">64</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char Sfc<span class="number">8</span>Random.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void Sfc<span class="number">8</span>Random.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint Sfc<span class="number">8</span>Random.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> Sfc<span class="number">8</span>Random.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong Sfc<span class="number">8</span>Random.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort Sfc<span class="number">8</span>Random.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn char SimpleRandom.next_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void SimpleRandom.next_bytes(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn uint SimpleRandom.next_int(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn uint<span class="number">128</span> SimpleRandom.next_int<span class="number">128</span>(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ulong SimpleRandom.next_long(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn ushort SimpleRandom.next_short(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void SimpleRandom.set_seed(&amp;self, char[] seed) @dynamic</code></pre><pre><code class="lang-c3">macro bool is_random(random)</code></pre><pre><code class="lang-c3">macro make_seed($Type, char[] input)</code></pre><pre><code class="lang-c3">macro int next(random, int max)</code></pre><pre><code class="lang-c3">macro void next_bool(random)</code></pre><pre><code class="lang-c3">macro double next_double(random)</code></pre><pre><code class="lang-c3">macro float next_float(random)</code></pre><pre><code class="lang-c3">fn int rand(int max) @builtin</code></pre><pre><code class="lang-c3">macro void seed(random, seed)</code></pre><pre><code class="lang-c3">macro void seed_entropy(random)</code></pre><pre><code class="lang-c3">fn void seeder(char[] input, char[] out_buffer)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdmathvector">std::math::vector</h3><pre><code class="lang-c3">macro Vec<span class="number">2</span>.angle(self, Vec<span class="number">2</span> v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>.clamp_mag(self, double min, double max)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>.distance_sq(self, Vec<span class="number">2</span> v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>.length_sq(self)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>.rotate(self, double angle)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">2</span> Vec<span class="number">2</span>.towards(self, Vec<span class="number">2</span> target, double max_distance)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>.transform(self, Matrix<span class="number">4</span> mat)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>f.angle(self, Vec<span class="number">2</span>f v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>f.clamp_mag(self, float min, float max)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>f.distance_sq(self, Vec<span class="number">2</span>f v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>f.length_sq(self)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>f.rotate(self, float angle)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">2</span>f Vec<span class="number">2</span>f.towards(self, Vec<span class="number">2</span>f target, float max_distance)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">2</span>f.transform(self, Matrix<span class="number">4</span>f mat)</code></pre><pre><code class="lang-c3">fn double Vec<span class="number">3</span>.angle(self, Vec<span class="number">3</span> v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span> Vec<span class="number">3</span>.barycenter(self, Vec<span class="number">3</span> a, Vec<span class="number">3</span> b, Vec<span class="number">3</span> c)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">3</span>.clamp_mag(self, double min, double max)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span> Vec<span class="number">3</span>.cross(self, Vec<span class="number">3</span> v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">3</span>.distance_sq(self, Vec<span class="number">3</span> v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">3</span>.length_sq(self)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span> Vec<span class="number">3</span>.perpendicular(self)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span> Vec<span class="number">3</span>.refract(self, Vec<span class="number">3</span> n, double r)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span> Vec<span class="number">3</span>.rotate_axis(self, Vec<span class="number">3</span> axis, double angle)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span> Vec<span class="number">3</span>.rotate_quat(self, Quaternion q)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span> Vec<span class="number">3</span>.towards(self, Vec<span class="number">3</span> target, double max_distance)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span> Vec<span class="number">3</span>.transform(self, Matrix<span class="number">4</span> mat)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span> Vec<span class="number">3</span>.unproject(self, Matrix<span class="number">4</span> projection, Matrix<span class="number">4</span> view)</code></pre><pre><code class="lang-c3">fn float Vec<span class="number">3</span>f.angle(self, Vec<span class="number">3</span>f v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span>f Vec<span class="number">3</span>f.barycenter(self, Vec<span class="number">3</span>f a, Vec<span class="number">3</span>f b, Vec<span class="number">3</span>f c)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">3</span>f.clamp_mag(self, float min, float max)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span>f Vec<span class="number">3</span>f.cross(self, Vec<span class="number">3</span>f v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">3</span>f.distance_sq(self, Vec<span class="number">3</span>f v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">3</span>f.length_sq(self)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span>f Vec<span class="number">3</span>f.perpendicular(self)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span>f Vec<span class="number">3</span>f.refract(self, Vec<span class="number">3</span>f n, float r)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span>f Vec<span class="number">3</span>f.rotate_axis(self, Vec<span class="number">3</span>f axis, float angle)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span>f Vec<span class="number">3</span>f.rotate_quat(self, Quaternionf q)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span>f Vec<span class="number">3</span>f.towards(self, Vec<span class="number">3</span>f target, float max_distance)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span>f Vec<span class="number">3</span>f.transform(self, Matrix<span class="number">4</span>f mat)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">3</span>f Vec<span class="number">3</span>f.unproject(self, Matrix<span class="number">4</span>f projection, Matrix<span class="number">4</span>f view)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">4</span>.clamp_mag(self, double min, double max)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">4</span>.distance_sq(self, Vec<span class="number">4</span> v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">4</span>.length_sq(self)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">4</span> Vec<span class="number">4</span>.towards(self, Vec<span class="number">4</span> target, double max_distance)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">4</span>f.clamp_mag(self, float min, float max)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">4</span>f.distance_sq(self, Vec<span class="number">4</span>f v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">macro Vec<span class="number">4</span>f.length_sq(self)</code></pre><pre><code class="lang-c3">fn Vec<span class="number">4</span>f Vec<span class="number">4</span>f.towards(self, Vec<span class="number">4</span>f target, float max_distance)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span> matrix<span class="number">4</span>_look_at(Vec<span class="number">3</span> eye, Vec<span class="number">3</span> target, Vec<span class="number">3</span> up)</code></pre><pre><code class="lang-c3">fn Matrix<span class="number">4</span>f matrix<span class="number">4</span>f_look_at(Vec<span class="number">3</span>f eye, Vec<span class="number">3</span>f target, Vec<span class="number">3</span>f up)</code></pre><pre><code class="lang-c3">fn void ortho_normalize(Vec<span class="number">3</span>f* v<span class="number">1</span>, Vec<span class="number">3</span>f* v<span class="number">2</span>)</code></pre><pre><code class="lang-c3">fn void ortho_normalized(Vec<span class="number">3</span>* v<span class="number">1</span>, Vec<span class="number">3</span>* v<span class="number">2</span>)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdnet">std::net</h3><pre><code class="lang-c3">enum IpProtocol : char (AIFamily ai_family)</code></pre><pre><code class="lang-c3">fault NetError</code></pre><pre><code class="lang-c3">struct InetAddress (Printable)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_any_local(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_link_local(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_loopback(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_multicast(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_multicast_global(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_multicast_link_local(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_multicast_node_local(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_multicast_org_local(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_multicast_site_local(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn bool InetAddress.is_site_local(InetAddress* addr)</code></pre><pre><code class="lang-c3">fn usz! InetAddress.to_format(InetAddress* addr, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn String InetAddress.to_new_string(InetAddress* addr, Allocator allocator = allocator::heap()) @dynamic</code></pre><pre><code class="lang-c3">fn AddrInfo*! addrinfo(String host, uint port, AIFamily ai_family, AISockType ai_socktype) @if(os::SUPPORTS_INET)</code></pre><pre><code class="lang-c3">fn String! int_to_new_ipv<span class="number">4</span>(uint val, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String! int_to_temp_ipv<span class="number">4</span>(uint val)</code></pre><pre><code class="lang-c3">fn InetAddress! ipv<span class="number">4</span>_from_str(String s)</code></pre><pre><code class="lang-c3">fn uint! ipv<span class="number">4</span>toint(String s)</code></pre><pre><code class="lang-c3">fn InetAddress! ipv<span class="number">6</span>_from_str(String s)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdnet-ifossupports_inet">std::net @if(os::SUPPORTS_INET)</h3><pre><code class="lang-c3">distinct PollEvents = ushort;</code></pre><pre><code class="lang-c3">distinct PollSubscribes = ushort;</code></pre><pre><code class="lang-c3">enum SocketOption : char (CInt value)</code></pre><pre><code class="lang-c3">struct Poll</code></pre><pre><code class="lang-c3">struct Socket (InStream, OutStream)</code></pre><pre><code class="lang-c3">macro void @loop_over_ai(AddrInfo* ai; @body(NativeSocket fd, AddrInfo* ai))</code></pre><pre><code class="lang-c3">fn void! Socket.close(&amp;self) @inline @dynamic</code></pre><pre><code class="lang-c3">fn void! Socket.destroy(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn bool! Socket.get_broadcast(&amp;self)</code></pre><pre><code class="lang-c3">fn bool! Socket.get_dontroute(&amp;self)</code></pre><pre><code class="lang-c3">fn bool! Socket.get_keepalive(&amp;self)</code></pre><pre><code class="lang-c3">fn bool! Socket.get_oobinline(&amp;self)</code></pre><pre><code class="lang-c3">fn bool! Socket.get_option(&amp;self, SocketOption option)</code></pre><pre><code class="lang-c3">fn bool! Socket.get_reuseaddr(&amp;self)</code></pre><pre><code class="lang-c3">fn usz! Socket.read(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn char! Socket.read_byte(&amp;self) @dynamic</code></pre><pre><code class="lang-c3">fn void! Socket.set_broadcast(&amp;self, bool value)</code></pre><pre><code class="lang-c3">fn void! Socket.set_dontroute(&amp;self, bool value)</code></pre><pre><code class="lang-c3">fn void! Socket.set_keepalive(&amp;self, bool value)</code></pre><pre><code class="lang-c3">fn void! Socket.set_oobinline(&amp;self, bool value)</code></pre><pre><code class="lang-c3">fn void! Socket.set_option(&amp;self, SocketOption option, bool value)</code></pre><pre><code class="lang-c3">fn void! Socket.set_reuseaddr(&amp;self, bool value)</code></pre><pre><code class="lang-c3">fn usz! Socket.write(&amp;self, char[] bytes) @dynamic</code></pre><pre><code class="lang-c3">fn void! Socket.write_byte(&amp;self, char byte) @dynamic</code></pre><pre><code class="lang-c3">macro Socket new_socket(fd, ai)</code></pre><pre><code class="lang-c3">fn ulong! poll(Poll[] polls, Duration timeout)</code></pre><pre><code class="lang-c3">fn ulong! poll_ms(Poll[] polls, long timeout_ms)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdnetos">std::net::os</h3><pre><code class="lang-c3">distinct AIFamily = CInt;</code></pre><pre><code class="lang-c3">distinct AIFlags = CInt;</code></pre><pre><code class="lang-c3">distinct AIProtocol = CInt;</code></pre><pre><code class="lang-c3">distinct AISockType = CInt;</code></pre><pre><code class="lang-c3">distinct SockAddrPtr = void*;</code></pre><pre><code class="lang-c3">struct AddrInfo</code></pre><h3 id="pre-conditions-for-macros-stdio-stdnetos-ifenvposix-supports_inet">std::net::os @if(env::POSIX &amp;&amp; SUPPORTS_INET)</h3><pre><code class="lang-c3">distinct NativeSocket = inline Fd;</code></pre><pre><code class="lang-c3">struct Posix_pollfd</code></pre><pre><code class="lang-c3">macro void! NativeSocket.close(self)</code></pre><pre><code class="lang-c3">macro bool NativeSocket.is_non_blocking(self)</code></pre><pre><code class="lang-c3">macro void! NativeSocket.set_non_blocking(self, bool non_blocking)</code></pre><pre><code class="lang-c3">fn anyfault convert_error(Errno error)</code></pre><pre><code class="lang-c3">fn anyfault socket_error()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdnetos-ifenvwin32">std::net::os @if(env::WIN32)</h3><pre><code class="lang-c3">distinct NativeSocket = uptr;</code></pre><pre><code class="lang-c3">macro void! NativeSocket.close(self)</code></pre><pre><code class="lang-c3">fn void! NativeSocket.set_non_blocking(self, bool non_blocking)</code></pre><pre><code class="lang-c3">fn anyfault convert_error(WSAError error)</code></pre><pre><code class="lang-c3">fn anyfault socket_error()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdnettcp-ifossupports_inet">std::net::tcp @if(os::SUPPORTS_INET)</h3><pre><code class="lang-c3">distinct TcpServerSocket = inline Socket;</code></pre><pre><code class="lang-c3">distinct TcpSocket = inline Socket;</code></pre><pre><code class="lang-c3">fn TcpSocket! accept(TcpServerSocket* server_socket)</code></pre><pre><code class="lang-c3">fn TcpSocket! connect(String host, uint port, Duration timeout = <span class="number">0</span>, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)</code></pre><pre><code class="lang-c3">fn TcpSocket! connect_async(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)</code></pre><pre><code class="lang-c3">fn TcpSocket! connect_async_to(AddrInfo* ai, SocketOption... options)</code></pre><pre><code class="lang-c3">fn TcpSocket! connect_to(AddrInfo* ai, SocketOption... options)</code></pre><pre><code class="lang-c3">fn TcpServerSocket! listen(String host, uint port, uint backlog, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)</code></pre><pre><code class="lang-c3">fn TcpServerSocket! listen_to(AddrInfo* ai, uint backlog, SocketOption... options)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdnetudp-ifossupports_inet">std::net::udp @if(os::SUPPORTS_INET)</h3><pre><code class="lang-c3">distinct UdpSocket = inline Socket;</code></pre><pre><code class="lang-c3">fn UdpSocket! connect(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)</code></pre><pre><code class="lang-c3">fn UdpSocket! connect_async(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)</code></pre><pre><code class="lang-c3">fn UdpSocket! connect_async_to(AddrInfo* ai, SocketOption... options)</code></pre><pre><code class="lang-c3">fn UdpSocket! connect_to(AddrInfo* ai, SocketOption... options)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdos-ifenvdarwin">std::os @if(env::DARWIN)</h3><pre><code class="lang-c3">fn uint num_cpu()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdos-ifenvlinux">std::os @if(env::LINUX)</h3><pre><code class="lang-c3">fn uint num_cpu()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdos-ifenvwin32">std::os @if(env::WIN32)</h3><pre><code class="lang-c3">fn uint num_cpu()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdosbacktrace">std::os::backtrace</h3><pre><code class="lang-c3">fault BacktraceFault</code></pre><pre><code class="lang-c3">struct Backtrace (Printable)</code></pre><pre><code class="lang-c3">fn void Backtrace.free(&amp;self)</code></pre><pre><code class="lang-c3">fn bool Backtrace.has_file(&amp;self)</code></pre><pre><code class="lang-c3">fn Backtrace* Backtrace.init(&amp;self, uptr offset, String function, String object_file, String file = <span class="string">""</span>, uint line = <span class="number">0</span>, Allocator allocator)</code></pre><pre><code class="lang-c3">fn bool Backtrace.is_unknown(&amp;self)</code></pre><pre><code class="lang-c3">fn usz! Backtrace.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn void*[] capture_current(void*[] buffer)</code></pre><pre><code class="lang-c3">fn BacktraceList! symbolize_backtrace(void*[] backtrace, Allocator allocator) @if(!env::NATIVE_STACKTRACE)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdosdarwin-ifenvdarwin">std::os::darwin @if(env::DARWIN)</h3><pre><code class="lang-c3">struct Darwin_Dl_info</code></pre><pre><code class="lang-c3">struct Darwin_segment_command_<span class="number">64</span></code></pre><pre><code class="lang-c3">fn String! executable_path(Allocator allocator)</code></pre><pre><code class="lang-c3">fn BacktraceList! symbolize_backtrace(void*[] backtrace, Allocator allocator)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdosenv">std::os::env</h3><pre><code class="lang-c3">fn bool clear_var(String name)</code></pre><pre><code class="lang-c3">fn String! executable_path(Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn Path! get_config_dir(Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String! get_home_dir(Allocator using = allocator::heap())</code></pre><pre><code class="lang-c3">fn String! get_var(String name, Allocator allocator = allocator::heap())</code></pre><pre><code class="lang-c3">fn String! get_var_temp(String name)</code></pre><pre><code class="lang-c3">fn bool set_var(String name, String value, bool overwrite = true)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdoslinux-ifenvlinux">std::os::linux @if(env::LINUX)</h3><pre><code class="lang-c3">struct Elf<span class="number">32</span>_Ehdr</code></pre><pre><code class="lang-c3">struct Elf<span class="number">32</span>_Phdr</code></pre><pre><code class="lang-c3">struct Elf<span class="number">64</span>_Ehdr</code></pre><pre><code class="lang-c3">struct Elf<span class="number">64</span>_Phdr</code></pre><pre><code class="lang-c3">struct Linux_Dl_info</code></pre><pre><code class="lang-c3">fn BacktraceList! symbolize_backtrace(void*[] backtrace, Allocator allocator)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdosmacoscf-ifenvdarwin-linkenvdarwin-corefoundationframework">std::os::macos::cf @if(env::DARWIN) @link(env::DARWIN, “CoreFoundation.framework”)</h3><pre><code class="lang-c3">distinct CFAllocatorContextRef = void*;</code></pre><pre><code class="lang-c3">distinct CFAllocatorRef = void*;</code></pre><pre><code class="lang-c3">distinct CFArrayCallBacksRef = void*;</code></pre><pre><code class="lang-c3">distinct CFArrayRef = void*;</code></pre><pre><code class="lang-c3">distinct CFMutableArrayRef = void*;</code></pre><pre><code class="lang-c3">distinct CFTypeRef = void*;</code></pre><pre><code class="lang-c3">struct CFRange</code></pre><pre><code class="lang-c3">macro void* CFAllocatorRef.alloc(CFAllocatorRef allocator, usz size)</code></pre><pre><code class="lang-c3">macro void CFAllocatorRef.dealloc(CFAllocatorRef allocator, void* ptr)</code></pre><pre><code class="lang-c3">macro usz CFAllocatorRef.get_preferred_size(CFAllocatorRef allocator, usz req_size)</code></pre><pre><code class="lang-c3">macro void CFAllocatorRef.set_default(CFAllocatorRef allocator)</code></pre><pre><code class="lang-c3">macro CFAllocatorRef default_allocator()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdosmacosobjc-ifenvdarwin-linkenvdarwin-corefoundationframework">std::os::macos::objc @if(env::DARWIN) @link(env::DARWIN, “CoreFoundation.framework”)</h3><pre><code class="lang-c3">distinct Class = void*;</code></pre><pre><code class="lang-c3">distinct Ivar = void*;</code></pre><pre><code class="lang-c3">distinct Method = void*;</code></pre><pre><code class="lang-c3">distinct Selector = void*;</code></pre><pre><code class="lang-c3">fault ObjcFailure</code></pre><pre><code class="lang-c3">macro bool Class.equals(Class a, Class b)</code></pre><pre><code class="lang-c3">macro Method Class.method(Class cls, Selector name)</code></pre><pre><code class="lang-c3">macro ZString Class.name(Class cls)</code></pre><pre><code class="lang-c3">macro bool Class.responds_to(Class cls, Selector sel)</code></pre><pre><code class="lang-c3">macro Class Class.superclass(Class cls)</code></pre><pre><code class="lang-c3">macro bool Selector.equals(Selector a, Selector b)</code></pre><pre><code class="lang-c3">macro Class! class_by_name(ZString c)</code></pre><pre><code class="lang-c3">macro Class[] class_get_list(Allocator allocator = allocator::heap())</code></pre><h3 id="pre-conditions-for-macros-stdio-stdosposix-ifenvposix">std::os::posix @if(env::POSIX)</h3><pre><code class="lang-c3">distinct DIRPtr = void*;</code></pre><pre><code class="lang-c3">distinct Pthread_t = void*;</code></pre><pre><code class="lang-c3">struct Posix_dirent</code></pre><pre><code class="lang-c3">struct Posix_spawn_file_actions_t</code></pre><pre><code class="lang-c3">struct Posix_spawnattr_t</code></pre><pre><code class="lang-c3">fn CInt backtrace(void** buffer, CInt size)</code></pre><pre><code class="lang-c3">macro CInt wEXITSTATUS(CInt status)</code></pre><pre><code class="lang-c3">macro bool wIFCONTINUED(CInt status)</code></pre><pre><code class="lang-c3">macro bool wIFEXITED(CInt status)</code></pre><pre><code class="lang-c3">macro bool wIFSIGNALED(CInt status)</code></pre><pre><code class="lang-c3">macro bool wIFSTOPPED(CInt status)</code></pre><pre><code class="lang-c3">macro CInt wSTOPSIG(CInt status)</code></pre><pre><code class="lang-c3">macro CInt wTERMSIG(CInt status)</code></pre><pre><code class="lang-c3">macro CInt wWCOREDUMP(CInt status)</code></pre><pre><code class="lang-c3">macro CInt w_EXITCODE(CInt ret, CInt sig)</code></pre><pre><code class="lang-c3">macro CInt w_STOPCODE(CInt sig)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdosprocess-ifenvwin32-envposix">std::os::process @if(env::WIN32 || env::POSIX)</h3><pre><code class="lang-c3">fault SubProcessResult</code></pre><pre><code class="lang-c3">struct SubProcess</code></pre><pre><code class="lang-c3">fn bool SubProcess.destroy(&amp;self)</code></pre><pre><code class="lang-c3">fn bool! SubProcess.is_running(&amp;self)</code></pre><pre><code class="lang-c3">fn CInt! SubProcess.join(&amp;self) @if(env::POSIX)</code></pre><pre><code class="lang-c3">fn CInt! SubProcess.join(&amp;self) @if(env::WIN<span class="number">32</span>)</code></pre><pre><code class="lang-c3">fn usz! SubProcess.read_stderr(&amp;self, char* buffer, usz size)</code></pre><pre><code class="lang-c3">fn usz! SubProcess.read_stdout(&amp;self, char* buffer, usz size)</code></pre><pre><code class="lang-c3">fn File SubProcess.stdout(&amp;self)</code></pre><pre><code class="lang-c3">fn void! SubProcess.terminate(&amp;self)</code></pre><pre><code class="lang-c3">fn SubProcess! create(String[] command_line, SubProcessOptions options = {}, String[] environment = {}) @if(env::POSIX)</code></pre><pre><code class="lang-c3">fn SubProcess! create(String[] command_line, SubProcessOptions options = {}, String[] environment = {}) @if(env::WIN<span class="number">32</span>)</code></pre><pre><code class="lang-c3">fn String! execute_stdout_to_buffer(char[] buffer, String[] command_line, SubProcessOptions options = {}, String[] environment = {})</code></pre><h3 id="pre-conditions-for-macros-stdio-stdoswin32">std::os::win32</h3><pre><code class="lang-c3">distinct Win<span class="number">32</span>_CRITICAL_SECTION = ulong[<span class="number">5</span>];</code></pre><pre><code class="lang-c3">enum Win<span class="number">32</span>_ADDRESS_MODE</code></pre><pre><code class="lang-c3">enum Win<span class="number">32</span>_SYM_TYPE</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_ADDRESS<span class="number">64</span></code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_AMD<span class="number">64</span>_CONTEXT @align(<span class="number">16</span>)</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_ARM<span class="number">64</span>_NT_CONTEXT @align(<span class="number">16</span>)</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_ARM<span class="number">64</span>_NT_NEON<span class="number">128</span></code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_FILETIME</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_GUID</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_IMAGEHLP_LINE<span class="number">64</span></code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_IMAGEHLP_MODULE<span class="number">64</span></code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_IMAGE_DATA_DIRECTORY</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_IMAGE_FILE_HEADER</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_IMAGE_NT_HEADERS</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_IMAGE_OPTIONAL_HEADER<span class="number">64</span></code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_KDHELP<span class="number">64</span></code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_M<span class="number">128</span>A @align(<span class="number">16</span>)</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_MODLOAD_DATA</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_MODULEINFO</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_OVERLAPPED</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_PROCESS_INFORMATION</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_SECURITY_ATTRIBUTES</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_STACKFRAME<span class="number">64</span></code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_STARTUPINFOEXW</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_STARTUPINFOW</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_SYMBOL_INFO</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_SYSTEM_INFO</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_UNICODE_STRING</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_XMM_SAVE_AREA<span class="number">32</span></code></pre><h3 id="pre-conditions-for-macros-stdio-stdoswin32-ifenvwin32">std::os::win32 @if(env::WIN32)</h3><pre><code class="lang-c3">distinct WSAError = int;</code></pre><pre><code class="lang-c3">enum Win<span class="number">32</span>_GET_FILEEX_INFO_LEVELS</code></pre><pre><code class="lang-c3">struct Symbol</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_FILE_ATTRIBUTE_DATA</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_WIN<span class="number">32</span>_FIND_DATAW</code></pre><pre><code class="lang-c3">struct Win<span class="number">32</span>_pollfd</code></pre><pre><code class="lang-c3">fn Win<span class="number">32</span>_DWORD! load_modules()</code></pre><pre><code class="lang-c3">fn Backtrace! resolve_backtrace(void* addr, Win<span class="number">32</span>_HANDLE process, Allocator allocator)</code></pre><pre><code class="lang-c3">fn BacktraceList! symbolize_backtrace(void*[] backtrace, Allocator allocator)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdsort">std::sort</h3><pre><code class="lang-c3">macro bool @is_comparer(<span class="comment">#cmp, #list)</span></code></pre><pre><code class="lang-c3">macro usz @len_from_list(&amp;list)</code></pre><pre><code class="lang-c3">macro usz binarysearch(list, x, cmp = null) @builtin</code></pre><pre><code class="lang-c3">macro quicksort(list, cmp = null) @builtin</code></pre><h3 id="pre-conditions-for-macros-stdio-stdsortqstype-comparer">std::sort::qs(&lt;Type, Comparer&gt;)</h3><pre><code class="lang-c3">fn void qsort(Type list, isz low, isz high, Comparer cmp)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthread">std::thread</h3><pre><code class="lang-c3">distinct ConditionVariable = NativeConditionVariable;</code></pre><pre><code class="lang-c3">distinct Mutex = NativeMutex;</code></pre><pre><code class="lang-c3">distinct MutexType = int;</code></pre><pre><code class="lang-c3">distinct OnceFlag = NativeOnceFlag;</code></pre><pre><code class="lang-c3">distinct RecursiveMutex = inline Mutex;</code></pre><pre><code class="lang-c3">distinct Thread = NativeThread;</code></pre><pre><code class="lang-c3">distinct TimedMutex = inline Mutex;</code></pre><pre><code class="lang-c3">distinct TimedRecursiveMutex = inline Mutex;</code></pre><pre><code class="lang-c3">fault ThreadFault</code></pre><pre><code class="lang-c3">macro void! ConditionVariable.broadcast(&amp;cond)</code></pre><pre><code class="lang-c3">macro void! ConditionVariable.destroy(&amp;cond)</code></pre><pre><code class="lang-c3">macro void! ConditionVariable.init(&amp;cond)</code></pre><pre><code class="lang-c3">macro void! ConditionVariable.signal(&amp;cond)</code></pre><pre><code class="lang-c3">macro void! ConditionVariable.wait(&amp;cond, Mutex* mutex)</code></pre><pre><code class="lang-c3">macro void! ConditionVariable.wait_timeout(&amp;cond, Mutex* mutex, ulong timeout)</code></pre><pre><code class="lang-c3">macro void! Mutex.destroy(&amp;mutex)</code></pre><pre><code class="lang-c3">macro void! Mutex.init(&amp;mutex)</code></pre><pre><code class="lang-c3">macro void! Mutex.lock(&amp;mutex)</code></pre><pre><code class="lang-c3">macro bool Mutex.try_lock(&amp;mutex)</code></pre><pre><code class="lang-c3">macro void! Mutex.unlock(&amp;mutex)</code></pre><pre><code class="lang-c3">macro void OnceFlag.call(&amp;flag, OnceFn func)</code></pre><pre><code class="lang-c3">macro void! RecursiveMutex.init(&amp;mutex)</code></pre><pre><code class="lang-c3">macro void! Thread.create(&amp;thread, ThreadFn thread_fn, void* arg)</code></pre><pre><code class="lang-c3">macro void! Thread.detach(thread)</code></pre><pre><code class="lang-c3">macro bool Thread.equals(thread, Thread other)</code></pre><pre><code class="lang-c3">macro int! Thread.join(thread)</code></pre><pre><code class="lang-c3">macro void! TimedMutex.init(&amp;mutex)</code></pre><pre><code class="lang-c3">macro void! TimedMutex.lock_timeout(&amp;mutex, ulong ms)</code></pre><pre><code class="lang-c3">macro void! TimedRecursiveMutex.init(&amp;mutex)</code></pre><pre><code class="lang-c3">macro void! TimedRecursiveMutex.lock_timeout(&amp;mutex, ulong ms)</code></pre><pre><code class="lang-c3">macro Thread current()</code></pre><pre><code class="lang-c3">macro void exit(int result)</code></pre><pre><code class="lang-c3">macro void! sleep(Duration d) @maydiscard</code></pre><pre><code class="lang-c3">macro void! sleep_ms(ulong ms) @maydiscard</code></pre><pre><code class="lang-c3">macro void! sleep_ns(NanoDuration ns) @maydiscard</code></pre><pre><code class="lang-c3">macro void yield()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthreadcpu-ifenvdarwin">std::thread::cpu @if(env::DARWIN)</h3><pre><code class="lang-c3">fn uint native_cpu()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthreadcpu-ifenvlinux">std::thread::cpu @if(env::LINUX)</h3><pre><code class="lang-c3">fn uint native_cpu()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthreadcpu-ifenvwin32">std::thread::cpu @if(env::WIN32)</h3><pre><code class="lang-c3">fn uint native_cpu()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthreados-if-envposix-envwin32">std::thread::os @if (!env::POSIX &amp;&amp; !env::WIN32)</h3><pre><code class="lang-c3">distinct NativeConditionVariable = int;</code></pre><pre><code class="lang-c3">distinct NativeMutex = int;</code></pre><pre><code class="lang-c3">distinct NativeOnceFlag = int;</code></pre><pre><code class="lang-c3">distinct NativeThread = int;</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthreados-ifenvlinux">std::thread::os @if(env::LINUX)</h3><pre><code class="lang-c3">distinct Pthread_attr_t = ulong[<span class="number">7</span>]; <span class="comment">// <span class="number">24</span> on <span class="number">32</span>bit</span></code></pre><pre><code class="lang-c3">distinct Pthread_cond_t = ulong[<span class="number">6</span>];</code></pre><pre><code class="lang-c3">distinct Pthread_condattr_t = uint;</code></pre><pre><code class="lang-c3">distinct Pthread_key_t = uint;</code></pre><pre><code class="lang-c3">distinct Pthread_mutex_t = ulong[<span class="number">5</span>]; <span class="comment">// <span class="number">24</span> on <span class="number">32</span> bit</span></code></pre><pre><code class="lang-c3">distinct Pthread_mutexattr_t = uint;</code></pre><pre><code class="lang-c3">distinct Pthread_once_t = int;</code></pre><pre><code class="lang-c3">distinct Pthread_rwlock_t = ulong[<span class="number">7</span>]; <span class="comment">// <span class="number">32</span> on <span class="number">3</span>bit</span></code></pre><pre><code class="lang-c3">distinct Pthread_rwlockattr_t = uint;</code></pre><pre><code class="lang-c3">distinct Pthread_sched_param = uint;</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthreados-ifenvposix-envlinux">std::thread::os @if(env::POSIX &amp;&amp; !env::LINUX)</h3><pre><code class="lang-c3">distinct Pthread_attr_t = ulong[<span class="number">8</span>];</code></pre><pre><code class="lang-c3">distinct Pthread_cond_t = ulong[<span class="number">6</span>];</code></pre><pre><code class="lang-c3">distinct Pthread_condattr_t = ulong[<span class="number">8</span>];</code></pre><pre><code class="lang-c3">distinct Pthread_key_t = ulong;</code></pre><pre><code class="lang-c3">distinct Pthread_mutex_t = ulong[<span class="number">8</span>];</code></pre><pre><code class="lang-c3">distinct Pthread_mutexattr_t = ulong[<span class="number">2</span>];</code></pre><pre><code class="lang-c3">distinct Pthread_once_t = ulong[<span class="number">2</span>];</code></pre><pre><code class="lang-c3">distinct Pthread_rwlock_t = ulong[<span class="number">25</span>];</code></pre><pre><code class="lang-c3">distinct Pthread_rwlockattr_t = ulong[<span class="number">3</span>];</code></pre><pre><code class="lang-c3">distinct Pthread_sched_param = ulong;</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthreados-ifenvposix">std::thread::os @if(env::POSIX)</h3><pre><code class="lang-c3">struct NativeMutex</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.broadcast(&amp;cond)</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.destroy(&amp;cond)</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.init(&amp;cond)</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.signal(&amp;cond)</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.wait(&amp;cond, NativeMutex* mtx)</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.wait_timeout(&amp;cond, NativeMutex* mtx, ulong ms)</code></pre><pre><code class="lang-c3">fn void! NativeMutex.destroy(&amp;self)</code></pre><pre><code class="lang-c3">fn void! NativeMutex.init(&amp;self, MutexType type)</code></pre><pre><code class="lang-c3">fn bool NativeMutex.is_initialized(&amp;self)</code></pre><pre><code class="lang-c3">fn void! NativeMutex.lock(&amp;self)</code></pre><pre><code class="lang-c3">fn void! NativeMutex.lock_timeout(&amp;self, ulong ms)</code></pre><pre><code class="lang-c3">fn bool NativeMutex.try_lock(&amp;self)</code></pre><pre><code class="lang-c3">fn void! NativeMutex.unlock(&amp;self)</code></pre><pre><code class="lang-c3">fn void NativeOnceFlag.call_once(&amp;flag, OnceFn func)</code></pre><pre><code class="lang-c3">fn void! NativeThread.create(&amp;thread, ThreadFn thread_fn, void* arg)</code></pre><pre><code class="lang-c3">fn void! NativeThread.detach(thread)</code></pre><pre><code class="lang-c3">fn bool NativeThread.equals(thread, NativeThread other)</code></pre><pre><code class="lang-c3">fn int! NativeThread.join(thread)</code></pre><pre><code class="lang-c3">fn void! native_sleep_nano(NanoDuration nano)</code></pre><pre><code class="lang-c3">fn NativeThread native_thread_current()</code></pre><pre><code class="lang-c3">fn void native_thread_exit(int result)</code></pre><pre><code class="lang-c3">fn void native_thread_yield()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthreados-ifenvwin32">std::thread::os @if(env::WIN32)</h3><pre><code class="lang-c3">distinct NativeThread = inline Win<span class="number">32</span>_HANDLE;</code></pre><pre><code class="lang-c3">struct NativeConditionVariable</code></pre><pre><code class="lang-c3">struct NativeMutex</code></pre><pre><code class="lang-c3">struct NativeOnceFlag</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.broadcast(&amp;cond)</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.destroy(&amp;cond) @maydiscard</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.init(&amp;cond)</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.signal(&amp;cond)</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.wait(&amp;cond, NativeMutex* mtx) @inline</code></pre><pre><code class="lang-c3">fn void! NativeConditionVariable.wait_timeout(&amp;cond, NativeMutex* mtx, uint time) @inline</code></pre><pre><code class="lang-c3">fn void! NativeMutex.destroy(&amp;mtx)</code></pre><pre><code class="lang-c3">fn void! NativeMutex.init(&amp;mtx, MutexType type)</code></pre><pre><code class="lang-c3">fn void! NativeMutex.lock(&amp;mtx)</code></pre><pre><code class="lang-c3">fn void! NativeMutex.lock_timeout(&amp;mtx, usz ms)</code></pre><pre><code class="lang-c3">fn bool NativeMutex.try_lock(&amp;mtx)</code></pre><pre><code class="lang-c3">fn void! NativeMutex.unlock(&amp;mtx)</code></pre><pre><code class="lang-c3">fn void NativeOnceFlag.call_once(&amp;flag, OnceFn func)</code></pre><pre><code class="lang-c3">fn void! NativeThread.create(&amp;thread, ThreadFn func, void* args)</code></pre><pre><code class="lang-c3">fn void! NativeThread.detach(thread) @inline</code></pre><pre><code class="lang-c3">fn bool NativeThread.equals(thread, NativeThread other)</code></pre><pre><code class="lang-c3">fn int! NativeThread.join(thread)</code></pre><pre><code class="lang-c3">fn void! native_sleep_nano(NanoDuration ns)</code></pre><pre><code class="lang-c3">fn NativeThread native_thread_current()</code></pre><pre><code class="lang-c3">fn void native_thread_exit(int result) @inline</code></pre><pre><code class="lang-c3">fn void native_thread_yield()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdthreadpoolsize">std::thread::pool(&lt;SIZE&gt;)</h3><pre><code class="lang-c3">struct QueueItem</code></pre><pre><code class="lang-c3">struct ThreadPool</code></pre><pre><code class="lang-c3">fn void! ThreadPool.destroy(&amp;self)</code></pre><pre><code class="lang-c3">fn void! ThreadPool.init(&amp;self)</code></pre><pre><code class="lang-c3">fn void! ThreadPool.push(&amp;self, ThreadFn func, void* arg)</code></pre><pre><code class="lang-c3">fn void! ThreadPool.stop_and_destroy(&amp;self)</code></pre><h3 id="pre-conditions-for-macros-stdio-stdtime">std::time</h3><pre><code class="lang-c3">distinct Clock = ulong;</code></pre><pre><code class="lang-c3">distinct Duration = long;</code></pre><pre><code class="lang-c3">distinct NanoDuration (Printable) = long;</code></pre><pre><code class="lang-c3">distinct Time = long;</code></pre><pre><code class="lang-c3">enum Month : char</code></pre><pre><code class="lang-c3">enum Weekday : char</code></pre><pre><code class="lang-c3">struct DateTime</code></pre><pre><code class="lang-c3">struct TzDateTime</code></pre><pre><code class="lang-c3">fn long Duration.to_ms(td)</code></pre><pre><code class="lang-c3">fn NanoDuration Duration.to_nano(td)</code></pre><pre><code class="lang-c3">fn Duration NanoDuration.to_duration(nd)</code></pre><pre><code class="lang-c3">fn usz! NanoDuration.to_format(&amp;self, Formatter* formatter) @dynamic</code></pre><pre><code class="lang-c3">fn long NanoDuration.to_ms(nd)</code></pre><pre><code class="lang-c3">fn double NanoDuration.to_sec(nd)</code></pre><pre><code class="lang-c3">fn Time Time.add_days(time, long days)</code></pre><pre><code class="lang-c3">fn Time Time.add_duration(time, Duration duration)</code></pre><pre><code class="lang-c3">fn Time Time.add_hours(time, long hours)</code></pre><pre><code class="lang-c3">fn Time Time.add_minutes(time, long minutes)</code></pre><pre><code class="lang-c3">fn Time Time.add_seconds(time, long seconds)</code></pre><pre><code class="lang-c3">fn Time Time.add_weeks(time, long weeks)</code></pre><pre><code class="lang-c3">fn double Time.diff_days(time, Time other)</code></pre><pre><code class="lang-c3">fn double Time.diff_hour(time, Time other)</code></pre><pre><code class="lang-c3">fn double Time.diff_min(time, Time other)</code></pre><pre><code class="lang-c3">fn double Time.diff_sec(time, Time other)</code></pre><pre><code class="lang-c3">fn Duration Time.diff_us(time, Time other)</code></pre><pre><code class="lang-c3">fn double Time.diff_weeks(time, Time other)</code></pre><pre><code class="lang-c3">fn double Time.to_seconds(time)</code></pre><pre><code class="lang-c3">fn Duration from_float(double s) @inline</code></pre><pre><code class="lang-c3">fn Duration hour(long l) @inline</code></pre><pre><code class="lang-c3">fn Duration min(long l) @inline</code></pre><pre><code class="lang-c3">fn Duration ms(long l) @inline</code></pre><pre><code class="lang-c3">fn Time now()</code></pre><pre><code class="lang-c3">fn Duration sec(long l) @inline</code></pre><h3 id="pre-conditions-for-macros-stdio-stdtimeclock">std::time::clock</h3><pre><code class="lang-c3">fn NanoDuration Clock.mark(&amp;self)</code></pre><pre><code class="lang-c3">fn NanoDuration Clock.to_now(self)</code></pre><pre><code class="lang-c3">fn Clock now()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdtimedatetime-ifenvlibc">std::time::datetime @if(env::LIBC)</h3><pre><code class="lang-c3">fn DateTime DateTime.add_days(&amp;self, int days)</code></pre><pre><code class="lang-c3">fn DateTime DateTime.add_hours(&amp;self, int hours)</code></pre><pre><code class="lang-c3">fn DateTime DateTime.add_minutes(&amp;self, int minutes)</code></pre><pre><code class="lang-c3">fn DateTime DateTime.add_months(&amp;self, int months)</code></pre><pre><code class="lang-c3">fn DateTime DateTime.add_seconds(&amp;self, int seconds)</code></pre><pre><code class="lang-c3">fn DateTime DateTime.add_weeks(&amp;self, int weeks)</code></pre><pre><code class="lang-c3">fn DateTime DateTime.add_years(&amp;self, int years)</code></pre><pre><code class="lang-c3">fn bool DateTime.after(&amp;self, DateTime compare) @inline</code></pre><pre><code class="lang-c3">fn bool DateTime.before(&amp;self, DateTime compare) @inline</code></pre><pre><code class="lang-c3">fn int DateTime.compare_to(&amp;self, DateTime compare)</code></pre><pre><code class="lang-c3">fn double DateTime.diff_sec(self, DateTime from)</code></pre><pre><code class="lang-c3">fn Duration DateTime.diff_us(self, DateTime from)</code></pre><pre><code class="lang-c3">fn int DateTime.diff_years(&amp;self, DateTime from)</code></pre><pre><code class="lang-c3">fn void DateTime.set_date(&amp;self, int year, Month month = JANUARY, int day = <span class="number">1</span>, int hour = <span class="number">0</span>, int min = <span class="number">0</span>, int sec = <span class="number">0</span>, int us = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">fn void DateTime.set_time(&amp;self, Time time)</code></pre><pre><code class="lang-c3">fn TzDateTime DateTime.to_local(&amp;self)</code></pre><pre><code class="lang-c3">fn Time DateTime.to_time(&amp;self) @inline</code></pre><pre><code class="lang-c3">fn DateTime from_date(int year, Month month = JANUARY, int day = <span class="number">1</span>, int hour = <span class="number">0</span>, int min = <span class="number">0</span>, int sec = <span class="number">0</span>, int us = <span class="number">0</span>)</code></pre><pre><code class="lang-c3">fn DateTime from_time(Time time)</code></pre><pre><code class="lang-c3">fn DateTime now()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdtimeos-ifenvdarwin">std::time::os @if(env::DARWIN)</h3><pre><code class="lang-c3">struct Darwin_mach_timebase_info</code></pre><pre><code class="lang-c3">fn Clock native_clock()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdtimeos-ifenvposix">std::time::os @if(env::POSIX)</h3><pre><code class="lang-c3">fn Clock native_clock() @if(!env::DARWIN)</code></pre><pre><code class="lang-c3">fn Time native_timestamp()</code></pre><h3 id="pre-conditions-for-macros-stdio-stdtimeos-ifenvwin32">std::time::os @if(env::WIN32)</h3><pre><code class="lang-c3">fn Clock native_clock()</code></pre><pre><code class="lang-c3">fn Time native_timestamp()</code></pre><hr><p>title: Conversions and Promotions
description: Conversions and Promotions
sidebar:</p><pre><code>order: 210</code></pre><hr><h2 id="pre-conditions-for-macros-conversion-rules-for-c3">Conversion Rules For C3</h2><p>C3 differs in some crucial respects when it comes to number conversions and promotions. These are the rules for C3:</p><ul>
<li><code>float</code> to <code>int</code> conversions require a cast.</li>
<li><code>int</code> to <code>float</code> conversions <em>do not</em> require a cast.</li>
<li><code>bool</code> to <code>float</code> converts to <code>0.0</code> or <code>1.0</code></li>
<li>Widening <code>float</code> conversions are only conditionally allowed<sup>*</sup>.</li>
<li>Narrowing conversions require a cast<sup>*</sup>.</li>
<li>Widening <code>int</code> conversions are only conditionally allowed<sup>*</sup>.</li>
<li>Signed &lt;-&gt; unsigned conversions of the same type <em>do not</em> require a cast.</li>
<li>In conditionals <code>float</code> to <code>bool</code> <em>do not</em> require a cast, any non zero <code>float</code> value considered true.</li>
<li>Implicit conversion to <code>bool</code> only occurs in conditionals or when the value is enclosed in <code>()</code> e.g. <code>bool x = (1.0)</code> or <code>if (1.0) { ... }</code></li>
</ul><p>C3 uses two’s complement arithmetic for all integer math.</p><p>:::note 
These abbreviations are used in the text below:
- “lhs” meaning “left hand side”.
- “rhs” meaning “right hand side”.
:::</p><h3 id="pre-conditions-for-macros-conversion-rules-for-c3-target-type">Target type</h3><p>The left hand side of an assignment, or the parameter type in a call is known as the <em>target type</em> the target type is used for implicit widening and inferring struct initialization.</p><h3 id="pre-conditions-for-macros-conversion-rules-for-c3-common-arithmetic-promotion">Common arithmetic promotion</h3><p>Like C, C3 uses implicit arithmetic promotion of integer and floating point variables before arithmetic operations:</p><ol>
<li>For any floating point type with a bitwidth smaller than 32 bits, widen to <code>float</code>. E.g. <code>f16 -&gt; float</code></li>
<li>For an integer type smaller than the <em>minimum arithmetic width</em> promote the value to a same signed integer of the <em>minimum arithmetic width</em> (this usually corresponds to a c int/uint). E.g. <code>ushort -&gt; uint</code></li>
</ol><h3 id="pre-conditions-for-macros-conversion-rules-for-c3-implicit-narrowing">Implicit narrowing</h3><p>An
 expression with an integer type, may implicitly narrow to smaller 
integer type, and similarly a float type may implicitly narrow to less 
wide floating point type is determined from the following algorithm.</p><ol>
<li>Shifts and assign look at the lhs expression.</li>
<li><code>++</code>, <code>--</code>, <code>~</code>, <code>-</code>, <code>!!</code>, <code>!</code> - check the inner type.</li>
<li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code>, <code>|</code>, <code>&amp;</code>, <code>??</code>, <code>?:</code> - check both lhs and rhs.</li>
<li>Narrowing <code>int</code>/<code>float</code> cast, assume the type is the narrowed type.</li>
<li>Widening <code>int</code>/<code>float</code> cast, look at the inner expression, ignoring the cast.</li>
<li>In the case of any other cast, assume it is opaque and the type is that of the cast.</li>
<li>In the case of an integer literal, instead of looking at the type, check that the integer would fit the type to narrow to.</li>
<li>For <code>.len</code> access, allow narrowing to C int width.</li>
<li>For all other expressions, check against the size of the type.</li>
</ol><p>As rough guide: if all the sub expressions originally are small enough it’s ok to implicitly convert the result.</p><p>Examples:</p><pre><code class="lang-c3">float<span class="number">16</span> h = <span class="number"><span class="number">12</span>.<span class="number">0</span></span>;
float f = <span class="number"><span class="number">13</span>.<span class="number">0</span></span>;
double d = <span class="number"><span class="number">22</span>.<span class="number">0</span></span>;

char x = <span class="number">1</span>;
short y = -<span class="number">3</span>;
int z = <span class="number">0</span>xFFFFF;
ulong w = -<span class="number">0</span>xFFFFFFF;

x = x + x; <span class="comment">// =&gt; calculated as x = (char)((int)x + (int)x);</span>
x = y + x; <span class="comment">// =&gt; Error, narrowing not allowed as y &gt; char</span>
h = x * h; <span class="comment">// =&gt; calculated as h = (float<span class="number">16</span>)((float)x * (float)h);</span>
h = f + x; <span class="comment">// =&gt; Error, narrowing not allowed since f &gt; f<span class="number">16</span></span></code></pre><h3 id="pre-conditions-for-macros-conversion-rules-for-c3-implicit-widening">Implicit widening</h3><p>Unlike C, implicit widening will only happen on “simple expressions”:
if the expression is a primary expression, or a unary operation on a primary expression.</p><p>For assignment, special rules hold. For an assignment to a binary expression, <em>if</em> its two subexpressions are “simple expressions” and the binary expression is <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, allow an implicit promotion of the two sub expressions.</p><pre><code class="lang-c3">int a = ...
short b = ...
char c = ...
long d = a; <span class="comment">// Valid - simple expression.</span>
int e = (int)(d + (a + b)); <span class="comment">// Error</span>
int f = (int)(d + ~b); <span class="comment">// Valid</span>
long g = a + b; <span class="comment">// Valid</span></code></pre><p>As a rule of thumb, if there are more than one possible conversion an explicit cast is needed.</p><p>Example:</p><pre><code class="lang-c3">long h = a + (b + c);

<span class="comment">// Possible intention <span class="number">1</span></span>
long h = (long)(a + (b + c));

<span class="comment">// Possible intention <span class="number">2</span></span>
long h = (long)a + (long)(b + c);

<span class="comment">// Possible intention <span class="number">3</span></span>
long h = (long)a + ((long)b + (long)c);</code></pre><h3 id="pre-conditions-for-macros-conversion-rules-for-c3-maximum-type">Maximum type</h3><p>The <em>maximum type</em> is a concept used when unifying two or more types. The algorithm follows:</p><ol>
<li>First perform implicit promotion.</li>
<li>If both types are the same, the maximum type is this type. </li>
<li>If one type is a floating point type, and the other is an integer type, 
the maximum type is the floating point type. E.g. <code>int + float -&gt; float</code>.</li>
<li>If both types are floating point types, the maximum type is the widest floating point type. E.g. <code>float + double -&gt; double</code>.</li>
<li>If both types are integer types with the same signedness, the 
maximum type is the widest integer type of the two. E.g. <code>uint + ulong -&gt; ulong</code>.</li>
<li>If both types are integer types with different signedness, the 
maximum type is a signed integer with the same bit width as the maximum integer type. <code>ulong + int -&gt; long</code></li>
<li>If at least one side is a struct or a pointer to a struct with an 
<code>inline</code> directive on a member, check recursively check if the type of 
the inline member can be used to find a maximum type (see below under sub struct conversions)</li>
<li>All other cases are errors.</li>
</ol><h3 id="pre-conditions-for-macros-conversion-rules-for-c3-substruct-conversions">Substruct conversions</h3><p>Substructs may be used in place of its parent structs in many cases. The rule is as follows:</p><ol>
<li>A substruct pointer may implicitly convert to a parent struct.</li>
<li>A substruct <em>value</em> may be implicitly assigned to a variable with the parent struct type, 
This will <em>truncate</em> the value, copying only the parent part of the substruct. However, a 
substruct value cannot be assigned its parent struct.</li>
<li>Substruct slices and arrays <em>can not</em> be cast (implicitly or explicitly) to an array of the parent struct type.</li>
</ol><h3 id="pre-conditions-for-macros-conversion-rules-for-c3-pointer-conversions">Pointer conversions</h3><p>Pointer conversion between types usually need explicit casts. 
The exception is <code>void *</code> which any type may implicitly convert <em>to</em> or <em>from</em>. 
Conversion rules from and to arrays are detailed under <a href="https://waveproc.github.io/language-common/arrays/">arrays</a></p><h3 id="pre-conditions-for-macros-conversion-rules-for-c3-vector-conversions">Vector conversions</h3><p>Conversion between underlying vector types need explicit conversions. They work
as regular conversions with one notable exception: converting a <code>true</code> boolean
vector value into an int will yield a value with all bits set. So <code>bool[&lt;2&gt;] { true, false }</code>
converted to for example <code>char[&lt;2&gt;]</code> will yield <code>{ 255, 0 }</code>.</p><p>Vectors can also be cast to the corresponding array type, for example: <code>char[&lt;2&gt;]</code> &lt;=&gt; <code>char[2]</code>.</p><h2 id="pre-conditions-for-macros-binary-conversions">Binary conversions</h2><h4>1. Multiplication, division, remainder, subtraction / addition with both operands being numbers</h4><p>These operations are only valid for integer and float types.</p><ol>
<li>Resolve the operands.</li>
<li>Find the <a href="#maximum-type">maximum type</a> of the two operands.</li>
<li>Promote both operands to the resulting type if both are simple expressions</li>
<li>The resulting type of the expression is the <a href="#maximum-type">maximum type</a>.</li>
</ol><h4>2. Addition with left side being a pointer</h4><ol>
<li>Resolve the operands.</li>
<li>If the rhs is not an integer, this is an error.   </li>
<li>If the rhs has a bit width that exceeds isz, this is an error.</li>
<li>The result of the expression is the lhs type.</li>
</ol><h4>3. Subtraction with lhs pointer and rhs integer</h4><ol>
<li>Resolve the operands.</li>
<li>If the right hand type has a bit width that exceeds isz, this is an error.</li>
<li>The result of the expression is the left hand type.</li>
</ol><h4>4. Subtraction with both sides pointers</h4><ol>
<li>Resolve the operands.</li>
<li>If the either side is a <code>void *</code>, it is cast to the other type.</li>
<li>If the types of the sides are different, this is an error.   </li>
<li>The result of the expression is isz.</li>
<li>If this result exceeds the target width, this is an error.</li>
</ol><h4>6. Bit operations <code>^</code> <code>&amp;</code> <code>|</code></h4><p>These operations are only valid for integers and booleans.</p><ol>
<li>Resolve the operands.</li>
<li>Find the <a href="#maximum-type">maximum type</a> of the two operands.</li>
<li>Promote both operands to the <a href="#maximum-type">maximum type</a> if they are simple expressions.</li>
<li>The result of the expression is the <a href="#maximum-type">maximum type</a>.</li>
</ol><h4>6. Shift operations <code>&lt;&lt;</code> <code>&gt;&gt;</code></h4><p>These operations are only valid for integers.</p><ol>
<li>Resolve the operands.</li>
<li>In safe mode, insert a trap to ensure that rhs &gt;= 0 and rhs &lt; bit width of the left hand side.</li>
<li>The result of the expression is the lhs type.</li>
</ol><h4>7. Assignment operations <code>+=</code> <code>-=</code> <code>*=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>^=</code> <code>|=</code> <code>&amp;=</code></h4><ol>
<li>Resolve the lhs.</li>
<li>Resolve the right operand as an assignment rhs.</li>
<li>The result of the expression is the lhs type.</li>
</ol><h4>8. Assignment shift <code>&gt;&gt;=</code> <code>&lt;&lt;=</code></h4><ol>
<li>Resolve both operands</li>
<li>In safe mode, insert a trap to ensure that rhs &gt;= 0 and rhs &lt; bit width of the left hand side.</li>
<li>The result of the expression is the lhs type.</li>
</ol><h4>9. <code>&amp;&amp;</code> and <code>||</code></h4><ol>
<li>Resolve both operands.</li>
<li>Insert bool cast of both operands.</li>
<li>The type is bool.</li>
</ol><h4>10. <code>&lt;=</code> <code>==</code> <code>&gt;=</code> <code>!=</code></h4><ol>
<li>Resolve the operands, left to right.</li>
<li>Find the <a href="#maximum-type">maximum type</a> of the two operands.</li>
<li>Promote both operands to the <a href="#maximum-type">maximum type</a>.</li>
<li>The type is bool.</li>
</ol><h2 id="pre-conditions-for-macros-unary-conversions">Unary conversions</h2><h4>1. Bit negate</h4><ol>
<li>Resolve the inner operand.</li>
<li>If the inner type is not an integer this is an error.   </li>
<li>The type is the inner type.</li>
</ol><h4>2. Boolean not</h4><ol>
<li>Resolve the inner operand.</li>
<li>The type is bool.</li>
</ol><h4>3. Negation</h4><ol>
<li>Resolve the inner operand.</li>
<li>If the type inner type is not a number this is an error.</li>
<li>If the inner type is an unsigned integer, cast it to the same signed type.</li>
<li>The type is the type of the result from (3)</li>
</ol><h4>4. <code>&amp;</code> and <code>&amp;&amp;</code></h4><ol>
<li>Resolve the inner operand.</li>
<li>The type is a pointer to the type of the inner operand.</li>
</ol><h4>5. <code>*</code></h4><ol>
<li>Resolve the inner operand.</li>
<li>If the operand is not a pointer, or is a <code>void *</code> pointer, this is an error.</li>
<li>The type is the pointee of the inner operand’s type.</li>
</ol><p>Dereferencing 0 is implementation defined.</p><h4>6. <code>++</code> and <code>--</code></h4><ol>
<li>Resolve the inner operand.</li>
<li>If the type is not a number, this is an error.</li>
<li>The type is the same as the inner operand.</li>
</ol><h2 id="pre-conditions-for-macros-base-expressions">Base expressions</h2><h4>1. Typed identifiers</h4><ol>
<li>The type is that of the declaration.</li>
<li>If the width of the type is less than that of the target type, widen to the target type.</li>
<li>If the width of the type is greater than that of the target type, it is an error.</li>
</ol><h4>2. Constants and literals</h4><ol>
<li>If the constant is an integer, it is assumed to be the <em>arithmetic promotion width</em> and signed. 
If the suffix <code>u</code> is added, it is assumed to be an unsigned number. If a suffix <code>ixx</code> or <code>uxx</code> 
is given then it is considered a an integer of that type width and signedness. It cannot be implicitly narrowed. </li>
<li>If the constant is a floating point value, it is assumed to be a <code>double</code> unless suffixed
with <code>f</code> which is then assumed to be a <code>float</code>. If a bit width is given after <code>f</code>, 
it is instead a floating point type of that width.</li>
</ol><hr><p>title: Precedence
description: Precedence
sidebar:</p><pre><code>order: 211</code></pre><hr><p>Precedence rules in C3 differs from C/C++. Here are all precedence levels in C3, listed from highest (1) to lowest (11):</p><ol>
<li><code>()</code>, <code>[]</code>, <code>.</code>, <code>!!</code> postfix <code>!</code>, <code>++</code> and <code>--</code> </li>
<li><code>@</code>, prefix <code>-</code>, <code>~</code>, prefix <code>*</code>, <code>&amp;</code>, prefix <code>++</code> and <code>--</code></li>
<li>infix <code>*</code>, <code>/</code>, <code>%</code></li>
<li><code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li><code>^</code>, <code>|</code>, infix <code>&amp;</code></li>
<li><code>+</code>, infix <code>-</code>, <code>+++</code></li>
<li><code>==</code>, <code>!=</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code></li>
<li><code>&amp;&amp;</code>, <code>&amp;&amp;&amp;</code></li>
<li><code>||</code>, <code>|||</code></li>
<li>ternary <code>?:</code> <code>??</code></li>
<li><code>=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>+=</code>, <code>-=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code></li>
</ol><p>The main difference is that bitwise operations and shift has 
higher precedence than addition/subtraction and multiplication/division 
in C3. Bitwise operations also have higher precedence than the 
relational operators. Also, there is no difference in precedence between
 &amp;&amp; || or between the bitwise operators.</p><p>Examples:</p><pre><code class="lang-c3">a + b &gt;&gt; c + d

(a + b) &gt;&gt; (c + d) <span class="comment">// C (+ - are evaluated before &gt;&gt;)</span>
a + (b &gt;&gt; c) + d   <span class="comment">// C<span class="number">3</span> (&gt;&gt; is evaluated before + -)</span>


a &amp; b == c

a &amp; (b == c)       <span class="comment">// C  (bitwise operators are evaluated after relational)</span>
(a &amp; b) == c       <span class="comment">// C<span class="number">3</span> (bitwise operators are evaluated before relational)</span>


a &gt; b == c &lt; d

(a &gt; b) == (c &lt; d) <span class="comment">// C  (&lt; &gt; binds tighter than ==)</span>
((a &gt; b) == c) &lt; d <span class="comment">// C<span class="number">3</span> Error, requires parenthesis!</span>


a | b ^ c &amp; d

a | ((b ^ c) &amp; d)  <span class="comment">// C  (All bitwise operators have different precedence)</span>
((a | b) ^ c) &amp; d  <span class="comment">// C<span class="number">3</span> Error, requires parenthesis!</span></code></pre><p>The
 change in precedence of the bitwise operators corrects a long standing 
issue in the C specification. The change in precedence for shift 
operations goes towards making the precedence less surprising.</p><p>Conflating
 the precedence of relational and equality operations, and all bitwise 
operations was motivated by simplification: few remember the exact 
internal differences in precedence between bitwise operators. 
Parenthesis are required for those conflated levels of precedence.</p><p>Left-
to-right offers a very simple model to think about the internal order of
 operations, and encourages use of explicit ordering, as best practice 
in C is to use parentheses anyway.</p><hr><p>title: Undefined Behaviour
description: Undefined Behaviour
sidebar:</p><pre><code>order: 212</code></pre><hr><p>Like C, C3 uses undefined behaviour. In contrast, C3 will <em>trap</em>
 - that is, print an error trace and abort – on undefined behaviour in 
debug builds. This is similar to using C with a UB sanitizer. It is only
 during release builds that actual undefined behaviour occurs.</p><p>In C3, undefined behaviour means that the compiler is free to interpret <em>undefined behaviour as if behaviour cannot occur</em>.</p><p>In the example below:</p><pre><code class="lang-c3">uint x = foo();
uint z = <span class="number">255</span> / x;
return x != <span class="number">0</span>;</code></pre><p>The case of <code>x == 0</code> would invoke undefined behaviour for <code>255/x</code>. For that reason, 
the compiler may assume that <code>x != 0</code> and compile it into the following code: </p><pre><code class="lang-c3">foo();
return true;</code></pre><p>As a contrast, the safe build will compile code equivalent to the following.</p><pre><code class="lang-c3">uint x = foo();
if (x == <span class="number">0</span>) trap(<span class="string">"Division by zero"</span>)
return true;</code></pre><h2 id="pre-conditions-for-macros-list-of-undefined-behaviours">List of undefined behaviours</h2><p>The following operations cause undefined behaviour in release builds of C3:</p><table>
<thead>
<tr>
<th>operation</th>
<th align="center">will trap in safe builds</th>
</tr>
</thead>
<tbody>
<tr>
<td>int / 0</td>
<td align="center">Yes</td>
</tr>
<tr>
<td>int % 0</td>
<td align="center">Yes</td>
</tr>
<tr>
<td>reading explicitly uninitialized memory</td>
<td align="center">Possible*</td>
</tr>
<tr>
<td>array index out of bounds</td>
<td align="center">Yes</td>
</tr>
<tr>
<td>dereference <code>null</code></td>
<td align="center">Yes</td>
</tr>
<tr>
<td>dereferencing memory not allocated</td>
<td align="center">Possible*</td>
</tr>
<tr>
<td>dereferencing memory outside of its lifetime</td>
<td align="center">Possible*</td>
</tr>
<tr>
<td>casting pointer to the incorrect array</td>
<td align="center">Possible*</td>
</tr>
<tr>
<td>violating pre or post conditions</td>
<td align="center">Yes</td>
</tr>
<tr>
<td>violating asserts</td>
<td align="center">Yes</td>
</tr>
<tr>
<td>reaching <code>unreachable()</code> code</td>
<td align="center">Yes</td>
</tr>
</tbody>
</table><p>* “Possible” indicates trapping is implementation dependent.</p><h2 id="pre-conditions-for-macros-list-of-implementation-dependent-behaviours">List of implementation dependent behaviours</h2><p>Some behaviour is allowed to differ between implementations and platforms.</p><table>
<thead>
<tr>
<th>operation</th>
<th align="center">will trap in safe builds</th>
<th align="center">permitted behaviour</th>
</tr>
</thead>
<tbody>
<tr>
<td>comparing pointers of different provenance</td>
<td align="center">Optional</td>
<td align="center">Any result</td>
</tr>
<tr>
<td>subtracting pointers of different provenance</td>
<td align="center">Optional</td>
<td align="center">Any result</td>
</tr>
<tr>
<td>shifting by more or equal to the bit width</td>
<td align="center">Yes</td>
<td align="center">Any result</td>
</tr>
<tr>
<td>shifting by negative amount</td>
<td align="center">Yes</td>
<td align="center">Any result</td>
</tr>
<tr>
<td>conversion floating point &lt;-&gt; integer type is out of range</td>
<td align="center">Optional</td>
<td align="center">Any result</td>
</tr>
<tr>
<td>conversion between pointer types produces one with incorrect alignment</td>
<td align="center">Optional</td>
<td align="center">Any result / Error</td>
</tr>
<tr>
<td>calling a function through a function pointer that does not match the function</td>
<td align="center">Optional</td>
<td align="center">Any result / Error</td>
</tr>
<tr>
<td>attempt to modify a string literal</td>
<td align="center">Optional</td>
<td align="center">Partial modification / Error</td>
</tr>
<tr>
<td>modifying a <code>const</code> variable</td>
<td align="center">Optional</td>
<td align="center">Partial modification / Error</td>
</tr>
</tbody>
</table><h2 id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3">List of undefined behaviour in C, which is defined in C3</h2><h3 id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-signed-integer-overflow">Signed Integer Overflow</h3><p>Signed integer is always wrapped using 2s complement.</p><h3 id="pre-conditions-for-macros-list-of-undefined-behaviour-in-c-which-is-defined-in-c3-modifying-the-intermediate-results-of-an-expression">Modifying the intermediate results of an expression</h3><p>Behaves as if the intermediate result was stored in a variable on the stack.</p><hr><p>title: Builtins
description: Builtins
sidebar:</p><pre><code>order: 226</code></pre><hr><p>The compiler offers builtin constants and functions. Some are only available on certain targets. All builtins use the <code>$$</code>
name prefix.</p><h2 id="pre-conditions-for-macros-builtin-constants">Builtin constants</h2><p>These constants are generated by the compiler and can safely be used by the user.</p><h4>$$BENCHMARK_NAMES</h4><p>An array of names of the benchmark functions.</p><h4>$$BENCHMARK_FNS</h4><p>An array of addresses to the benchmark functions.</p><h4>$$DATE</h4><p>The current date.</p><h4>$$FILE</h4><p>The current file name.</p><h4>$$FILEPATH</h4><p>The current file with path.</p><h4>$$FUNC</h4><p>The current function name, will return “<global>“ on the global level.</global></p><h4>$$FUNCTION</h4><p>The current function as an expression.</p><h4>$$LINE</h4><p>The current line as an integer.</p><h4>$$LINE_RAW</h4><p>Usually the same as $$LINE, but in case of a macro inclusion it returns the line in the macro rather than
the line where the macro was included.</p><h4>$$MODULE</h4><p>The current module name.</p><h4>$$TIME</h4><p>The current time.</p><h2 id="pre-conditions-for-macros-compiler-builtin-functions">Compiler builtin functions</h2><p>The <code>$$</code> namespace defines <em>compiler builtin functions</em>. 
These special functions are <strong>not guaranteed</strong> to exist on 
all platforms, and are ways to wrap compiler implemented, optimized implementations
of some particular functionality. They are mainly intended for standard 
library <em>internal</em> use. The standard library have macros 
that wrap these builtins, so they should normally not be used on their own. </p><h4>$$trap</h4><p>Emits a trap instruction. </p><h4>$$unreachable</h4><p>Inserts an “unreachable” annotation.</p><h4>$$stacktrace</h4><p>Returns the current “callstack” reference if available. OS and compiler dependent.</p><h4>$$volatile_store</h4><p>Takes a variable and a value and stores the value as a volatile store.</p><h4>$$volatile_load</h4><p>Takes a variable and returns the value using a volatile load.</p><h4>$$memcpy</h4><p>Builtin memcpy instruction.</p><h4>$$memset</h4><p>Builtin memset instruction.</p><h4>$$prefetch</h4><p>Prefetch a memory location.</p><h4>$$sysclock</h4><p>Access to the cycle counter register (or similar low latency clock) on supported
architectures (e.g. RDTSC on x86), otherwise $$sysclock will yield 0.</p><h4>$$syscall</h4><p>Makes a syscall according to the platform convention on platforms where it is supported.</p><h3 id="pre-conditions-for-macros-compiler-builtin-functions-math-functions">Math functions</h3><p>Functions <code>$$ceil</code>, <code>$$trunc</code>, <code>$$sin</code>, <code>$$cos</code>, <code>$$log</code>, <code>$$log2</code>, <code>$$log10</code>, <code>$$rint</code>, <code>$$round</code>
<code>$$sqrt</code>, <code>$$roundeven</code>, <code>$$floor</code>, <code>$$sqrt</code>, <code>$$pow</code>, <code>$$exp</code>, <code>$$fma</code> and <code>$$fabs</code>, <code>$$copysign</code>,
<code>$$round</code>, <code>$$nearbyint</code>.</p><p>Can be applied to float vectors or numbers. Returns the same type.</p><p>Functions <code>$$min</code>, <code>$$abs</code> and <code>$$max</code> can be applied to any integer or float number or vector.</p><p>Function $pow_int takes a float or floating vector + an integer and returns
the same type as the first parameter.</p><p>Saturated addition, subtraction and left shift for integers and integer vectors:
<code>$$sat_add</code>, <code>$$sat_shl</code>, <code>$$sat_sub</code>.</p><h3 id="pre-conditions-for-macros-compiler-builtin-functions-bit-functions">Bit functions</h3><h4>$$fshl and $$fshr</h4><p>Funnel shift left and right, takes either two integers or two integer vectors.</p><h4>$$ctz, $$clz, $$bitreverse, $$bswap, $$popcount</h4><p>Bit functions work on an integer or an integer vector.</p><h3 id="pre-conditions-for-macros-compiler-builtin-functions-vector-functions">Vector functions</h3><p><code>$$reduce_add</code>, <code>$$reduce_mul</code>, <code>$$reduce_and</code>, <code>$$reduce_or</code>, <code>$$reduce_xor</code> work on integer vectors.</p><p><code>$$reduce_fadd</code>, <code>$$reduce_fmul</code> works on float vectors.</p><p><code>$$reduce_max</code>, <code>$$reduce_min</code> works on any vector.</p><p><code>$$reverse</code> reverses the values in any vector.</p><p><code>$$shufflevector</code> rearranges the values of two vectors using a fixed mask into
a resulting vector.</p><hr><p>title: Library Packaging
description: Library Packaging
sidebar:</p><pre><code>order: 227</code></pre><hr><p><em>Note, the library system is in early alpha, everything below is subject to change</em></p><p>C3 allows convenient packaging of C3 source files optionally with  statically or dynamically linked libraries.
To use such a library, simply pass the path to the library directory and add the library you wish to link to.
The compiler will resolve any dependencies to other libraries and only compile those that are in use.</p><h2 id="pre-conditions-for-macros-how-it-works">How it works</h2><p>A library may be used either packaged or unpacked. If unpacked, it is simply a directory with the <code>.c3l</code>
suffix, which contains all the necessary files, if packed, this is simply a compressed variant of 
a directory with the same structure.</p><h3 id="pre-conditions-for-macros-how-it-works-the-specification">The specification</h3><p>In the top of the library resides the <code>manifest.json</code> file which has the following structure:</p><pre><code class="lang-json">{
  <span class="string">"provides"</span> : <span class="string">"my_lib"</span>,
  <span class="string">"execs"</span> : [],
  <span class="string">"targets"</span> : {
    <span class="string">"macos-x<span class="number">64</span>"</span> : {
      <span class="string">"linkflags"</span> : [],
      <span class="string">"dependencies"</span> : [],
      <span class="string">"linked-libs"</span> : [<span class="string">"my_lib_static"</span>, <span class="string">"Cocoa.framework"</span>, <span class="string">"c"</span>]
    },
    <span class="string">"windows-x<span class="number">64</span>"</span> : {
      <span class="string">"linkflags"</span> : [<span class="string">"/stack:<span class="number">65536</span>"</span>],
      <span class="string">"dependencies"</span> : [<span class="string">"ms_my_extra"</span>],
      <span class="string">"linked-libs"</span> : [<span class="string">"my_lib_static"</span>, <span class="string">"kernel<span class="number">32</span>"</span>],
      <span class="string">"execs"</span> : [],
    }
  }
}</code></pre><p>In the example here, this library supports two targets: <strong>macos-x64</strong> and <strong>windows-x64</strong>. If 
we tried to use it with any other target, the compiler would give an error.</p><p>We see that if we use the <strong>windows-x64</strong> target it will also load the <strong>ms_my_extra</strong> library. And
we also see that the linker would have a special argument on that platform.</p><p>Both targets expect <code>my_lib_static</code> to be available for linking. If this library provides this
or dynamic library it will be in the target sub-directories, so it likely has the path 
<code>windows-x64/my_lib_static.lib</code> and <code>macos-z64/libmy_lib_static.a</code>.</p><h3 id="pre-conditions-for-macros-how-it-works-source-code">Source code</h3><p>Aside from the manifest, C3 will read any C and C3 files in the same directory as <code>manifest.json</code>
as well as any files in the target subdirectory for the current target. For static libraries
typically a <code>.c3i</code> file (that is, a C3 file without any implementations) is provided, similar to
how .h files are used in C.</p><h3 id="pre-conditions-for-macros-how-it-works-additional-actions">Additional actions</h3><p><code>"exec"</code>, which is available both at the top level and per-target, lists the scripts which will be
invoked when a library is used. This requires running the compiler at <strong>full trust level</strong> using the 
<code>--trust=full</code> option.</p><h2 id="pre-conditions-for-macros-how-to-automatically-export-libraries">How to – automatically – export libraries</h2><p><em>This is not implemented yet, docs will materialize once it is finished</em></p><hr><p>title: Inline Assembly
description: Inline Assembly
sidebar:</p><pre><code>order: 232</code></pre><hr><p>C3 provides two ways to insert inline assembly: asm strings and asm blocks. </p><h2 id="pre-conditions-for-macros-asm-strings">Asm strings</h2><p>This form takes a single compile time string and passes it directly to the underlying
backend without any changes.</p><pre><code class="lang-c3">int x = <span class="number">0</span>;
asm(<span class="string">"nop"</span>);
int y = x;</code></pre><h2 id="pre-conditions-for-macros-asm-block">Asm block</h2><p>Asm blocks uses a common grammar for all types of processors. It assumes that
all assembly statements can be reduced to the format:</p><pre><code class="lang-asm">instruction (arg (<span class="string">','</span> arg)*)?;</code></pre><p>Where an arg is:</p><ol>
<li>An identifier, e.g. <code>FOO</code>, <code>x</code>.</li>
<li>A numeric constant <code>1</code> <code>0xFF</code> etc.</li>
<li>A register name (always lower case with a ‘$’ prefix) e.g. <code>$eax</code> <code>$r7</code>.</li>
<li>The address of a variable e.g. <code>&amp;x</code>.</li>
<li>An indirect address: <code>[addr]</code> or <code>[addr + index * &lt;const&gt; + offset]</code>.</li>
<li>Any expression inside of “()” (will be evaluated before entering the <code>asm</code> block).</li>
</ol><p>An example:</p><pre><code class="lang-c3">int aa = <span class="number">3</span>;
int g;
int* gp = &amp;g;
int* xa = &amp;a;
usz asf = <span class="number">1</span>;
asm
{
    movl x, <span class="number">4</span>;                  <span class="comment">// Move <span class="number">4</span> into the variable x</span>
    movl [gp], x;               <span class="comment">// Move the value of x into the address in gp</span>
    movl x, <span class="number">1</span>;                  <span class="comment">// Move <span class="number">1</span> into x</span>
    movl [xa + asf * <span class="number">4</span> + <span class="number">4</span>], x; <span class="comment">// Move x into the address at xa[asf + <span class="number">1</span>]</span>
    movl $eax, (<span class="number">23</span> + x);        <span class="comment">// Move <span class="number">23</span> + x into EAX</span>
    movl x, $eax;               <span class="comment">// Move EAX into x</span>
    movq [&amp;z], <span class="number">33</span>;              <span class="comment">// Move <span class="number">33</span> into the memory address of z</span>
}</code></pre><p>The asm block will infer register clobbers and in/out parameters.</p><p><em>\</em>Please note that the current state of inline asm is a <strong>work in progress</strong>,
only a subset of x86, aarch64 and riscv instructions are available, other platforms
have no support at all. It is likely that the grammar will be extended as more 
architectures are supported. More instructions can be added as they are needed,
so please file issues when you encounter missing instructions you need.*</p><hr><p>title: Build Commands
description: Build Commands
sidebar:</p><pre><code>order: 240</code></pre><hr><p>import { FileTree } from ‘@astrojs/starlight/components’;</p><p>Building a project is done by invoking the C3 compiler with the <code>build</code> or <code>run</code> command inside of the project structure. The compiler will search upwards in the file hierarchy until a <code>project.json</code> file is found.</p><p>You can also <a href="https://waveproc.github.io/build-your-project/project-config/">customise the project build config</a>.</p><h2 id="pre-conditions-for-macros-compile-individual-files">Compile Individual Files</h2><p>By default the compiler is compiling stand-alone files to output an executable binary.</p><pre><code class="lang-bash">c<span class="number">3</span>c compile &lt;file<span class="number">1</span>&gt; &lt;file<span class="number">2</span>&gt; &lt;file<span class="number">3</span>&gt;</code></pre><h2 id="pre-conditions-for-macros-run">Run</h2><p>When starting out, with C3 it’s natural to use <code>compile-run</code> to try things out. For larger projects, the built-in build system is recommended instead. </p><p>The <code>compile-run</code> command works same as compilation, but also immediately runs the resulting executable.</p><pre><code class="lang-bash">c<span class="number">3</span>c compile-run &lt;file<span class="number">1</span>&gt; &lt;file<span class="number">2</span>&gt; &lt;file<span class="number">3</span>&gt;</code></pre><h2 id="pre-conditions-for-macros-common-additional-parameters">Common additional parameters</h2><p>Additional parameters:
- <code>--lib &lt;path&gt;</code> add a library to search.
- <code>--output &lt;path&gt;</code> override the output directory.
- <code>--path &lt;path&gt;</code> execute as if standing at <code>&lt;path&gt;</code></p><h2 id="pre-conditions-for-macros-init-a-new-project">Init a new project</h2><pre><code class="lang-bash">c<span class="number">3</span>c init &lt;project_name&gt; [optional path]</code></pre><p>Create a new project structure in the current directory.</p><p>Use the <code>--template</code> to select a template. The following are built in:</p><ul>
<li><code>exe</code> - the default template, produces an executable.</li>
<li><code>static-lib</code> - template for producing a static library.</li>
<li><code>dynamic-lib</code> - template for producing a dynamic library.</li>
</ul><p>It is also possible to give the path to a custom template.</p><p>Additional parameters:
- <code>--template &lt;path&gt;</code> indicate an alternative template to use.</p><p>For example <code>c3c init hello_world</code> creates the following structure:</p><filetree>
- build/
- docs/
- lib/
- resources/
- scripts/
- src/
  - main.c3
- test/
- LICENSE
- project.json
- README.md
</filetree><p>Check the <a href="https://waveproc.github.io/build-your-project/project-config/">project configuration docs</a> to learn more about configuring your project.</p><h2 id="pre-conditions-for-macros-test">Test</h2><pre><code class="lang-bash">c<span class="number">3</span>c test</code></pre><p>Will run any tests in the project in the <code>"sources"</code> directory defined in your <code>project.json</code> for example:</p><pre><code class="lang-json5">...
<span class="string">"sources"</span>: [ <span class="string">"src/**"</span> ],
...</code></pre><p>Tests are defined with a <code>@test</code> attribute, for example:</p><pre><code class="lang-c3">fn void! test_fn() @test
{
    assert(true == true, <span class="string">"true is definitely true"</span>);
}</code></pre><h2 id="pre-conditions-for-macros-build">Build</h2><pre><code class="lang-bash">c<span class="number">3</span>c build [target]</code></pre><p>Build the project in the current path. It doesn’t matter where in the project structure you are. </p><p>The built-in templates define two targets: <code>debug</code> (which is the default) and <code>release</code>.</p><h2 id="pre-conditions-for-macros-clean">Clean</h2><pre><code class="lang-bash">c<span class="number">3</span>c clean</code></pre><h2 id="pre-conditions-for-macros-build-and-run">Build and Run</h2><pre><code class="lang-bash">c<span class="number">3</span>c run [target]</code></pre><p>Build the target (if needed) and run the executable.</p><h2 id="pre-conditions-for-macros-clean-and-run">Clean and Run</h2><pre><code class="lang-bash">c<span class="number">3</span>c clean-run [target]</code></pre><p>Clean, build and run the target.</p><h2 id="pre-conditions-for-macros-dist">Dist</h2><pre><code class="lang-bash">c<span class="number">3</span>c dist [target]</code></pre><p><em>Not properly added yet</em></p><p>Clean, build and package the target for distribution.
Will also run the target if it is a executable.</p><h2 id="pre-conditions-for-macros-docs">Docs</h2><pre><code class="lang-bash">c<span class="number">3</span>c docs [target]</code></pre><p><em>Not added yet</em> </p><p>Rebuilds the documentation. </p><h2 id="pre-conditions-for-macros-bench">Bench</h2><pre><code class="lang-bash">c<span class="number">3</span>c bench [target]</code></pre><p>Runs benchmarks on a target.</p><hr><p>title: Project Configuration
description: Project Configuration
sidebar:</p><pre><code>order: 241</code></pre><hr><h1 id="customizing-a-project">Customizing A Project</h1><p>This is a description of the configuration options in <code>project.json</code>:</p><pre><code class="lang-json5">{
  <span class="comment">// Language version of C<span class="number">3</span>.</span>
  <span class="string">"langrev"</span>: <span class="string">"<span class="number">1</span>"</span>,
  <span class="comment">// Warnings used for all targets.</span>
  <span class="string">"warnings"</span>: [ <span class="string">"no-unused"</span> ],
  <span class="comment">// Directories where C<span class="number">3</span> library files may be found.</span>
  <span class="string">"dependency-search-paths"</span>: [ <span class="string">"lib"</span> ],
  <span class="comment">// Libraries to use for all targets.</span>
  <span class="string">"dependencies"</span>: [ ],
  <span class="comment">// Authors, optionally with email.</span>
  <span class="string">"authors"</span>: [ <span class="string">"John Doe &lt;john.doe@example.com&gt;"</span> ],
  <span class="comment">// Version using semantic versioning.</span>
  <span class="string">"version"</span>: <span class="string">"<span class="number"><span class="number">0</span>.<span class="number">1</span></span>.<span class="number">0</span>"</span>,
  <span class="comment">// Sources compiled for all targets.</span>
  <span class="string">"sources"</span>: [ <span class="string">"src/**"</span> ],
  <span class="comment">// C sources if the project also compiles C sources</span>
  <span class="comment">// relative to the project file.</span>
  <span class="comment">// <span class="string">"c-sources"</span>: [ <span class="string">"csource/**"</span> ],</span>
  <span class="comment">// Include directories for C sources relative to the project file.</span>
  <span class="comment">// <span class="string">"c-include-dirs: [ "</span>csource/include<span class="string">" ],</span>
  <span class="comment">// Output location, relative to project file.</span>
  "</span>output<span class="string">": "</span>../build<span class="string">",
  <span class="comment">// Architecture and OS target.</span>
  <span class="comment">// You can use <span class="string">'c<span class="number">3</span>c --list-targets'</span> to list all valid targets,</span>
  <span class="comment">// "</span>target<span class="string">": "</span>windows-x<span class="number">64</span><span class="string">",</span>
  <span class="comment">// Current Target options:</span>
  <span class="comment">//    android-aarch<span class="number">64</span> </span>
  <span class="comment">//    elf-aarch<span class="number">64</span> elf-riscv<span class="number">32</span> elf-riscv<span class="number">64</span> elf-x<span class="number">86</span> elf-x<span class="number">64</span> elf-xtensa</span>
  <span class="comment">//    mcu-x<span class="number">86</span> mingw-x<span class="number">64</span> netbsd-x<span class="number">86</span> netbsd-x<span class="number">64</span> openbsd-x<span class="number">86</span> openbsd-x<span class="number">64</span></span>
  <span class="comment">//    freebsd-x<span class="number">86</span> freebsd-x<span class="number">64</span> ios-aarch<span class="number">64</span> </span>
  <span class="comment">//    linux-aarch<span class="number">64</span> linux-riscv<span class="number">32</span> linux-riscv<span class="number">64</span> linux-x<span class="number">86</span> linux-x<span class="number">64</span> </span>
  <span class="comment">//    macos-aarch<span class="number">64</span> macos-x<span class="number">64</span> </span>
  <span class="comment">//    wasm<span class="number">32</span> wasm<span class="number">64</span> </span>
  <span class="comment">//    windows-aarch<span class="number">64</span> windows-x<span class="number">64</span> </span>
  "</span>targets<span class="string">": {
    "</span>linux-x<span class="number">64</span><span class="string">": {
      <span class="comment">// Executable or library.</span>
      "</span>type<span class="string">": "</span>executable<span class="string">",
      <span class="comment">// Additional libraries, sources</span>
      <span class="comment">// and overrides of global settings here.</span>
    },
  },
  <span class="comment">// Global settings.</span>
  <span class="comment">// C compiler if the project also compiles C sources</span>
  <span class="comment">// defaults to <span class="string">'cc'</span>.</span>
  "</span>cc<span class="string">": "</span>cc<span class="string">",
  <span class="comment">// CPU name, used for optimizations in the LLVM backend.</span>
  "</span>cpu<span class="string">": "</span>generic<span class="string">",
  <span class="comment">// Debug information, may be "</span>none<span class="string">", "</span>full<span class="string">" and "</span>line-tables<span class="string">".</span>
  "</span>debug-info<span class="string">": "</span>full<span class="string">",
  <span class="comment">// FP math behaviour: "</span>strict<span class="string">", "</span>relaxed<span class="string">", "</span>fast<span class="string">".</span>
  "</span>fp-math<span class="string">": "</span>strict<span class="string">",
  <span class="comment">// Link libc other default libraries.</span>
  "</span>link-libc<span class="string">": true,
  <span class="comment">// Memory environment: "</span>normal<span class="string">", "</span>small<span class="string">", "</span>tiny<span class="string">", "</span>none<span class="string">".</span>
  "</span>memory-env<span class="string">": "</span>normal<span class="string">",
  <span class="comment">// Optimization: "</span>O<span class="number">0</span><span class="string">", "</span>O<span class="number">1</span><span class="string">", "</span>O<span class="number">2</span><span class="string">", "</span>O<span class="number">3</span><span class="string">", "</span>O<span class="number">4</span><span class="string">", "</span>O<span class="number">5</span><span class="string">", "</span>Os<span class="string">", "</span>Oz<span class="string">".</span>
  "</span>opt<span class="string">": "</span>O<span class="number">0</span><span class="string">",
  <span class="comment">// Code optimization level: "</span>none<span class="string">", "</span>less<span class="string">", "</span>more<span class="string">", "</span>max<span class="string">".</span>
  "</span>optlevel<span class="string">": "</span>none<span class="string">",
  <span class="comment">// Code size optimization: "</span>none<span class="string">", "</span>small<span class="string">", "</span>tiny<span class="string">".</span>
  "</span>optsize<span class="string">": "</span>none<span class="string">",
  <span class="comment">// Relocation model: "</span>none<span class="string">", "</span>pic<span class="string">", "</span>PIC<span class="string">", "</span>pie<span class="string">", "</span>PIE<span class="string">".</span>
  "</span>reloc<span class="string">": "</span>none<span class="string">",
  <span class="comment">// Trap on signed and unsigned integer wrapping for testing.</span>
  "</span>trap-on-wrap<span class="string">": false,
  <span class="comment">// Turn safety (contracts, runtime bounds checking, null pointer checks etc).</span>
  "</span>safe<span class="string">": true,
  <span class="comment">// Compile all modules together, enables more inlining.</span>
  "</span>single-module<span class="string">": true,
  <span class="comment">// Use / don't use soft float, value is otherwise target default.</span>
  "</span>soft-float<span class="string">": false,
  <span class="comment">// Strip unused code and globals from the output.</span>
  "</span>strip-unused<span class="string">": true,
  <span class="comment">// The size of the symtab, which limits the amount</span>
  <span class="comment">// of symbols that can be used. Should usually not be changed.</span>
  "</span>symtab<span class="string">": <span class="number">1048576</span>,
  <span class="comment">// Use the system linker.</span>
  "</span>linker<span class="string">": "</span>cc<span class="string">",
  <span class="comment">// Include the standard library.</span>
  "</span>use-stdlib<span class="string">": true,
  <span class="comment">// Set general level of x<span class="number">64</span> cpu: "</span>baseline<span class="string">", "</span>ssse<span class="number">3</span><span class="string">", "</span>sse<span class="number">4</span><span class="string">", "</span>avx<span class="number">1</span><span class="string">", "</span>avx<span class="number">2</span>-v<span class="number">1</span><span class="string">", "</span>avx<span class="number">2</span>-v<span class="number">2</span><span class="string">", "</span>avx<span class="number">512</span><span class="string">", "</span>native<span class="string">".</span>
  "</span>x<span class="number">86</span>cpu<span class="string">": "</span>native<span class="string">",
  <span class="comment">// Set max type of vector use: "</span>none<span class="string">", "</span>mmx<span class="string">", "</span>sse<span class="string">", "</span>avx<span class="string">", "</span>avx<span class="number">512</span><span class="string">", "</span>native<span class="string">".</span>
  "</span>x<span class="number">86</span>vec<span class="string">": "</span>sse",
}</code></pre><p>By default, an executable is assumed, but changing the type to <code>"static-lib"</code> or <code>"dynamic-lib"</code> 
creates static library and dynamic library targets respectively.</p><p><em>This part will be updated, stay tuned</em> </p><h2 id="customizing-a-project-compilation-options">Compilation options</h2><p>The project file contains common settings at the top level, that can be overridden by each
target, by simply assigning that particular key. So if the top level defines <code>target</code> to be <code>macos-x64</code>
and the actual target defines it to be <code>windows-x64</code>, then the <code>windows-x64</code> will be used for compilation.</p><p>Similarly, compiler command line parameters can be used in turn to override the target setting.</p><h4>targets</h4><p>The list of targets that can be built.</p><h4>dependencies</h4><p>List of C3 libraries (“.c3l”) to use when compiling the target.</p><h4>sources</h4><p>List of source files to compile and for tests which will run.</p><h4>cc</h4><p>C compiler to use for compiling C sources (if C sources are compiled together with C3 files).</p><h4>c-sources</h4><p>List of C sources to compile, using the default C compiler.</p><h4>linker-search-paths</h4><p>This adds paths for the linker to search, when linking normal C libraries.</p><h4>linked-libraries</h4><p>This is a list of C libraries to link to. The names need to follow the normal
naming standard for how libraries are provided to the system linker,
so for example on Linux, libraries have names like <code>libfoo.a</code> but when
presented to the linker the name is <code>foo</code>. As an example <code>"linked-libraries": ["curl"]</code>
would on Linux look for the library <code>libcurl.a</code> and <code>libcurl.so</code> in the 
paths given by “linker-search-paths”.</p><h4>version</h4><p><em>Not handled yet</em></p><p>Version for library, will also be provided as a compile time constant.</p><h4>authors</h4><p><em>Not handled yet</em></p><p>List of authors to add for library compilation.</p><h4>langrev</h4><p><em>Not handled yet</em></p><p>The language revision to use. </p><h4>features</h4><p>This is a list of upper-case constants that can be tested for
in the source code using <code>$feature(NAME_OF_FEATURE)</code>.</p><h4>warnings</h4><p><em>Not completely supported yet</em></p><p>List of warnings to enable during compilation.</p><h4>opt</h4><p>Optimization setting: O0, O1, O2, O3, O4, O5, Os, Oz.</p><h2 id="customizing-a-project-target-options">Target options</h2><h4>type</h4><p>This mandatory option should be one of “executable”, “dynamic-lib” and “static-lib”.</p><p><em>More types will be added</em></p><h2 id="customizing-a-project-using-environment-variables">Using environment variables</h2><p><em>Not supported yet</em></p><p>In addition to constants any values starting with “$” will be assumed to be environment variables.</p><p>For example “$HOME” would on unix systems return the home directory. For strings that start with $ but <em>should not</em> be interpreted as an environment variable. For example, the string <code>"\$HOME"</code> would be interpreted as the plain string “$HOME”</p><hr><p>title: Frequently Asked Questions
description: Frequently asked questions about C3
sidebar:</p><pre><code>order: 700</code></pre><hr><h2 id="customizing-a-project-standard-library">Standard library</h2><p><strong>Q:</strong> What are the most fundamental modules in the standard library?</p><p><strong>A:</strong> By default C3 will implicitly import anything in <code>std::core</code> into
your files. It contains string functions, allocators and conveniences for
doing type introspection. The latter is in particular useful when writing
contracts for macros:</p><ul>
<li><code>std::core::array</code> functions for working with arrays.</li>
<li><code>std::core::builtin</code> contains functions that are to be used without a module
prefix, <code>unreachable()</code>, <code>bitcast()</code>, <code>@catch()</code> and <code>@ok()</code>
are especially important.</li>
<li><code>std::core::cinterop</code> contains types which will match the C types on the platform.</li>
<li><code>std::core::dstring</code> Has the dynamic string type.</li>
<li><code>std::core::mem</code> contains <code>malloc</code> etc, as well as functions for atomic
and volatile load / store.</li>
<li><code>std::core::string</code> has all string functionality, including conversions,
splitting and searching strings.</li>
</ul><p>Aside from the <code>std::core</code> module, <code>std::collections</code> is important as it
holds various containers. Of those the generic <code>List</code> type in <code>std::collections::list</code>
and the <code>HashMap</code> in <code>std::collections::map</code> are very frequently used.</p><p>IO is a must, and <code>std::io</code> contains <code>std::io::file</code> for working with files,
<code>std::io::path</code> for working with paths. <code>std::io</code> itself contains
functionality to writing to streams in various ways. Useful streams can
be found in the <code>stream</code> sub folder.</p><p>Also of interest could be <code>std::net</code> for sockets. <code>std::threads</code> for
platform independent threads, <code>std::time</code> for dates and timers, <code>libc</code> for
invoking libc functions. <code>std::os</code> for working with OS specific code and
<code>std::math</code> for math functions and vector methods.</p><p><strong>Q:</strong> How do strings work?</p><p><strong>A:</strong> C3 defines a native string type <code>String</code>, which is a distinct <code>char[]</code>. Because
<code>char[]</code> is essentially a pointer + length, some care has to be taken to
ensure that the pointer is properly managed.</p><p>For dynamic strings, or as a string builder, use <code>DString</code>. To get a String from
a DString you can either get a <em>view</em> using <code>str_view()</code> or make a copy using <code>copy_str()</code>.
In the former case, the String may become invalid if DString is then mutated.</p><p><code>ZString</code> is a distinct zero terminated <code>char*</code>. It is used to model zero-terminated
strings like in C. It is mostly useful interfacing with C.</p><p><code>WString</code> is a <code>Char16*</code>, useful on those platforms, like Win32, where this
is the common unicode format. Like ZString, it is mostly useful when interfacing
with C.</p><h2 id="customizing-a-project-language-features">Language features</h2><p><strong>Q:</strong> How do I use slices?</p><p><strong>A:</strong> Slices are typically preferred in any situation where one in C would pass
a pointer + length. It is a struct containing a pointer + a length.</p><p>Given an array, pointer or another slice you use either <code>[start..end]</code>
or <code>[start:len]</code> to create it:</p><pre><code class="lang-c3">int[<span class="number">100</span>] a;
int[] b = a[<span class="number">3</span>..<span class="number">6</span>]; <span class="comment">// Or a[<span class="number">3</span>:<span class="number">4</span>]</span>
b[<span class="number">0</span>] = <span class="number">1</span>;          <span class="comment">// Same as a[<span class="number">3</span>] = <span class="number">1</span></span></code></pre><p>You can also just pass a pointer to an array:</p><pre><code class="lang-c3">b = &amp;a; <span class="comment">// Same as b = a[<span class="number">0</span>..<span class="number">99</span>];</span></code></pre><p>The start and/or end may be omitted:</p><pre><code class="lang-c3">a[..<span class="number">6</span>]; <span class="comment">// a[<span class="number">0</span>..<span class="number">6</span>]</span>
a[<span class="number">1</span>..]; <span class="comment">// a[<span class="number">1</span>..<span class="number">99</span>]</span>
a[..];  <span class="comment">// a[<span class="number">0</span>..<span class="number">99</span>];</span></code></pre><p>It is possible to use ranges to assign:</p><pre><code class="lang-c3">a[<span class="number">1</span>..<span class="number">2</span>] = <span class="number">5</span>;         <span class="comment">// Assign <span class="number">5</span> to a[<span class="number">1</span>] and a[<span class="number">2</span>]</span>
a[<span class="number">1</span>..<span class="number">3</span>] = a[<span class="number">11</span>..<span class="number">13</span>]; <span class="comment">// Copy <span class="number">11</span>-<span class="number">13</span> to <span class="number">1</span>-<span class="number">3</span></span></code></pre><p>It is important to remember that the <em>lifetime</em> of a slice is the same
as the lifetime of its underlying pointer:</p><pre><code class="lang-c3">fn int[] buggy_code()
{
    int[<span class="number">3</span>] a;
    int[] b = a[<span class="number">0</span>..<span class="number">1</span>];
    return b; <span class="comment">// returning a pointer to a!</span>
}</code></pre><p><strong>Q:</strong> How do I pass varargs to another function that takes varargs?</p><p><strong>A:</strong> Use the splat operator, <code>...</code></p><pre><code class="lang-c3">fn void test(String format, args...)
{
    io::printfn(format, ...args);
}

fn void main()
{
    test(<span class="string">"Format: %s %d"</span>, <span class="string">"Foo"</span>, <span class="number">123</span>);
}</code></pre><p><strong>Q:</strong> What are vectors?</p><p><strong>A:</strong> Vectors are similar to arrays, but declared with <code>[&lt; &gt;]</code> rather than <code>[ ]</code>, the element type may also only
be of integer, float, bool or pointer types. Vectors are backed by SIMD types on supported platforms. Arithmetics
available on the element type is available on the vector and is done element wise:</p><pre><code class="lang-c3">int[&lt;<span class="number">2</span>&gt;] pos = { <span class="number">1</span>, <span class="number">3</span> };
int[&lt;<span class="number">2</span>&gt;] speed = { <span class="number">5</span>, <span class="number">7</span> };
pos += speed;              <span class="comment">// pos is now { <span class="number">6</span>, <span class="number">10</span> }</span></code></pre><p>Swizzling is also supported:</p><pre><code class="lang-c3">int[&lt;<span class="number">3</span>&gt;] test = pos.yxx;    <span class="comment">// test is now { <span class="number">10</span>, <span class="number">6</span>, <span class="number">6</span> }</span></code></pre><p>Any scalar value will be expanded to the vector size:</p><pre><code class="lang-c3"><span class="comment">// Same as speed = speed * { <span class="number">2</span>, <span class="number">2</span> }    </span>
speed = speed * <span class="number">2</span>;</code></pre><h2 id="customizing-a-project-memory-management">Memory management</h2><p><strong>Q:</strong> How do I work with memory?</p><p><strong>A:</strong> There is <code>malloc</code>, <code>calloc</code> and <code>free</code> just like in C. The main difference is that these will invoke whatever
the current heap allocator is, which does not need to be the allocator provided by libc. You can get the current heap
allocator using <code>allocator::heap()</code> and do allocations directly. There is also a temporary allocator.</p><p>Convenience functions are available for allocating particular types: <code>mem::new(Type)</code> would allocate a single <code>Type</code>
on the heap and zero initialize it. <code>mem::alloc(Type)</code> does the same but without zero initialization.</p><p>Alternatively, <code>mem::new</code> can take a second initializer argument:</p><pre><code class="lang-c3">Foo* f<span class="number">1</span> = malloc(Foo.sizeof);                   <span class="comment">// No initialization</span>
Foo* f<span class="number">2</span> = calloc(Foo.sizeof);                   <span class="comment">// Zero initialization</span>
Foo* f<span class="number">3</span> = mem::new(Foo);                        <span class="comment">// Zero initialization</span>
Foo* f<span class="number">4</span> = mem::alloc(Foo);                      <span class="comment">// No initialization</span>
Foo* f<span class="number">5</span> = mem::new(Foo, { <span class="number">4</span>, <span class="number"><span class="number">10</span>.<span class="number">0</span></span>, .a = <span class="number">123</span> }); <span class="comment">// Initialized to argument</span></code></pre><p>For arrays <code>mem::new_array</code> and <code>mem::alloc_array</code> works in corresponding ways:</p><pre><code class="lang-c3">Foo* foos<span class="number">1</span> = malloc(Foo.sizeof * len);    <span class="comment">// No initialization</span>
Foo* foos<span class="number">2</span> = calloc(Foo.sizeof * len);    <span class="comment">// Zero initialization</span>
Foo[] foos<span class="number">3</span> = mem::new_array(Foo, len);   <span class="comment">// Zero initialization</span>
Foo[] foos<span class="number">4</span> = mem::alloc_array(Foo, len); <span class="comment">// No initialization</span></code></pre><p>Regardless of how they are allocated, they can be freed using <code>free()</code></p><p><strong>Q:</strong> How does the temporary allocator work?</p><p><strong>A:</strong> The temporary allocator is a kind of stack allocator. <code>talloc</code>, <code>tcalloc</code> and <code>trealloc</code> correspond to
<code>malloc</code>, <code>calloc</code> and <code>realloc</code>. There is no <code>free</code>, as temporary allocations are free when pool of temporary
objects are released. You use the <code>@pool()</code> macro to create a temporary allocation scope. When execution exits
this scope, the temporary objects are all freed:</p><pre><code class="lang-c3">@pool()
{
    void* some_mem = talloc(<span class="number">128</span>);
    foo(some_mem);
}; 
<span class="comment">// Temporary allocations are automatically freed here.</span></code></pre><p>Similar to the heap allocator, there is also <code>mem::temp_new</code>, <code>mem::temp_alloc</code>, <code>mem::temp_new_array</code> and <code>mem::temp_alloc_array</code>,
which all work like their heap counterparts.</p><p><strong>Q:</strong> How can I return a temporarily allocated object from inside a temporary allocation scope?</p><p><strong>A:</strong> You need to pass in a copy of the temp allocator <em>outside</em> of <code>@pool</code> and allocate explicitly
using that allocator. In addition, you need to pass this temp allocator to <code>@pool</code> to make the
new temp allocator aware of the external temp allocator:</p><pre><code class="lang-c3"><span class="comment">// Store the temp allocator</span>
Allocator* temp = allocator::temp();
@pool(temp)
{
    <span class="comment">// Note, <span class="string">'allocator::temp() != temp'</span> here!</span>
    void* some_mem = talloc(<span class="number">128</span>);
    <span class="comment">// Allocate this on the external temp allocator</span>
    Foo* foo = temp.new(Foo); 
    foo.z = foo(some_mem);
    <span class="comment">// Now <span class="string">"some_mem"</span> will be released,</span>
    <span class="comment">// but the memory pointed to by <span class="string">"foo"</span> is still valid.</span>
    return foo;
};</code></pre><h2 id="customizing-a-project-interfacing-with-c-code">Interfacing with C code</h2><p><strong>Q:</strong> How do I call a C function from C3?</p><p><strong>A:</strong> Just copy the C function definition and prefix it with <code>extern</code> (and don’t forget the <code>fn</code> as well).</p><p>Imagine for example that you have the function <code>double test(int a, void* b)</code>. To call it from C3 just declare
<code>extern fn double test(CInt a, void* b)</code> in the C3 code.</p><p><strong>Q:</strong> My C function / global has a name that doesn’t conform to the C3 name requirements, just <code>extern fn</code> doesn’t 
work.</p><p><strong>A:</strong> In this case you need to give the function a C3-compatible name and then use the <code>@extern</code> attribute to 
indicate its actual external name. For example, the function <code>int *ABC(void *x)</code> could be declared in the C3 code as
<code>extern fn int* abc(void* x) @extern("ABC")</code>.</p><p>There are many examples of this in the <code>std::os</code> modules.</p><h2 id="customizing-a-project-patterns">Patterns</h2><p><strong>Q:</strong> When do I put functionality in method and when is it a free function?</p><p><strong>A:</strong> In the C3 standard library, free functions are preferred unless the function is only acting on the particular
type. Some exceptions exist, but prefer things like <code>io::fprintf(file, "Hello %s", name)</code> over 
<code>file.fprintf("Hello %s", name)</code>. The former also has the advantage that it’s easier to extend to work with many
types.</p><p><strong>Q:</strong> Are there any naming conventions in the standard library what one should know about?</p><p><strong>A:</strong> Yes. A function or method with <code>new</code> in the name will in general do one or more allocations and can take an
optional allocator. A function or method with <code>temp</code> in the name will usually allocate using the temp allocator. 
The method <code>free</code> will free all memory associated with a type. <code>destroy</code> is similar to <code>free</code> but also indicates
that other resources (such as file handles) are released. In some cases <code>close</code> is used instead of <code>destroy</code>.</p><p>Function and variable names use <code>snake_case</code> (all lower case with <code>_</code> separating words).</p><p><strong>Q:</strong> How do I create overloaded methods?</p><p><strong>A:</strong> This can be achieved with macro methods.</p><p>Imagine you have two methods:</p><pre><code class="lang-c3">fn void Obj.func<span class="number">1</span>(&amp;self, String... args) @private {} <span class="comment">// varargs variant</span>
fn void Obj.func<span class="number">2</span>(&amp;self, Foo* pf) @private {} <span class="comment">// Foo pointer variant</span></code></pre><p>We can now create a macro method on <code>Obj</code> which compiles to different calls depending on arguments:</p><pre><code class="lang-c3"><span class="comment">// The macro must be vararg, since the functions take different amount of arguments</span>
macro void Obj.func(&amp;self, ...)
{
    <span class="comment">// Does it have a single argument of type <span class="string">'Foo*'</span>?</span>
    $if $vacount == <span class="number">1</span> &amp;&amp; @typeis($vaarg(<span class="number">0</span>), Foo*):
        <span class="comment">// If so, dispatch to func<span class="number">2</span></span>
        return self.func<span class="number">2</span>($vaarg(<span class="number">0</span>));
    $else
        <span class="comment">// Otherwise, dispatch all varargs to func<span class="number">1</span> </span>
        return self.func<span class="number">1</span>($vasplat());
    $endif
}</code></pre><p>The above would make it possible to use both <code>obj.func("Abc", "Def")</code> and <code>obj.func(&amp;my_foo)</code>.</p><h2 id="customizing-a-project-platform-support">Platform support</h2><p><strong>Q:</strong> How do I use WASM?</p><p><strong>A:</strong> Currently WASM support is really incomplete.</p><p>You can try this:</p><p><code>compile --reloc=none --target wasm32 -g0 --link-libc=no --no-entry mywasm.c3</code></p><p>Unless you are compiling with something that already runs initializers,
you will need to call the function <code>runtime::wasm_initialize()</code> early in your
main <em>or</em> call it externally (for example from JS) with the name <code>_initialize()</code>,
otherwise globals might not be set up properly.</p><p>This should yield an <code>out.wasm</code> file, but there is no CI running on the WASM code
and no one is really using it yet, so the quality is low.</p><p>We do want WASM to be working really well, so if you’re interested in 
writing something in WASM - please reach out to the developer team and we’ll
help you get things working.</p><p><strong>Q:</strong> How do I conditionally compile based on compiler flags?</p><p><strong>A:</strong> You can pass <em>feature flags</em> on the command line using <code>-D SOME_FLAG</code> or using the <code>features</code> key
in the project file.</p><p>You can then test for them using <code>$feature(FLAG_NAME)</code>:</p><pre><code class="lang-c3">int my_var @if($feature(USE_MY_VAR));

fn int test()
{
    $if $feature(USE_MY_VAR):
        return my_var;
    $else
        return <span class="number">0</span>;
    $endif
}</code></pre><h2 id="customizing-a-project-syntax-language-design">Syntax &amp; Language design</h2><p><strong>Q:</strong> Why does C3 require that types start with upper case but functions with lower case?</p><p><strong>A:</strong> C grammar is ambiguous. Usually compilers implement either the so-called lexer hack, but other methods
exist as well, such as delayed parsing. It is also possible to make it unambiguous using infinite lookahead.</p><p>However, all of those methods makes it much harder for tools to search the source code accurately. By making
the naming convention part of the grammar, C3 is straightforward to parse with a single token lookahead.</p><p><strong>Q:</strong> Why are there no closures and only non-capturing lambdas?</p><p><strong>A:</strong> With closures, life-time management of captured variables become important to track. This can become
arbitrarily complex, and without RAII or any other memory management technique it is fairly difficult to
make code safe. Non-capturing lambdas on the other hand are fairly safe.</p><p><strong>Q:</strong> Why is it called C3 and not something better?</p><p><strong>A:</strong> Naming a programming language isn’t easy. Most programming languages have pretty bad names, and
while C3 isn’t the best, no real better alternative has come along.</p><p><strong>Q:</strong> Why are there no static methods?</p><p><strong>A:</strong> Static methods creates a tension between free functions in modules and functions namespaced by the type.
Java for example, resolves this by not having free functions at all. C3 solves it by not having static methods (nor
static variables). Consequently more functions becomes part of the module rather than the type.</p><p><strong>Q:</strong> Why do macros with trailing bodies require <code>;</code> at the end?</p><pre><code class="lang-c3">@test()
{
   <span class="comment">// code</span>
}; <span class="comment">// &lt;- Why is this needed?</span></code></pre><p><strong>A:</strong> All macro calls, including those with a trailing body, are expressions, so it would be ambiguous
to let them terminate a statement without a much more complicated grammar. An example:</p><pre><code class="lang-c3"><span class="comment">// How can the parser determine that the </span>
<span class="comment">// last `}` ends the expression? (And does it?)</span>
int a = @test() {} + @test() {}
*b = <span class="number">123</span>;
<span class="comment">// In comparison, the grammar for this is easy:</span>
int a = @test() {} + @test() {};
*b = <span class="number">123</span>;</code></pre><p>C3 strives for a simple grammar, and so the trade-off having to use <code>;</code> was a fairly
low prices to pay for this feature.</p><p><strong>Q:</strong> Why do only macros have ref arguments?</p><p><strong>A:</strong> Ref arguments break the general contract of a call: what looks like a pass-by-value 
may suddenly be passed by reference. This makes code reading much harder, but is popular 
in C++ because: (1) No need for <code>-&gt;</code> (2) It prevents passing of null pointers. Neither
of these are required in C3 (<code>-&gt;</code> is not needed, and <code>&amp;</code> in the parameter contract will
prevent nulls).</p><p>This leaves the case where there is a benefit for the user to create an implicit <code>&amp;</code> 
on a call. These cases should be rare, and in C3, it’s not a problem creating a wrapper
macro in those cases.</p><p>Note that macros that violate the call contract, such as ones using ref arguments, need
to have the <code>@</code> name prefix to indicate that it is indeed possibly violating 
“value is passed by value” semantics.</p><hr><p>title: All Features
description: A list of all features of C3.
sidebar:</p><pre><code>order: 701</code></pre><hr><p>Here is a summary of <em>all</em> the features of C3 and changes from C</p><h2 id="customizing-a-project-symbols-and-literals">Symbols and literals</h2><p>Changes relating to literals, identifiers etc.</p><h3 id="customizing-a-project-symbols-and-literals-added">Added</h3><ol>
<li>0o prefix for octal.</li>
<li>0b prefix for binary.</li>
<li>Optional “_” as digit separator.</li>
<li>Hexadecimal byte data, e.g <code>x"abcd"</code>.</li>
<li>Base64 byte data, e.g. <code>b64"QzM="</code>.</li>
<li>Type name restrictions (PascalCase).</li>
<li>Variable and function name restrictions (must start with lower case letter).</li>
<li>Constant name restrictions (no lower case).</li>
<li>Character literals may be 2, 4, 8, 16 bytes long. (2cc, 4cc etc).</li>
<li>Raw string literals between “`”.</li>
<li><code>\e</code> escape character.</li>
<li>Source code must be UTF-8.</li>
<li>Assumes <code>\n</code> for new row <code>\r</code> is stripped from source.</li>
<li>Bit-width integer and float suffixes: <code>u8</code>/<code>i8</code>/<code>u16</code>/<code>i16</code>/… <code>f32</code>/<code>f64</code>/… </li>
<li>The <code>null</code> literal is a pointer value of 0.</li>
<li>The <code>true</code> and <code>false</code> are boolean constants true and false.</li>
</ol><h3 id="customizing-a-project-symbols-and-literals-removed">Removed</h3><ol>
<li>Trigraphs / digraphs.</li>
<li>0123-style octal.</li>
<li><code>z</code>, <code>LL</code> and <code>ULL</code> suffixes.</li>
</ol><h2 id="customizing-a-project-built-in-types">Built-in types</h2><h3 id="customizing-a-project-built-in-types-added">Added</h3><ol>
<li>Type declaration is left to right: <code>int[4]*[2] a;</code> instead of <code>int (*a[2])[4];</code> </li>
<li>Simd vector types using <code>[&lt;&gt;]</code> syntax, e.g. <code>float[&lt;4&gt;]</code>, use <code>[&lt;*&gt;]</code> for inferred length.</li>
<li>Slice type built in, using <code>[]</code> suffix, e.g. <code>int[]</code></li>
<li>Distinct types, similar to a typedef but forms a new type. (Example: the <code>String</code> type is a distinct <code>char[]</code>)</li>
<li>Built-in 128-bit integer on all platforms.</li>
<li><code>char</code> is an unsigned 8-bit integer. <code>ichar</code> is its signed counterpart.</li>
<li>Well-defined bitwidth for integer types: ichar/char (8 bits), 
short/ushort (16 bits), int/uint (32 bits), long/ulong (64 bits), 
int128/uint128 (128 bits)</li>
<li>Pointer-sized <code>iptr</code> and <code>uptr</code> integers.</li>
<li><code>isz</code> and <code>usz</code> integers corresponding to the <code>size_t</code> bitwidth.</li>
<li>Optional types are formed using the <code>!</code> suffix.</li>
<li><code>bool</code> is the boolean type.</li>
<li><code>typeid</code> is a unique type identifier for a type, it can be used at runtime and compile time.</li>
<li><code>any</code> contains a <code>typeid</code> and <code>void*</code> allowing it to act as a reference to any type of value.</li>
<li><code>anyfault</code> holds any <code>fault</code> value (see below).</li>
</ol><h3 id="customizing-a-project-built-in-types-changed">Changed</h3><ol>
<li>Inferred array type uses <code>[*]</code> (e.g. <code>int[*] x = { 1, 2 };</code>).</li>
<li>Flexible array member uses <code>[*]</code>.</li>
</ol><h3 id="customizing-a-project-built-in-types-removed">Removed</h3><ol>
<li>The spiral rule type declaration (see above).</li>
<li>Complex types</li>
<li>size_t, ptrdiff_t (see above).</li>
<li>Array types do not decay.</li>
</ol><h2 id="customizing-a-project-types">Types</h2><h3 id="customizing-a-project-types-added">Added</h3><ol>
<li><code>bitstruct</code> a struct with a container type allowing precise control over bit-layout, replacing bitfields and enum masks.</li>
<li><code>fault</code> an enum type with unique values which are used together with optional.</li>
<li>Vector types.</li>
<li>Optional types.</li>
<li><code>enum</code> allows a set of unique constants to be associated with each enum value.</li>
<li>Compile time reflection and limited runtime reflection on types (see “Reflection”)</li>
<li>All types have a <code>typeid</code> property uniquely referring to that particular type.</li>
<li>Distinct types, which are similar to aliases, but represent distinctly different types.</li>
<li>Types may have methods. Methods can be added to any type, including built-in types.</li>
<li>Subtyping: using <code>inline</code> on a struct member allows a struct to be implicitly converted to this member type and use corresponding methods.</li>
<li>Using <code>inline</code> on a distinct type allows it to be implicitly converted <em>to</em> its base type (but not vice versa).</li>
<li>Types may add operator overloading to support <code>foreach</code> and subscript operations.</li>
<li>Generic types through generic modules, using <code>(&lt; ... &gt;)</code> for the generic parameter list (e.g. <code>List(&lt;int&gt;) list;</code>).</li>
<li>Interface types, <code>any</code> types which allows dynamic invocation of methods.</li>
</ol><h3 id="customizing-a-project-types-changed">Changed</h3><ol>
<li><code>typedef</code> is replaced by <code>def</code> and has somewhat different syntax (e.g. <code>def MyTypeAlias = int;</code>).</li>
<li>Function pointer syntax is prefix <code>fn</code> followed by a regular function declaration without the function name.</li>
</ol><h3 id="customizing-a-project-types-removed">Removed</h3><ol>
<li>Enums, structs and unions no longer have distinct namespaces.</li>
<li>Enum, struct and union declarations should not have a trailing ‘;’</li>
<li>Inline <code>typedef</code> is not allowed. <code>def</code> can only be used at the top level.</li>
<li>Anonymous structs are not allowed.</li>
<li>Type qualifiers are all removed, including <code>const</code>, <code>restrict</code>, <code>volatile</code></li>
<li>Function pointers types <strong>cannot</strong> be used “raw”, but must always be used through a type alias.</li>
</ol><h3 id="customizing-a-project-types-introspection">Introspection</h3><p>Compile time type methods: <code>alignof</code>, <code>associated</code>, <code>elements</code>, <code>extnameof</code>, <code>inf</code>, <code>inner</code>, <code>kindof</code>, <code>len</code>,
<code>max</code>, <code>membersof</code>, <code>min</code>, <code>nan</code>, <code>names</code>, <code>params</code>, <code>returns</code>, <code>sizeof</code>, <code>typeid</code>, <code>values</code>,
<code>qnameof</code>, <code>is_eq</code>, <code>is_ordered</code>.</p><p>Runtime type methods: <code>inner</code>, <code>kind</code>, <code>len</code>, <code>names</code>, <code>sizeof</code>.</p><h2 id="customizing-a-project-expressions">Expressions</h2><h3 id="customizing-a-project-expressions-added">Added</h3><ol>
<li>Expression block using <code>{| ... |}</code>. Somewhat similar to GCC statement expressions.</li>
<li>Array initializers may use ranges. (e.g. <code>int[256] x = { [0..128] = 1 }</code>)</li>
<li><code>?:</code> operator, returning the first value if it can be converted to a boolean true, otherwise the second value is returned.</li>
<li>Orelse <code>??</code> returning the first value if it is a result, the second if the first value was an optional value.</li>
<li>Rethrow <code>!</code> suffix operator with an implicit <code>return</code> the value if it was an optional value.</li>
<li>Dynamic calls, allowing calls to be made on the <code>any</code> and interfaces dispatched using a dynamic mechanism.</li>
<li>Create a slice using a range subscript (e.g. <code>a[4..8]</code> to form a slice from element 4 to element 8).</li>
<li>Two range subscript methods: <code>[start..inclusive_end]</code> and <code>[start:length]</code>. Start, end and length may be omitted for default values.</li>
<li>Indexing from end: slices, arrays and vectors may be indexed from the end using <code>^</code>. <code>^1</code> represents the last element. This works for ranges as well.</li>
<li>Range assignment, assign a single value to an entire range e.g. <code>a[4..8] = 1;</code>.</li>
<li>Slice assignment, copy one range to the other range e.g. <code>a[4..8] = b[8..12];</code>.</li>
<li>Array, vector and slice comparison: <code>==</code> can be used to make an element-wise comparison of two containers. </li>
<li><code>?</code> suffix operator turns a fault into an optional value.</li>
<li><code>!!</code> suffix panics if the value is an optional value.</li>
<li><code>$defined(...)</code> returns true if the last expression is defined (sub-expressions must be valid).</li>
<li><code>$and(...)</code> <code>$or(...)</code> perform compile time logic, and may also be written as <code>&amp;&amp;&amp;</code> and <code>|||</code> respectively. </li>
<li>It does not check any elements after the first false value found for <code>$and()</code> also written as <code>&amp;&amp;&amp;</code>. To check both conditions are false use: <code>!false_condition &amp;&amp;&amp; !false_condition</code>.</li>
<li>It does not check any values after the first true found for <code>$or()</code> also written as <code>|||</code>.</li>
<li>Lambdas (anonymous functions) may be defined, they work just like functions and do not capture any state.</li>
<li>Simple bitstructs (only containing booleans) may be manipulated using bit operations <code>&amp; ^ | ~</code> and assignment.</li>
<li>Structs may implicitly convert to their <code>inline</code> member if they have one.</li>
<li>Pointers to arrays may implicitly convert to slices.</li>
<li>Any pointer may implicitly convert to an <code>any</code> with type being the pointee.</li>
<li>Optional values will implicitly invoke “flatmap” on an expression it is a subexpression of.</li>
<li>Swizzling for arrays and vectors.</li>
</ol><h3 id="customizing-a-project-expressions-changed">Changed</h3><ol>
<li>Compound literals use <code>Type { ... }</code> rather than <code>(Type) { ... }</code></li>
<li>Operator precedence of bit operations is higher than <code>+</code> and <code>-</code>.</li>
<li>Well defined-evaluation order: left-to-right, assignment after expression evaluation.</li>
<li><code>sizeof</code> is <code>$sizeof</code> and only works on expressions. Use <code>Type.sizeof</code> on types.</li>
<li><code>alignof</code> is <code>$alignof</code> for expressions. Types use <code>Type.alignof</code>.</li>
<li>Narrowing conversions are only allowed if all sub-expressions is as small or smaller than the type.</li>
<li>Widening conversions are only allowed on simple expressions (i.e. most binary expressions and some unary may not be widened)</li>
</ol><h3 id="customizing-a-project-expressions-removed">Removed</h3><ol>
<li>The comma operator is removed.</li>
</ol><h3 id="customizing-a-project-expressions-cast-changes">Cast changes</h3><h2 id="customizing-a-project-functions">Functions</h2><h3 id="customizing-a-project-functions-added">Added</h3><ol>
<li>Functions may be invoked using named arguments, the name is the dot-prefixed parameter name, e.g. <code>foo(name: a, len: 2)</code>.</li>
<li>Typed varargs are declared <code>Type... argument</code>, and will take 0 or more arguments of the given type.</li>
<li>It is possible to “splat” an array or slice into the location of a typed vararg using <code>...</code>: <code>foo(a, b, ...list)</code></li>
<li><code>any</code> varargs are declared <code>argument...</code>, it can take 0 or more arguments of any type which are implicitly converted to the <code>any</code> type.</li>
<li>The function declaration may have <code>@inline</code> or <code>@noinline</code> as a default.</li>
<li>Using <code>@inline</code> or <code>@noinline</code> on a function call expression will override the function default.</li>
<li>Type methods are functions defined in the form <code>fn void Foo.my_method(Foo* foo) { ... }</code>, they can be invoked using dot syntax.</li>
<li>Type methods may be attached to any type, even arrays and vectors.</li>
<li>Error handling using optional return types.</li>
</ol><h3 id="customizing-a-project-functions-changed">Changed</h3><ol>
<li>Function declarations use the <code>fn</code> prefix.</li>
</ol><h3 id="customizing-a-project-functions-removed">Removed</h3><ol>
<li>Functions with C-style varargs may be called, and declared as external functions, but not used for C3 functions.</li>
</ol><h2 id="customizing-a-project-attributes">Attributes</h2><p>C3 adds a long range of attributes in the form <code>@name(...)</code>. It is possible to create custom 
attribute groups using <code>def</code> (e.g. <code>def MyAttribute(usz align) = { @aligned(align) @weak };</code>) which
groups certain attributes. Empty attribute groups are permitted.</p><p>The complete list: <code>@align</code>, <code>@benchmark</code>, <code>@bigendian</code>, <code>@builtin</code>,
<code>@callconv</code>, <code>@deprecated</code>, <code>@dynamic</code>, <code>@export</code>,
<code>@extern</code>, <code>@if</code>, <code>@inline</code>, <code>@interface</code>,
<code>@littleendian</code>, <code>@local</code>, <code>@maydiscard</code>, <code>@naked</code>,
<code>@nodiscard</code>, <code>@noinit</code>, <code>@noreturn</code>, <code>@nostrip</code>,
<code>@obfuscate</code>, <code>@operator</code>, <code>@overlap</code>, <code>@priority</code>,
<code>@private</code>, <code>@public</code>, <code>@pure</code>, <code>@reflect</code>,
<code>@section</code>, <code>@test</code>, <code>@used</code>, <code>@unused</code>.</p><h2 id="customizing-a-project-declarations">Declarations</h2><h3 id="customizing-a-project-declarations-added">Added</h3><ol>
<li><code>var</code> declaration for type inferred variables in macros. E.g. <code>var a = some_value;</code></li>
<li><code>var</code> declaration for new type variables in macros. E.g. <code>var $Type = int;</code></li>
<li><code>var</code> declaration for compile time mutable variables in function and macros. E.g. <code>var $foo = 1;</code></li>
<li><code>const</code> declarations may be untyped. Such constants are not stored in the resulting binary.</li>
</ol><h3 id="customizing-a-project-declarations-changed">Changed</h3><ol>
<li><code>tlocal</code> declares a variable to be thread local.</li>
<li><code>static</code> top level declarations are replaced with <code>@local</code>. (<code>static</code> in functions is unchanged)</li>
</ol><h3 id="customizing-a-project-declarations-removed">Removed</h3><ol>
<li><code>restrict</code> removed.</li>
<li><code>atomic</code> should be replaced by atomic load/store operations.</li>
<li><code>volatile</code> should be replaced by volatile load/store operations.</li>
</ol><h2 id="customizing-a-project-statements">Statements</h2><h3 id="customizing-a-project-statements-added">Added</h3><ol>
<li>Match-style variant of the <code>switch</code> statement, allows each <code>case</code> to hold an expression to test.</li>
<li>Switching over type with <code>typeid</code>.</li>
<li>Unpack <code>any</code> to the underlying type with an <code>any</code>-switch.</li>
<li><code>nextcase</code> to fallthrough to the next case.</li>
<li><code>nextcase &lt;expr&gt;</code> to jump to the case with the expression value (this may be an expression evaluated at runtime).</li>
<li><code>nextcase default</code> to jump to the <code>default</code> clause.</li>
<li>Labelled <code>while</code>/<code>do</code>/<code>for</code>/<code>foreach</code> to use with <code>break</code> <code>nextcase</code> and <code>continue</code>.</li>
<li><code>foreach</code> to iterate over arrays, vectors, slices and user-defined containers using operator overloading.</li>
<li><code>foreach_r</code> to iterate in reverse.</li>
<li><code>foreach</code> / <code>foreach_r</code> may take the element by value or reference. The index may optionally be provided.</li>
<li><code>$if</code>, <code>$switch</code>, <code>$for</code>, <code>$foreach</code> statements executing at compile time.</li>
<li><code>$echo</code> printing a message at compile time.</li>
<li><code>$assert</code> compile time assert.</li>
<li><code>defer</code> statement to execute statements at scope exit.</li>
<li><code>defer catch</code> and <code>defer try</code> similar to <code>defer</code> but executes only on optional exit or regular exit of scope respectively.</li>
<li><code>do</code> statements may omit <code>while</code>, behaving same as <code>while (0)</code></li>
<li><code>if</code> may have a label. Labelled <code>if</code> may be exited using labelled break.</li>
<li><code>asm</code> blocks for inline assembly. </li>
<li>if-try statements allows you to run code where an expression is a result.</li>
<li>if-catch statements runs code on fault. It can be used to implicitly unwrap variables.</li>
<li>Exhaustive switching on enums.</li>
</ol><h3 id="customizing-a-project-statements-changed">Changed</h3><ol>
<li>Switch cases will have implicit break, rather than implicit fallthrough.</li>
<li><code>assert</code> is an actual statement and may take a string or a format + arguments.</li>
<li><code>static_assert</code> is <code>$assert</code> and is a statement.</li>
</ol><h3 id="customizing-a-project-statements-removed">Removed</h3><ol>
<li><code>goto</code> removed, replaced by labelled break, continue and nextcase.</li>
</ol><h2 id="customizing-a-project-compile-time-evaluation">Compile time evaluation</h2><h3 id="customizing-a-project-compile-time-evaluation-added">Added</h3><ol>
<li><code>@if(cond)</code> to conditionally include a struct/union field, a user-defined type etc.</li>
<li>Compile time variables with <code>$</code> prefix e.g. <code>$foo</code>.</li>
<li><code>$if...$else...$endif</code> and <code>$switch...$endswitch</code> inside of functions to conditionally include code.</li>
<li><code>$for</code> and <code>$foreach</code> to loop over compile time variables and data.</li>
<li><code>$typeof</code> determines an expression type without evaluating it.</li>
<li>Type properties may be accessed at compile time.</li>
<li><code>$define</code> returns true if the variable, function or type exists.</li>
<li><code>$error</code> emits an error if encountered.</li>
<li><code>$embed</code> includes a file as binary data.</li>
<li><code>$include</code> includes a file as text.</li>
<li><code>$exec</code> includes the output of a program as code.</li>
<li><code>$evaltype</code> takes a compile time string and turns it into a type.</li>
<li><code>$eval</code> takes a string and turns it into an identifier.</li>
<li><code>$extnameof</code> turns an identifier into its string external name.</li>
<li><code>$nameof</code> turns an identifier into its local string name.</li>
<li><code>$qnameof</code> turns an identifier into its local string name with the module prefixed.</li>
<li>Compile time constant values are always compile time folded for arithmetic operations and casts.</li>
<li><code>$$FUNCTION</code> returns the current function as an identifier.</li>
</ol><h3 id="customizing-a-project-compile-time-evaluation-changed">Changed</h3><ol>
<li><code>#define</code> for constants is replaced by untyped constants, e.g. <code>#define SOME_CONSTANT 1</code> becomes <code>const SOME_CONSTANT = 1;</code>.</li>
<li><code>#define</code> for variable and function aliases is replaced by <code>def</code>, e.g. <code>#define native_foo win32_foo</code> becomes <code>def native_foo = win32_foo;</code></li>
<li>In-function <code>#if...#else..#endif</code> is replaced by <code>$if</code>, <code>#if...#elif...#endif</code> is replaced by <code>$switch</code>.</li>
<li>For converting code into a string use <code>$stringify</code>.</li>
<li>Macros for date, line etc are replaced by <code>$$DATE</code>, <code>$$FILE</code>, <code>$$FILEPATH</code>, <code>$$FUNC</code>, <code>$$LINE</code>, <code>$$MODULE</code>, <code>$$TIME</code>.</li>
</ol><h3 id="customizing-a-project-compile-time-evaluation-removed">Removed</h3><ol>
<li>Top level <code>#if...#endif</code> does not have a counterpart. Use <code>@if</code> instead.</li>
<li>No <code>#include</code> directives, <code>$include</code> will include text but isn’t for the same use.</li>
</ol><h2 id="customizing-a-project-macros">Macros</h2><h3 id="customizing-a-project-macros-added">Added</h3><ol>
<li><code>macro</code> for defining macros.</li>
<li>“Function-like” macros have no prefix and has only regular parameters or type parameters.</li>
<li>“At”-macros are prefixed with <code>@</code> and may also have compile time values, expression and ref parameters, and may have a trailing body.</li>
<li>Type parameters have the prefix <code>$</code> and conform to the type naming standard (“$TypeFoo”).</li>
<li>“ref” parameters are declared using with a <code>&amp;</code> prefix operator. This is similar to C++ ref parameters.</li>
<li>Expression parameters are unevaluated expressions, this is similar to arguments to <code>#define</code>.</li>
<li>Compile time values have a <code>$</code> prefix and must contain compile time constant values.</li>
<li>Any macro that evaluates to a constant result can be used as if it was the resulting constant.</li>
<li>Macros may be recursively evaluated.</li>
<li>Macros are inlined at the location where they are invoked.</li>
<li>Unless resulting in a single constant, macros implicitly create a runtime scope.</li>
</ol><h3 id="customizing-a-project-macros-removed">Removed</h3><ol>
<li>No <code>#define</code> macros.  </li>
<li>Macros cannot be incomplete statements.</li>
</ol><h2 id="customizing-a-project-features-provided-by-builtins">Features provided by builtins</h2><p>Some features are provided by builtins, and appears as normal functions and macros in the standard library
but nonetheless provided unique functionality:</p><ol>
<li><code>@likely(...)</code> / <code>@unlikely(...)</code> on branches affects compilation optimization.</li>
<li><code>@anycast(...)</code> casts an <code>any</code> with an optional result.</li>
<li><code>unreachable(...)</code> marks a path as unreachable with a panic in safe mode.</li>
<li><code>unsupported(...)</code> similar to unreachable but for functionality not implemented.</li>
<li><code>@expect(...)</code> expect a certain value with an optional probability for the optimizer.</li>
<li><code>@prefetch(...)</code> prefect a pointer.</li>
<li><code>swizzle(...)</code> swizzles a vector.</li>
<li><code>@volatile_load(...)</code> and <code>@volatile_store(...)</code> volatile load/store.</li>
<li><code>@atomic_load(...)</code> and <code>@atomic_store(...)</code> atomic load/store.</li>
<li><code>compare_exchange(...)</code> atomic compare exchange.</li>
<li>Saturating add, sub, mul, shl on integers.</li>
<li>Vector reduce operations: add, mul, and, or, xor, max, min.</li>
</ol><h2 id="customizing-a-project-modules">Modules</h2><ol>
<li>Modules are defined using <code>module &lt;name&gt;</code>. Where name is on the form <code>foo::bar::baz</code></li>
<li>Modules can be split into an unlimited number of module sections, each starting with the same module name declaration.</li>
<li>The <code>import</code> statement imports a given module.</li>
<li>Each module section has its own set of import statements.</li>
<li>Importing a module gives access to the declarations that are <code>@public</code>.</li>
<li>Declarations are default <code>@public</code>, but a module section may set a different default (e.g. <code>module my_module @private;</code>)</li>
<li><code>@private</code> means the declaration is only visible in the module.</li>
<li><code>@local</code> means only visible to the current module section.</li>
<li>Imports are recursive. For example, <code>import my_lib</code> will implicitly also import <code>my_lib::net</code>.</li>
<li>Multiple imports may be specified with the same <code>import</code>, e.g. <code>import std::net, std::io;</code>.</li>
<li>Generic modules have a set of parameters after the module name <code>module arr(&lt;Type, LEN&gt;);</code></li>
<li>Generic modules are not type checked until any of its types, functions or globals are instantiated.</li>
</ol><h2 id="customizing-a-project-contracts">Contracts</h2><ol>
<li>Doc contracts (starting with <code>&lt;*</code>) are parsed.</li>
<li>The first part, up until the first <code>@</code> directive on a new line, is ignored.</li>
<li>The <code>@param</code> directive for pointer arguments may define usage constraints <code>[in]</code> <code>[out]</code> and <code>[inout]</code>.</li>
<li>Pointer argument constraints may add a <code>&amp;</code> prefix to indicate that they may not be <code>null</code>, e.g. <code>[&amp;inout]</code>.</li>
<li>Contracts may be attached to generic modules, functions and macros.</li>
<li><code>@require</code> directives are evaluated given the arguments provided. Failing them may be a compile time or runtime error.</li>
<li>The <code>@ensure</code> directive is evaluated at exit - if the return is a result and not an optional.</li>
<li><code>return</code> can be used as a variable identifier inside of <code>@ensure</code>, and holds the return value.</li>
<li><code>@return!</code> optionally lists the errors used. This will be checked at compile time.</li>
<li><code>@pure</code> says that no writing to globals is allowed inside and only <code>@pure</code> functions may be called.</li>
</ol><h2 id="customizing-a-project-benchmarking">Benchmarking</h2><ol>
<li>Benchmarks are indicated by <code>@benchmark</code>.</li>
<li>Marking a module section <code>@benchmark</code> makes all functions inside of it implicitly benchmarks.</li>
<li>Benchmarks are usually not compiled.</li>
<li>Benchmarks are instead only run by the compiler on request.</li>
</ol><h2 id="customizing-a-project-testing">Testing</h2><ol>
<li>Tests are indicated by <code>@test</code>.</li>
<li>Marking a module section <code>@test</code> makes all functions inside of it implicitly tests.</li>
<li>Tests are usually not compiled.</li>
<li>Tests are instead only run by the compiler on request.</li>
</ol><h2 id="customizing-a-project-safe-fast">Safe / fast</h2><p>Compilation has two modes: “safe” and “fast”. Safe will insert checks for out-of-bounds access, null-pointer deref,
shifting by negative numbers, division by zero, violation of contracts and asserts.</p><p>Fast will assume all of those checks can be assumed to always pass. This means that unexpected behaviour may result
from violating those checks. It is recommended to develop in “safe” mode.</p><p>If debug symbols are available, C3 will produce a stack trace in safe mode where an error occurs.</p><hr><p>title: Comparisons With Other Languages
description: How C3 compares to other languages
sidebar:</p><pre><code>order: 701</code></pre><hr><p>An important question to answer is “How does C3 compare to other similar programming languages?”.
Here is an extremely brief (and not yet complete) overview.</p><h2 id="customizing-a-project-c">C</h2><p>As C3 is an evolution of C, the languages are quite similar.
C3 adds features, but also removes a few.</p><h5>In C3 but not in C</h5><ul>
<li>Module system</li>
<li>Integrated build system</li>
<li>Generics</li>
<li>Semantic Macros</li>
<li>Error handling</li>
<li>Defer</li>
<li>Value methods</li>
<li>Associated enum data</li>
<li>Distinct types and subtypes</li>
<li>Optional contracts</li>
<li>Built-in slices</li>
<li>Foreach for iteration over arrays and types</li>
<li>Dynamic calls and types</li>
</ul><h5>In C but not in C3</h5><ul>
<li>Qualified types (<code>const</code>, <code>volatile</code> etc)</li>
<li>Unsafe implicit conversions</li>
</ul><h2 id="customizing-a-project-c">C++</h2><p>C++ is a complex object oriented “almost superset” of C. It tries to be everything to everyone,
while squeezing this into a C syntax. The language is well known for its
many pitfalls and quirky corners – as well as its long compile times.</p><p>C3 is in many ways different from C++ in the same way that C is different from C++,
but the semantic macro system and the generics close the gap in terms of writing
reusable generic code. The C3 module system and error handling is also very
different from how C++ does things.</p><h5>In C++ but not in C3</h5><ul>
<li>Objects and classes</li>
<li>RAII</li>
<li>Exceptions</li>
</ul><h5>In C3 but not in C++</h5><ul>
<li>Module system (yet)</li>
<li>Integrated build system</li>
<li>Semantic macros</li>
<li>Error handling</li>
<li>Defer</li>
<li>Associated enum data</li>
<li>Built-in slices</li>
<li>Dynamic calls</li>
</ul><h2 id="customizing-a-project-rust">Rust</h2><p>Rust is a safe systems programming language. While not quite as complex as C++,
it is still a feature rich programming language with semantic macros, traits and
pattern matching to mention a few.</p><p>Error handling is handled using <code>Result</code> and <code>Optional</code> which is similar to 
how C3 works.</p><p>C3 compares to Rust much like C, although the presence of built-in slices and 
strings reduces the places where C3 is unsafe. Rust provides arrays and strings,
but they are not built in.</p><h5>In Rust but not in C3</h5><ul>
<li>RAII</li>
<li>Memory safety</li>
<li>Safe union types with functions</li>
<li>Different syntax from C</li>
<li>Pattern matching</li>
<li>Async built in</li>
</ul><h5>In C3 but not in Rust</h5><ul>
<li>Same ease of programming as C</li>
<li>Optional contracts</li>
<li>Familiar C syntax and behaviour</li>
<li>Dynamic calls</li>
</ul><h2 id="customizing-a-project-zig">Zig</h2><p>Zig is a systems programming language with extensive compile time execution to
enable polymorphic functions and parameterized types. It aims to be a C replacement.</p><p>Compared to C3, Zig tries to be a completely new language in terms of syntax and feel.
C3 uses macros to a modest degree where it is more pervasive in Zig, and
does not depart from C to the same degree. Like Rust, it features slices as a first
class type. The standard library uses an explicit allocator to allow it to work
with many different allocation strategies.</p><p>Zig is a very ambitious project, aiming to support as many types of platforms as
possible.</p><h5>In Zig but not in C3</h5><ul>
<li>Pervasive compile time execution.</li>
<li>Memory allocation failure is an error.</li>
<li>Toolchain uses build files written in native Zig.</li>
<li>Different syntax and behaviour compared to C.</li>
<li>Structs define namespace.</li>
<li>Async primitives built in.</li>
<li>Arbitrary integer sizes.</li>
</ul><h5>In C3 but not in Zig</h5><ul>
<li>Module system.</li>
<li>Integrated build system.</li>
<li>C ABI compatibility by default.</li>
<li>Optional contracts.</li>
<li>Familiar C syntax and behaviour.</li>
<li>Dynamic interfaces.</li>
<li>Built in benchmarks.</li>
</ul><h2 id="customizing-a-project-jai">Jai</h2><p>Jai is a programming language aimed at high performance game programming.
It has an extensive compile time meta programming functionality, even
to the point of being able to run programs at compile time. It also
has compile-time polymorphism, a powerful macro system and uses 
an implicit context system to switch allocation schemes.</p><h5>In Jai but not in C3</h5><ul>
<li>Pervasive compile time execution.</li>
<li>Jai’s compile time execution is the build system.</li>
<li>Different syntax and behaviour compared to C.</li>
<li>More powerful macro system than C3.</li>
<li>Implicit constructors.</li>
</ul><h5>In C3 but not in Jai</h5><ul>
<li>Module system.</li>
<li>Integrated build system.</li>
<li>Optional contracts.</li>
<li>Familiar C syntax and behaviour.</li>
<li>Fairly small language.</li>
<li>Dynamic interfaces.</li>
</ul><h2 id="customizing-a-project-odin">Odin</h2><p>Odin is a language built for high performance but tries to remain
a simple language to learn. Superficially the syntax shares much with
Jai, and some of Jai’s features things – like an implicit context – also shows up
in Odin. In contrast with both Jai and Zig, Odin uses only minimal compile time evaluation
and instead only relies on parametric polymorphism to ensure reuse.
It also contains conveniences, like maps and arrays built into
the language. For error handling it relies on Go style tuple returns.</p><h5>In Odin but not in C3</h5><ul>
<li>Different syntax and behaviour compared to C.</li>
<li>Ad hoc parametric polymorphism.</li>
<li>Multiple return values.</li>
<li>Error handling through multiple returns.</li>
<li>A rich built in set of types.</li>
</ul><h5>In C3 but not in Odin</h5><ul>
<li>Familiar C syntax and behaviour.</li>
<li>Semantic macros.</li>
<li>Value methods.</li>
<li>Optional contracts.</li>
<li>Built in error handling.</li>
<li>Dynamic interfaces.</li>
</ul><h2 id="customizing-a-project-d">D</h2><p>D is an incredibly extensive language, it covers anything C++ does and adds much more.
D manages this with much fewer syntactic quirks than C++. It is a strong,
feature-rich language.</p><h5>In D but not in C3</h5><ul>
<li>Objects and classes.</li>
<li>RAII.</li>
<li>Exceptions.</li>
<li>Optional GC.</li>
</ul><p><em>+ Many, many more features.</em> </p><h5>In C3 but not in D</h5><ul>
<li>Fairly small language.</li>
</ul><hr><p>title: Changes From C
description: Changes From C
sidebar:</p><pre><code>order: 702</code></pre><hr><p>Although C3 is trying to improve on C, this does not only mean addition of features, but also removal, or breaking changes:</p><h5>No mandatory header files</h5><p>There is a C3 interchange header format for declaring interfaces of libraries, but it is only used for special applications.</p><h5>Removal of the old C macro system</h5><p>The old C macro system is replaced by a new C3 macro system.</p><h5>Import and modules</h5><p>C3 uses module imports instead of header includes to link modules together.</p><h5>Member access using <code>.</code> even for pointers</h5><p>The <code>-&gt;</code>
 operator is removed, access uses dot for both direct and pointer 
access. Note that this is just single access: to access a pointer of a 
pointer (e.g. <code>int**</code>) an explicit dereference would be needed.</p><h5>Different operator precedence</h5><p>Notably bit operations have higher precedence than +/-, making code like this: <code>a &amp; b == c</code> evaluate like <code>(a &amp; b) == c</code> instead of C’s <code>a &amp; (b == c)</code>. See the page about <a href="https://waveproc.github.io/language-rules/precedence/">precedence rules</a>.</p><h5>Removal of the const type qualifier</h5><p>The const qualifier is only retained for actual constant variables. C3 uses a special type of <a href="https://waveproc.github.io/language-common/contracts/">post condition</a> for functions to indicate that they do not alter in parameters.</p><pre><code class="lang-c3">&lt;*
 This function ensures that foo is not changed in the function.
 @param [in] foo
 @param [out] bar
*&gt;
fn void test(Foo* foo, Bar* bar)
{
    bar.y = foo.x;
    <span class="comment">// foo.x = foo.x + <span class="number">1</span> - compile time error, can<span class="string">'t write to '</span>in<span class="string">' param.</span>
    <span class="comment">// int x = bar.y     - compile time error, can'</span>t read from an <span class="string">'out'</span> param.</span>
}</code></pre><p><em>Rationale: const correctness requires littering 
const across the code base. Although const is useful, it provides weaker
 guarantees that it appears.</em></p><h5>Fixed arrays do not decay and have copy semantics</h5><p>C3
 has three different array types. Variable arrays and slices decay to 
pointers, but fixed arrays are value objects and do not decay.</p><pre><code class="lang-c3">int[<span class="number">3</span>] a = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> };
int[<span class="number">4</span>]* b = &amp;a; <span class="comment">// No conversion</span>
int* c = a; <span class="comment">// ERROR</span>
int* d = &amp;a; <span class="comment">// Valid implicit conversion</span>
int* e = b; <span class="comment">// Valid implicit conversion</span>
int[<span class="number">3</span>] f = a; <span class="comment">// Copy by value!</span></code></pre><h5>Removal of multiple declaration syntax with initialization</h5><p>Only a single declaration with initialization is allowed per statement in C3:</p><pre><code class="lang-c3">int i, j = <span class="number">1</span>; <span class="comment">// ERROR</span>
int a = <span class="number">1</span>;    <span class="comment">// Ok</span>
int b, c;     <span class="comment">// Ok</span></code></pre><p>In conditionals, a special form of multiple declarations are allowed but each must then provide its type:</p><pre><code class="lang-c3">for (int i = <span class="number">0</span>, int j = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++, j++) { ... }</code></pre><h5>Integer promotions rules and safe signed-unsigned comparisons</h5><p>Promotion rules for integer types are different from C. 
C3 allows implicit widening only
where there is only a single way to widen the expression. To explain the latter:
take the case of <code>long x = int_val_1 + int_val_2</code>. In C this would widen the result of the addition:
<code>long x = (long)(int_val_1 + int_val_2)</code>, but there is another possible 
way to widen: <code>long x = (long)int_val_1 + (long)int_val_2</code>. so in this case, the widening
is disallowed. However, <code>long x = int_val_1</code> is unambiguous, so C3 permits it just like C (read more on the <a href="https://waveproc.github.io/language-rules/conversion/">conversion page</a>. </p><p>C3 also adds <em>safe signed-unsigned comparisons</em>: this means that comparing signed and unsigned values will always yield the correct result:</p><pre><code class="lang-c3"><span class="comment">// The code below would print <span class="string">"Hello C<span class="number">3</span>!"</span> in C<span class="number">3</span> and <span class="string">"Hello C!"</span> in C.</span>
int i = -<span class="number">1</span>;
uint j = <span class="number">1</span>;
if (i &lt; j)
{
    printf(<span class="string">"Hello C<span class="number">3</span>!\n"</span>);
}
else
{
    printf(<span class="string">"Hello C!\n"</span>);
}</code></pre><h5>Goto removed</h5><p><code>goto</code> is removed and replaced with labelled <code>break</code> and <code>continue</code> together with the <code>nextcase</code> statement that allows you to jump between cases in a <code>switch</code> statement.</p><p><em>Rationale:
 It is very difficult to make goto work well with defer and implicit 
unwrapping of optional results. It is not just making the compiler 
harder to write, but
the code is harder to understand as well. The replacements together with
 <code>defer</code> cover many if not all usages of <code>goto</code> in regular code.</em></p><h5>Implicit break in switches</h5><p>Empty <code>case</code> statements have implicit fall through in C3, otherwise the <code>nextcase</code> statement is needed
<code>nextcase</code> can also be used to jump to any other case statement in the switch.</p><pre><code class="lang-c3">switch (h)
{
    case <span class="number">1</span>:
        a = <span class="number">1</span>;
        nextcase; <span class="comment">// Fall through</span>
    case <span class="number">2</span>:
        b = <span class="number">123</span>;
    case <span class="number">3</span>:
        a = <span class="number">2</span>;
        nextcase <span class="number">2</span>; <span class="comment">// Jump to case <span class="number">2</span></span>
    default:
        a = <span class="number">111</span>;
}</code></pre><h5>Locals variables are implicitly zeroed</h5><p>In C global variables are implicitly zeroed out, but local variables aren’t. 
In C3 local variables are zeroed out by default, but may be <em>explicitly</em> undefined 
(using the <code>@noinit</code> attribute) if you wish to match the C behaviour.</p><h6>Rationale for this change</h6><ul>
<li>In the “zero-is-initialization” paradigm, zeroing variables, in particular structs, 
is very common. By offering zero initialization by default this <strong>avoids a whole class of vulnerabilities</strong>.</li>
<li>Another alternative that was considered for C3 was mandatory initialization,
but this adds a lot of extra boilerplate. </li>
<li>C3 also offers a way to opt out of zero-initialization, so the change comes at no performance loss.</li>
</ul><h5>Compound literal syntax changed</h5><pre><code class="lang-c"><span class="comment">// C style:</span>
call_foo((Foo) { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });

<span class="comment">// C++ style (<span class="number">1</span>):</span>
call_foo(Foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));

<span class="comment">// C++ style (<span class="number">2</span>):</span>
call_foo(Foo { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });

<span class="comment">// C<span class="number">3</span>:</span>
call_foo(Foo { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> } );

<span class="comment">// C<span class="number">3</span> with inference:</span>
call_foo({ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> });</code></pre><h5>Bitfields replaced by bitstructs</h5><p>Bitfields are replaced by bitstructs that have a well-defined encapsulating type, and 
an exact bit layout.</p><pre><code class="lang-c"><span class="comment">// C</span>
struct Foo
{
    int a : <span class="number">3</span>;
    unsigned b : <span class="number">4</span>;
    MyEnum c : <span class="number">7</span>;
};

struct Flags
{
    bool has_hyperdrive : <span class="number">1</span>;
    bool has_tractorbeam : <span class="number">1</span>;
    bool has_plasmatorpedoes : <span class="number">1</span>;
}    

<span class="comment">// C<span class="number">3</span></span>
bitstruct Foo : short
{  
    int a : <span class="number">0</span>..<span class="number">2</span>;
    uint b : <span class="number">3</span>..<span class="number">6</span>;
    MyEnum c : <span class="number">7</span>..<span class="number">13</span>;
}

<span class="comment">// Simple form, only allowed when all fields are bools.</span>
struct Flags : char
{
    bool has_hyperdrive;
    bool has_tractorbeam;
    bool has_plasmatorpedoes;
}</code></pre><h5>Evaluation order is well-defined</h5><p>Evaluation order is left-to-right, and in assignment expressions, assignment
happens after expression evaluation.</p><h5>Signed overflow is well-defined</h5><p>Signed integer overflow always wraps using 2s complement. It is never undefined behaviour.</p><h5>Octal removed</h5><p>The old <code>0777</code> octal syntax is removed and replaced by a <code>0o</code> prefix, e.g. <code>0o777</code>. Strings do not support octal sequences aside
from <code>'\0'</code>.</p><hr><p>title: Rejected Ideas
description: Rejected Ideas
sidebar:</p><pre><code>order: 703</code></pre><hr><p>These are ideas that will not be implemented in C3 with rationale given.</p><h3 id="customizing-a-project-d-constructors-and-destructors">Constructors and destructors</h3><p>A
 fundamental concept in C3 is that data is not “active”. This is to say 
there is no code associated with the data implicitly unlike constructors
 and destructors in an object oriented language. Not having constructors
 / destructors prevents RAII-style resource handling, but also allows 
the code to assume the memory can be freely allocated and initialized as
 it sees fit, without causing any corruption or undefined behaviour.</p><p>There
 is a fundamental difference between active objects and inert data, each
 has its advantages and disadvantages. C3 follows the C model, which is 
that data is passive and does not enforce any behaviour. This has very 
deep implications on the semantics of the language and adding 
constructors and destructors would change the language greatly, 
requiring modification of many parts of the language altering.</p><p>For that reason constructors and destructors will not be considered for C3.</p><h3 id="customizing-a-project-d-unicode-identifiers">Unicode identifiers</h3><p>The
 main argument for unicode identifiers is that “it allows people to code
 in their own language”. However, there is no proof that this actually 
is used in practice. Furthermore there are practical issues, such as 
bidirectional text, characters with different code points that are 
rendered in an identical way etc.</p><p>Given the complexity and the lack of actual proven benefit, unicode identifiers will not happen for C3.</p><hr><p>title: Grammar
description: Grammar
sidebar:</p><pre><code>order: 999</code></pre><hr><h2 id="customizing-a-project-keywords">Keywords</h2><p>The following are reserved keywords used by C3:</p><pre><code>void        bool        char        double
float       float16     int128      ichar
int         iptr        isz         long
short       uint128     uint        ulong
uptr        ushort      usz         float128
any         anyfault    typeid      assert
asm         bitstruct   break       case
catch       const       continue    def
default     defer       distinct    do
else        enum        extern      false
fault       for         foreach     foreach_r
fn          tlocal      if          inline
import      macro       module      nextcase
null        return      static      struct
switch      true        try         union
var         while</code></pre><pre><code>$alignof    $assert     $case       $default    
$defined    $echo       $embed      $exec
$else       $endfor     $endforeach $endif      
$endswitch  $eval       $evaltype   $error      
$extnameof  $for        $foreach    $if         
$include    $nameof     $offsetof   $qnameof    
$sizeof     $stringify  $switch     $typefrom   
$typeof     $vacount    $vatype     $vaconst    
$varef      $vaarg      $vaexpr     $vasplat</code></pre><p>The following attributes are built in:</p><pre><code>@align        @benchmark  @bigendian  @builtin
@cdecl        @deprecated @dynamic    @export
@extern       @extname    @inline     @interface
@littleendian @local      @maydiscard @naked
@nodiscard    @noinit     @noinline   @noreturn
@nostrip      @obfuscate  @operator   @overlap
@packed       @priority   @private    @public
@pure         @reflect    @section    @stdcall
@test         @unused     @used       @veccall
@wasm         @weak       @winmain</code></pre><p>The following constants are defined:</p><pre><code>$$BENCHMARK_FNS  $$BENCHMARK_NAMES $$DATE
$$FILE           $$FILEPATH        $$FUNC
$$FUNCTION       $$LINE            $$LINE_RAW
$$MODULE         $$TEST_FNS        $$TEST_NAMES
$$TIME</code></pre><h2 id="customizing-a-project-yacc-grammar">Yacc grammar</h2><pre><code class="lang-c">%{

<span class="comment">#include &lt;stdio.h&gt;</span>
<span class="comment">#define YYERROR_VERBOSE</span>
int yydebug = <span class="number">1</span>;
extern char yytext[];
extern int column;
int yylex(void);
void yyerror(char *s);
%}

%token IDENT HASH_IDENT CT_IDENT CONST_IDENT
%token TYPE_IDENT CT_TYPE_IDENT
%token AT_TYPE_IDENT AT_IDENT CT_INCLUDE
%token STRING_LITERAL INTEGER
%token INC_OP DEC_OP SHL_OP SHR_OP LE_OP GE_OP EQ_OP NE_OP
%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN
%token SUB_ASSIGN SHL_ASSIGN SHR_ASSIGN AND_ASSIGN
%token XOR_ASSIGN OR_ASSIGN VAR NUL ELVIS NEXTCASE ANYFAULT
%token MODULE IMPORT DEF EXTERN
%token CHAR SHORT INT LONG FLOAT DOUBLE CONST VOID USZ ISZ UPTR IPTR ANY
%token ICHAR USHORT UINT ULONG BOOL INT<span class="number">128</span> UINT<span class="number">128</span> FLOAT<span class="number">16</span> FLOAT<span class="number">128</span> BFLOAT<span class="number">16</span>
%token TYPEID BITSTRUCT STATIC BANGBANG AT_CONST_IDENT HASH_TYPE_IDENT
%token STRUCT UNION ENUM ELLIPSIS DOTDOT BYTES

%token CT_ERROR
%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR CONTINUE BREAK RETURN FOREACH_R FOREACH
%token FN FAULT MACRO CT_IF CT_ENDIF CT_ELSE CT_SWITCH CT_CASE CT_DEFAULT CT_FOR CT_FOREACH CT_ENDFOREACH
%token CT_ENDFOR CT_ENDSWITCH BUILTIN IMPLIES INITIALIZE FINALIZE CT_ECHO CT_ASSERT CT_EVALTYPE CT_VATYPE
%token TRY CATCH SCOPE DEFER LVEC RVEC OPTELSE CT_TYPEFROM CT_TYPEOF TLOCAL
%token CT_VASPLAT INLINE DISTINCT CT_VACONST CT_NAMEOF CT_VAREF CT_VACOUNT CT_VAARG
%token CT_SIZEOF CT_STRINGIFY CT_QNAMEOF CT_OFFSETOF CT_VAEXPR
%token CT_EXTNAMEOF CT_EVAL CT_DEFINED CT_CHECKS CT_ALIGNOF ASSERT
%token ASM CHAR_LITERAL REAL TRUE FALSE CT_CONST_IDENT
%token LBRAPIPE RBRAPIPE HASH_CONST_IDENT

%start translation_unit
%%

path
        : IDENT SCOPE
        | path IDENT SCOPE
        ;

path_const
    : path CONST_IDENT
    | CONST_IDENT
    ;

path_ident
    : path IDENT
    | IDENT
    ;

path_at_ident
    : path AT_IDENT
    | AT_IDENT
    ;

ident_expr
    : CONST_IDENT
    | IDENT
    | AT_IDENT
    ;

local_ident_expr
    : CT_IDENT
        | HASH_IDENT
    ;

ct_call
    : CT_ALIGNOF
    | CT_DEFINED
    | CT_EXTNAMEOF
    | CT_NAMEOF
    | CT_OFFSETOF
    | CT_QNAMEOF
    ;

ct_analyse
    : CT_EVAL
    | CT_SIZEOF
    | CT_STRINGIFY
    ;

ct_arg
    : CT_VACONST
        | CT_VAARG
        | CT_VAREF
        | CT_VAEXPR
    ;

flat_path
    : primary_expr param_path
    | type
    | primary_expr
    ;

maybe_optional_type
    : optional_type
    | empty
    ;

string_expr
    : STRING_LITERAL
    | string_expr STRING_LITERAL
    ;

bytes_expr
    : BYTES
    | bytes_expr BYTES
    ;

expr_block
    : LBRAPIPE opt_stmt_list RBRAPIPE
    ;

base_expr
    : string_expr
    | INTEGER
    | bytes_expr
    | NUL
    | BUILTIN CONST_IDENT
    | BUILTIN IDENT
    | CHAR_LITERAL
    | REAL
    | TRUE
    | FALSE
    | path ident_expr
    | ident_expr
    | local_ident_expr
    | type initializer_list
    | type <span class="string">'.'</span> access_ident
    | type <span class="string">'.'</span> CONST_IDENT
    | <span class="string">'('</span> expr <span class="string">')'</span>
    | expr_block
    | ct_call <span class="string">'('</span> flat_path <span class="string">')'</span>
    | ct_arg <span class="string">'('</span> expr <span class="string">')'</span>
    | ct_analyse <span class="string">'('</span> expr <span class="string">')'</span>
    | CT_VACOUNT
    | CT_CHECKS <span class="string">'('</span> expression_list <span class="string">')'</span>
    | lambda_decl compound_statement
    ;

primary_expr
    : base_expr
    | initializer_list
    ;

range_loc
    : expr
    | <span class="string">'^'</span> expr
    ;

range_expr
    : range_loc DOTDOT range_loc
    | range_loc DOTDOT
    | DOTDOT range_loc
    | range_loc <span class="string">':'</span> range_loc
    | <span class="string">':'</span> range_loc
    | range_loc <span class="string">':'</span>
    | DOTDOT
    ;


call_inline_attributes
    : AT_IDENT
    | call_inline_attributes AT_IDENT
    ;

call_invocation
    : <span class="string">'('</span> call_arg_list <span class="string">')'</span>
    | <span class="string">'('</span> call_arg_list <span class="string">')'</span> call_inline_attributes
    ;

access_ident
    : IDENT
    | AT_IDENT
    | HASH_IDENT
    | CT_EVAL <span class="string">'('</span> expr <span class="string">')'</span>
    | TYPEID
    ;

call_trailing
    : <span class="string">'['</span> range_loc <span class="string">']'</span>
    | <span class="string">'['</span> range_expr <span class="string">']'</span>
    | call_invocation
    | call_invocation compound_statement
    | <span class="string">'.'</span> access_ident
    | INC_OP
    | DEC_OP
    | <span class="string">'!'</span>
    | BANGBANG
    ;

call_stmt_expr
    : base_expr
    | call_stmt_expr call_trailing
    ;

call_expr
    : primary_expr
    | call_expr call_trailing
    ;

unary_expr
    : call_expr
    | unary_op unary_expr
    ;

unary_stmt_expr
    : call_stmt_expr
    | unary_op unary_expr
    ;

unary_op
    : <span class="string">'&amp;'</span>
    | AND_OP
    | <span class="string">'*'</span>
    | <span class="string">'+'</span>
    | <span class="string">'-'</span>
    | <span class="string">'~'</span>
    | <span class="string">'!'</span>
    | INC_OP
    | DEC_OP
    | <span class="string">'('</span> type <span class="string">')'</span>
    ;

mult_op
    : <span class="string">'*'</span>
    | <span class="string">'/'</span>
    | <span class="string">'%'</span>
        ;

mult_expr
    : unary_expr
    | mult_expr mult_op unary_expr
    ;

mult_stmt_expr
    : unary_stmt_expr
    | mult_stmt_expr mult_op unary_expr
    ;

shift_op
    : SHL_OP
    | SHR_OP
    ;

shift_expr
    : mult_expr
    | shift_expr shift_op mult_expr
    ;

shift_stmt_expr
    : mult_stmt_expr
    | shift_stmt_expr shift_op mult_expr
    ;


bit_op
        : <span class="string">'&amp;'</span>
        | <span class="string">'^'</span>
        | <span class="string">'|'</span>
        ;

bit_expr
    : shift_expr
    | bit_expr bit_op shift_expr
    ;

bit_stmt_expr
    : shift_stmt_expr
    | bit_stmt_expr bit_op shift_expr
    ;

additive_op
    : <span class="string">'+'</span>
    | <span class="string">'-'</span>
        ;

additive_expr
    : bit_expr
    | additive_expr additive_op bit_expr
    ;

additive_stmt_expr
    : bit_stmt_expr
    | additive_stmt_expr additive_op bit_expr
    ;

relational_op
    : <span class="string">'&lt;'</span>
    | <span class="string">'&gt;'</span>
    | LE_OP
    | GE_OP
    | EQ_OP
    | NE_OP
    ;

relational_expr
    : additive_expr
    | relational_expr relational_op additive_expr
    ;

relational_stmt_expr
    : additive_stmt_expr
    | relational_stmt_expr relational_op additive_expr
    ;

rel_or_lambda_expr
    : relational_expr
    | lambda_decl IMPLIES relational_expr
    ;

and_expr
    : relational_expr
    | and_expr AND_OP relational_expr
    ;

and_stmt_expr
    : relational_stmt_expr
    | and_stmt_expr AND_OP relational_expr
    ;

or_expr
    : and_expr
    | or_expr OR_OP and_expr
    ;

or_stmt_expr
    : and_stmt_expr
    | or_stmt_expr OR_OP and_expr
    ;

or_expr_with_suffix
    : or_expr
    | or_expr <span class="string">'?'</span>
    | or_expr <span class="string">'?'</span> <span class="string">'!'</span>
    ;

or_stmt_expr_with_suffix
    : or_stmt_expr
    | or_stmt_expr <span class="string">'?'</span>
    | or_stmt_expr <span class="string">'?'</span> <span class="string">'!'</span>
    ;

ternary_expr
    : or_expr_with_suffix
    | or_expr <span class="string">'?'</span> expr <span class="string">':'</span> ternary_expr
    | or_expr_with_suffix ELVIS ternary_expr
    | or_expr_with_suffix OPTELSE ternary_expr
    | lambda_decl implies_body
    ;

ternary_stmt_expr
    : or_stmt_expr_with_suffix
    | or_stmt_expr <span class="string">'?'</span> expr <span class="string">':'</span> ternary_expr
    | or_stmt_expr_with_suffix ELVIS ternary_expr
    | or_stmt_expr_with_suffix OPTELSE ternary_expr
    | lambda_decl implies_body
    ;

assignment_op
    : <span class="string">'='</span>
    | ADD_ASSIGN
    | SUB_ASSIGN
    | MUL_ASSIGN
    | DIV_ASSIGN
    | MOD_ASSIGN
    | SHL_ASSIGN
    | SHR_ASSIGN
    | AND_ASSIGN
    | XOR_ASSIGN
    | OR_ASSIGN
    ;

empty
    :
    ;

assignment_expr
        : ternary_expr
        | CT_TYPE_IDENT <span class="string">'='</span> type
        | unary_expr assignment_op assignment_expr
        ;
assignment_stmt_expr
        : ternary_stmt_expr
        | CT_TYPE_IDENT <span class="string">'='</span> type
        | unary_stmt_expr assignment_op assignment_expr
        ;

implies_body
    : IMPLIES expr
    ;

lambda_decl
    : FN maybe_optional_type fn_parameter_list opt_attributes
    ;

expr_no_list
    : assignment_stmt_expr
    ;

expr
    : assignment_expr
    ;


constant_expr
    : ternary_expr
    ;

param_path_element
    : <span class="string">'['</span> expr <span class="string">']'</span>
    | <span class="string">'['</span> expr DOTDOT expr <span class="string">']'</span>
    | <span class="string">'.'</span> IDENT
    ;

param_path
    : param_path_element
    | param_path param_path_element
    ;

arg    : param_path <span class="string">'='</span> expr
    | type
    | param_path <span class="string">'='</span> type
    | expr
    | CT_VASPLAT <span class="string">'('</span> range_expr <span class="string">')'</span>
    | CT_VASPLAT <span class="string">'('</span> <span class="string">')'</span>
    | ELLIPSIS expr
    ;

arg_list
    : arg
    | arg_list <span class="string">','</span> arg
    ;

call_arg_list
    : arg_list
    | arg_list <span class="string">';'</span>
    | arg_list <span class="string">';'</span> parameters
    | <span class="string">';'</span>
    | <span class="string">';'</span> parameters
    | empty
    ;

opt_arg_list_trailing
    : arg_list
    | arg_list <span class="string">','</span>
    | empty
    ;

enum_constants
    : enum_constant
    | enum_constants <span class="string">','</span> enum_constant
    ;

enum_list
    : enum_constants
    | enum_constants <span class="string">','</span>
    ;

enum_constant
    : CONST_IDENT
    | CONST_IDENT <span class="string">'('</span> arg_list <span class="string">')'</span>
    | CONST_IDENT <span class="string">'('</span> arg_list <span class="string">','</span> <span class="string">')'</span>
    ;

identifier_list
    : IDENT
    | identifier_list <span class="string">','</span> IDENT
    ;

enum_param_decl
    : type
    | type IDENT
    | type IDENT <span class="string">'='</span> expr
    ;

base_type
    : VOID
    | BOOL
    | CHAR
    | ICHAR
    | SHORT
    | USHORT
    | INT
    | UINT
    | LONG
    | ULONG
    | INT<span class="number">128</span>
    | UINT<span class="number">128</span>
    | FLOAT
    | DOUBLE
    | FLOAT<span class="number">16</span>
    | BFLOAT<span class="number">16</span>
    | FLOAT<span class="number">128</span>
    | IPTR
    | UPTR
    | ISZ
    | USZ
    | ANYFAULT
    | ANY
    | TYPEID
    | TYPE_IDENT
    | path TYPE_IDENT
    | CT_TYPE_IDENT
    | CT_TYPEOF <span class="string">'('</span> expr <span class="string">')'</span>
    | CT_TYPEFROM <span class="string">'('</span> constant_expr <span class="string">')'</span>
    | CT_VATYPE <span class="string">'('</span> constant_expr <span class="string">')'</span>
    | CT_EVALTYPE <span class="string">'('</span> constant_expr <span class="string">')'</span>
    ;

type
    : base_type
    | type <span class="string">'*'</span>
    | type <span class="string">'['</span> constant_expr <span class="string">']'</span>
    | type <span class="string">'['</span> <span class="string">']'</span>
    | type <span class="string">'['</span> <span class="string">'*'</span> <span class="string">']'</span>
    | type LVEC constant_expr RVEC
    | type LVEC <span class="string">'*'</span> RVEC
    ;

optional_type
    : type
    | type <span class="string">'!'</span>
    ;

local_decl_after_type
    : CT_IDENT
    | CT_IDENT <span class="string">'='</span> constant_expr
    | IDENT opt_attributes
    | IDENT opt_attributes <span class="string">'='</span> expr
    ;

local_decl_storage
    : STATIC
    | TLOCAL
    ;

decl_or_expr
    : var_decl
    | optional_type local_decl_after_type
    | expr
    ;

var_decl
    : VAR IDENT <span class="string">'='</span> expr
    | VAR CT_IDENT <span class="string">'='</span> expr
    | VAR CT_IDENT
    | VAR CT_TYPE_IDENT <span class="string">'='</span> type
    | VAR CT_TYPE_IDENT
    ;

initializer_list
    : <span class="string">'{'</span> opt_arg_list_trailing <span class="string">'}'</span>
    ;

ct_case_stmt
        : CT_CASE constant_expr <span class="string">':'</span> opt_stmt_list
        | CT_CASE type <span class="string">':'</span> opt_stmt_list
        | CT_DEFAULT <span class="string">':'</span> opt_stmt_list
        ;

ct_switch_body
    : ct_case_stmt
        | ct_switch_body ct_case_stmt
        ;

ct_for_stmt
        : CT_FOR <span class="string">'('</span> for_cond <span class="string">')'</span> opt_stmt_list CT_ENDFOR
    ;

ct_foreach_stmt
    : CT_FOREACH <span class="string">'('</span> CT_IDENT <span class="string">':'</span> expr <span class="string">')'</span> opt_stmt_list CT_ENDFOREACH
    | CT_FOREACH <span class="string">'('</span> CT_IDENT <span class="string">','</span> CT_IDENT <span class="string">':'</span> expr <span class="string">')'</span> opt_stmt_list CT_ENDFOREACH
    ;
ct_switch
        : CT_SWITCH <span class="string">'('</span> constant_expr <span class="string">')'</span>
        | CT_SWITCH <span class="string">'('</span> type <span class="string">')'</span>
        | CT_SWITCH
       ;

ct_switch_stmt
    : ct_switch ct_switch_body CT_ENDSWITCH
    ;

var_stmt
    : var_decl <span class="string">';'</span>

decl_stmt_after_type
    : local_decl_after_type
    | decl_stmt_after_type <span class="string">','</span> local_decl_after_type
    ;

declaration_stmt
    : const_declaration
    | local_decl_storage optional_type decl_stmt_after_type <span class="string">';'</span>
    | optional_type decl_stmt_after_type <span class="string">';'</span>
    ;

return_stmt
    : RETURN expr <span class="string">';'</span>
    | RETURN <span class="string">';'</span>
    ;

catch_unwrap_list
    : relational_expr
    | catch_unwrap_list <span class="string">','</span> relational_expr
    ;

catch_unwrap
    : CATCH catch_unwrap_list
    | CATCH IDENT <span class="string">'='</span> catch_unwrap_list
    | CATCH type IDENT <span class="string">'='</span> catch_unwrap_list
    ;

try_unwrap
    : TRY rel_or_lambda_expr
    | TRY IDENT <span class="string">'='</span> rel_or_lambda_expr
    | TRY type IDENT <span class="string">'='</span> rel_or_lambda_expr
    ;

try_unwrap_chain
    : try_unwrap
    | try_unwrap_chain AND_OP try_unwrap
    | try_unwrap_chain AND_OP rel_or_lambda_expr
    ;

default_stmt
    : DEFAULT <span class="string">':'</span> opt_stmt_list
    ;

case_stmt
    : CASE expr <span class="string">':'</span> opt_stmt_list
    | CASE expr DOTDOT expr <span class="string">':'</span> opt_stmt_list
    | CASE type <span class="string">':'</span> opt_stmt_list
    ;

switch_body
    : case_stmt
    | default_stmt
    | switch_body case_stmt
    | switch_body default_stmt
    ;

cond_repeat
    : decl_or_expr
    | cond_repeat <span class="string">','</span> decl_or_expr
    ;

cond
    : try_unwrap_chain
    | catch_unwrap
    | cond_repeat
    | cond_repeat <span class="string">','</span> try_unwrap_chain
    | cond_repeat <span class="string">','</span> catch_unwrap
    ;

else_part
    : ELSE if_stmt
    | ELSE compound_statement
    ;

if_stmt
    : IF optional_label paren_cond <span class="string">'{'</span> switch_body <span class="string">'}'</span>
    | IF optional_label paren_cond <span class="string">'{'</span> switch_body <span class="string">'}'</span> else_part
    | IF optional_label paren_cond statement
    | IF optional_label paren_cond compound_statement else_part
    ;

expr_list_eos
    : expression_list <span class="string">';'</span>
    | <span class="string">';'</span>
    ;

cond_eos
    : cond <span class="string">';'</span>
    | <span class="string">';'</span>
    ;

for_cond
    : expr_list_eos cond_eos expression_list
    | expr_list_eos cond_eos
    ;

for_stmt
    : FOR optional_label <span class="string">'('</span> for_cond <span class="string">')'</span> statement
    ;

paren_cond
    : <span class="string">'('</span> cond <span class="string">')'</span>
    ;

while_stmt
    : WHILE optional_label paren_cond statement
    ;

do_stmt
    : DO optional_label compound_statement WHILE <span class="string">'('</span> expr <span class="string">')'</span> <span class="string">';'</span>
    | DO optional_label compound_statement <span class="string">';'</span>
    ;

optional_label_target
    : CONST_IDENT
    | empty
    ;

continue_stmt
    : CONTINUE optional_label_target <span class="string">';'</span>
    ;

break_stmt
    : BREAK optional_label_target <span class="string">';'</span>
    ;

nextcase_stmt
    : NEXTCASE CONST_IDENT <span class="string">':'</span> expr <span class="string">';'</span>
    | NEXTCASE expr <span class="string">';'</span>
    | NEXTCASE CONST_IDENT <span class="string">':'</span> type <span class="string">';'</span>
    | NEXTCASE type <span class="string">';'</span>
    | NEXTCASE <span class="string">';'</span>
    ;

foreach_var
    : optional_type <span class="string">'&amp;'</span> IDENT
    | optional_type IDENT
    | <span class="string">'&amp;'</span> IDENT
    | IDENT
    ;

foreach_vars
    : foreach_var
    | foreach_var <span class="string">','</span> foreach_var
    ;

foreach_stmt
    : FOREACH optional_label <span class="string">'('</span> foreach_vars <span class="string">':'</span> expr <span class="string">')'</span> statement
    : FOREACH_R optional_label <span class="string">'('</span> foreach_vars <span class="string">':'</span> expr <span class="string">')'</span> statement
    ;

defer_stmt
    : DEFER statement
    | DEFER TRY statement
    | DEFER CATCH statement
    ;

ct_if_stmt
    : CT_IF constant_expr <span class="string">':'</span> opt_stmt_list CT_ENDIF
    | CT_IF constant_expr <span class="string">':'</span> opt_stmt_list CT_ELSE opt_stmt_list CT_ENDIF
    ;

assert_expr
    : try_unwrap_chain
    | expr
    ;

assert_stmt
    : ASSERT <span class="string">'('</span> assert_expr <span class="string">')'</span> <span class="string">';'</span>
    | ASSERT <span class="string">'('</span> assert_expr <span class="string">','</span> expr <span class="string">')'</span> <span class="string">';'</span>
    ;

asm_stmts
    : asm_stmt
    | asm_stmts asm_stmt
    ;

asm_instr
    : INT
    | IDENT
    | INT <span class="string">'.'</span> IDENT
    | IDENT <span class="string">'.'</span> IDENT
    ;

asm_addr
    : asm_expr
    | asm_expr additive_op asm_expr
    | asm_expr additive_op asm_expr <span class="string">'*'</span> INTEGER
    | asm_expr additive_op asm_expr <span class="string">'*'</span> INTEGER additive_op INTEGER
    | asm_expr additive_op asm_expr shift_op INTEGER
    | asm_expr additive_op asm_expr additive_op INTEGER
    ;

asm_expr
    : CT_IDENT
    | CT_CONST_IDENT
    | IDENT
    | <span class="string">'&amp;'</span> IDENT
    | CONST_IDENT
    | REAL
    | INTEGER
    | <span class="string">'('</span> expr <span class="string">')'</span>
    | <span class="string">'['</span> asm_addr <span class="string">']'</span>

asm_exprs
    : asm_expr
    | asm_exprs <span class="string">','</span> asm_expr
    ;

asm_stmt
    : asm_instr asm_exprs <span class="string">';'</span>
    | asm_instr <span class="string">';'</span>
    ;

asm_block_stmt
    : ASM <span class="string">'('</span> expr <span class="string">')'</span>
    | ASM <span class="string">'{'</span> asm_stmts <span class="string">'}'</span>
    | ASM <span class="string">'{'</span> <span class="string">'}'</span>
    ;


/* Order here matches compiler */
statement
    : compound_statement
    | var_stmt
    | declaration_stmt
    | return_stmt
    | if_stmt
    | while_stmt
    | defer_stmt
    | switch_stmt
    | do_stmt
    | for_stmt
    | foreach_stmt
    | continue_stmt
    | break_stmt
    | nextcase_stmt
    | asm_block_stmt
        | ct_echo_stmt
    | ct_assert_stmt
        | ct_if_stmt
        | ct_switch_stmt
        | ct_foreach_stmt
        | ct_for_stmt
        | expr_no_list <span class="string">';'</span>
        | assert_stmt
        | <span class="string">';'</span>
    ;

compound_statement
    : <span class="string">'{'</span> opt_stmt_list <span class="string">'}'</span>
    ;

statement_list
    : statement
    | statement_list statement
    ;

opt_stmt_list
    : statement_list
    | empty
    ;

switch_stmt
    : SWITCH optional_label <span class="string">'{'</span> switch_body <span class="string">'}'</span>
    | SWITCH optional_label <span class="string">'{'</span> <span class="string">'}'</span>
    | SWITCH optional_label paren_cond <span class="string">'{'</span> switch_body <span class="string">'}'</span>
    | SWITCH optional_label paren_cond <span class="string">'{'</span> <span class="string">'}'</span>
    ;

expression_list
        : decl_or_expr
        | expression_list <span class="string">','</span> decl_or_expr
        ;

optional_label
    : CONST_IDENT <span class="string">':'</span>
    | empty
    ;

ct_assert_stmt
    : CT_ASSERT constant_expr <span class="string">':'</span> constant_expr <span class="string">';'</span>
    | CT_ASSERT constant_expr <span class="string">';'</span>
    | CT_ERROR constant_expr <span class="string">';'</span>
    ;

ct_include_stmt
    : CT_INCLUDE string_expr <span class="string">';'</span>
    ;

ct_echo_stmt
    : CT_ECHO constant_expr <span class="string">';'</span>

bitstruct_declaration
    : BITSTRUCT TYPE_IDENT <span class="string">':'</span> type opt_attributes bitstruct_body

bitstruct_body
    : <span class="string">'{'</span> <span class="string">'}'</span>
    | <span class="string">'{'</span> bitstruct_defs <span class="string">'}'</span>
    | <span class="string">'{'</span> bitstruct_simple_defs <span class="string">'}'</span>
    ;

bitstruct_defs
    : bitstruct_def
    | bitstruct_defs bitstruct_def
    ;

bitstruct_simple_defs
    : base_type IDENT <span class="string">';'</span>
    | bitstruct_simple_defs base_type IDENT <span class="string">';'</span>
    ;

bitstruct_def
    : base_type IDENT <span class="string">':'</span> constant_expr DOTDOT constant_expr <span class="string">';'</span>
    | base_type IDENT <span class="string">':'</span> constant_expr <span class="string">';'</span>
    ;

static_declaration
    : STATIC INITIALIZE opt_attributes compound_statement
    | STATIC FINALIZE opt_attributes compound_statement
    ;

attribute_name
    : AT_IDENT
    | AT_TYPE_IDENT
    | path AT_TYPE_IDENT
    ;

attribute_operator_expr
    : <span class="string">'&amp;'</span> <span class="string">'['</span> <span class="string">']'</span>
    | <span class="string">'['</span> <span class="string">']'</span> <span class="string">'='</span>
    | <span class="string">'['</span> <span class="string">']'</span>
    ;

attr_param
    : attribute_operator_expr
    | constant_expr
    ;

attribute_param_list
    : attr_param
    | attribute_param_list <span class="string">','</span> attr_param
    ;

attribute
    : attribute_name
    | attribute_name <span class="string">'('</span> attribute_param_list <span class="string">')'</span>
    ;

attribute_list
    : attribute
    | attribute_list attribute
    ;

opt_attributes
       : attribute_list
        | empty
        ;

trailing_block_param
    : AT_IDENT
    | AT_IDENT <span class="string">'('</span> <span class="string">')'</span>
    | AT_IDENT <span class="string">'('</span> parameters <span class="string">')'</span>
    ;

macro_params
    : parameters
    | parameters <span class="string">';'</span> trailing_block_param
    | <span class="string">';'</span> trailing_block_param
    | empty
    ;

macro_func_body
    : implies_body <span class="string">';'</span>
    | compound_statement
    ;

macro_declaration
        : MACRO macro_header <span class="string">'('</span> macro_params <span class="string">')'</span> opt_attributes macro_func_body
    ;

struct_or_union
    : STRUCT
    | UNION
    ;

struct_declaration
    : struct_or_union TYPE_IDENT opt_attributes struct_body
        ;

struct_body
        : <span class="string">'{'</span> struct_declaration_list <span class="string">'}'</span>
    ;

struct_declaration_list
    : struct_member_decl
        | struct_declaration_list struct_member_decl
        ;

enum_params
    : enum_param_decl
    | enum_params <span class="string">','</span> enum_param_decl
    ;

enum_param_list
    : <span class="string">'('</span> enum_params <span class="string">')'</span>
    | <span class="string">'('</span> <span class="string">')'</span>
    | empty
    ;

struct_member_decl
        : type identifier_list opt_attributes <span class="string">';'</span>
        | struct_or_union IDENT opt_attributes struct_body
        | struct_or_union opt_attributes struct_body
        | BITSTRUCT <span class="string">':'</span> type opt_attributes bitstruct_body
        | BITSTRUCT IDENT <span class="string">':'</span> type opt_attributes bitstruct_body
        | INLINE type IDENT opt_attributes <span class="string">';'</span>
        | INLINE type opt_attributes <span class="string">';'</span>
    ;


enum_spec
    : <span class="string">':'</span> type enum_param_list
    | empty
    ;

enum_declaration
    : ENUM TYPE_IDENT enum_spec opt_attributes <span class="string">'{'</span> enum_list <span class="string">'}'</span>
    ;

faults
    : CONST_IDENT
    | faults <span class="string">','</span> CONST_IDENT
    ;

fault_declaration
        : FAULT TYPE_IDENT opt_attributes <span class="string">'{'</span> faults <span class="string">'}'</span>
        | FAULT TYPE_IDENT opt_attributes <span class="string">'{'</span> faults <span class="string">','</span> <span class="string">'}'</span>
        ;

func_macro_name
    : IDENT
    | AT_IDENT
    ;

func_header
    : optional_type type <span class="string">'.'</span> func_macro_name
    | optional_type func_macro_name
    ;


macro_header
    : func_header
    | type <span class="string">'.'</span> func_macro_name
    | func_macro_name
    ;

fn_parameter_list
    : <span class="string">'('</span> parameters <span class="string">')'</span>
    | <span class="string">'('</span> <span class="string">')'</span>
    ;

parameters
    : parameter <span class="string">'='</span> expr
    | parameter
    | parameters <span class="string">','</span> parameter
    | parameters <span class="string">','</span> parameter <span class="string">'='</span> expr
    ;

parameter
    : type IDENT opt_attributes
    | type ELLIPSIS IDENT opt_attributes
    | type ELLIPSIS CT_IDENT
    | type CT_IDENT
        | type ELLIPSIS opt_attributes
    | type HASH_IDENT opt_attributes
    | type <span class="string">'&amp;'</span> IDENT opt_attributes
    | type opt_attributes
    | <span class="string">'&amp;'</span> IDENT opt_attributes
    | HASH_IDENT opt_attributes
    | ELLIPSIS
    | IDENT opt_attributes
    | IDENT ELLIPSIS opt_attributes
    | CT_IDENT
    | CT_IDENT ELLIPSIS
    ;

func_definition
    : FN func_header fn_parameter_list opt_attributes <span class="string">';'</span>
    | FN func_header fn_parameter_list opt_attributes macro_func_body
    ;

const_declaration
    : CONST CONST_IDENT opt_attributes <span class="string">'='</span> expr <span class="string">';'</span>
    | CONST type CONST_IDENT opt_attributes <span class="string">'='</span> expr <span class="string">';'</span>
    ;

func_typedef
    : FN optional_type fn_parameter_list
    ;

opt_distinct_inline
    : DISTINCT
    | DISTINCT INLINE
    | INLINE DISTINCT
    | INLINE
    | empty
    ;

generic_parameters
    : bit_expr
    | type
    | generic_parameters <span class="string">','</span> bit_expr
    | generic_parameters <span class="string">','</span> type
    ;

typedef_type
    : func_typedef
    | type opt_generic_parameters
    ;



multi_declaration
    : <span class="string">','</span> IDENT
    | multi_declaration <span class="string">','</span> IDENT
    ;

global_storage
    : TLOCAL
    | empty
    ;

global_declaration
    : global_storage optional_type IDENT opt_attributes <span class="string">';'</span>
    | global_storage optional_type IDENT multi_declaration opt_attributes <span class="string">';'</span>
    | global_storage optional_type IDENT opt_attributes <span class="string">'='</span> expr <span class="string">';'</span>
    ;

opt_tl_stmts
    : top_level_statements
    | empty
    ;

tl_ct_case
    : CT_CASE constant_expr <span class="string">':'</span> opt_tl_stmts
    | CT_CASE type <span class="string">':'</span> opt_tl_stmts
        | CT_DEFAULT <span class="string">':'</span> opt_tl_stmts
        ;

tl_ct_switch_body
        : tl_ct_case
        | tl_ct_switch_body tl_ct_case
        ;

define_attribute
    : AT_TYPE_IDENT <span class="string">'('</span> parameters <span class="string">')'</span> opt_attributes <span class="string">'='</span> <span class="string">'{'</span> opt_attributes <span class="string">'}'</span>
    | AT_TYPE_IDENT opt_attributes <span class="string">'='</span> <span class="string">'{'</span> opt_attributes <span class="string">'}'</span>
    ;

opt_generic_parameters
    : <span class="string">'&lt;'</span> generic_parameters <span class="string">'&gt;'</span>
    | empty
    ;



define_ident
    : IDENT <span class="string">'='</span> path_ident opt_generic_parameters
    | CONST_IDENT <span class="string">'='</span> path_const opt_generic_parameters
    | AT_IDENT <span class="string">'='</span> path_at_ident opt_generic_parameters
        ;

define_declaration
    : DEF define_ident <span class="string">';'</span>
    | DEF define_attribute <span class="string">';'</span>
    | DEF TYPE_IDENT opt_attributes <span class="string">'='</span> opt_distinct_inline typedef_type <span class="string">';'</span>
    ;

tl_ct_if
    : CT_IF constant_expr <span class="string">':'</span> opt_tl_stmts CT_ENDIF
    | CT_IF constant_expr <span class="string">':'</span> opt_tl_stmts CT_ELSE opt_tl_stmts CT_ENDIF
    ;

tl_ct_switch
    : ct_switch tl_ct_switch_body CT_ENDSWITCH
    ;

module_param
        : CONST_IDENT
        | TYPE_IDENT
        ;

module_params
    : module_param
        | module_params <span class="string">','</span> module_param
        ;

module
    : MODULE path_ident opt_attributes <span class="string">';'</span>
    | MODULE path_ident <span class="string">'&lt;'</span> module_params <span class="string">'&gt;'</span> opt_attributes <span class="string">';'</span>
    ;

import_paths
    : path_ident
    | path_ident <span class="string">','</span> path_ident
    ;

import_decl
        : IMPORT import_paths opt_attributes <span class="string">';'</span>
        ;

translation_unit
    : top_level_statements
    | empty
    ;

top_level_statements
    : top_level
    | top_level_statements top_level
    ;

opt_extern
    : EXTERN
    | empty
    ;

top_level
    : module
    | import_decl
    | opt_extern func_definition
    | opt_extern const_declaration
    | opt_extern global_declaration
    | ct_assert_stmt
    | ct_echo_stmt
    | ct_include_stmt
    | tl_ct_if
    | tl_ct_switch
    | struct_declaration
    | fault_declaration
    | enum_declaration
    | macro_declaration
    | define_declaration
    | static_declaration
    | bitstruct_declaration
    ;


%%

void yyerror(char *s)
{
    fflush(stdout);
    printf(<span class="string">"\n%*s\n%*s\n"</span>, column, <span class="string">"^"</span>, column, s);
}

int main(int argc, char *argv[])
{
    yyparse();
    return <span class="number">0</span>;
}</code></pre><hr><p>title: C3 Specification
description: C3 Specification
sidebar:</p><pre><code>order: 999</code></pre><hr><p><em>THIS SPECIFICATION IS UNDER DEVELOPMENT</em></p><h2 id="customizing-a-project-notation">Notation</h2><p>The syntax is specified using Extended Backus-Naur Form (EBNF):</p><pre><code>production  ::= PRODUCTION_NAME '::=' expression?
expression  ::= alternative ("|" alternative)* 
alternative ::= term term*
term        ::= PRODUCTION_NAME | TOKEN | set | group | option | repetition
set         ::= '[' (range | CHAR) (rang | CHAR)* ']'
range       ::= CHAR '-' CHAR 
group       ::= '(' expression ')'
option      ::= expression '?'
repetition  ::= expression '*'</code></pre><p>Productions are expressions constructed from terms and the following operators, in increasing precedence:</p><pre><code>|   alternation
()  grouping
?  option (0 or 1 times)
*  repetition (0 to n times)</code></pre><p>Uppercase production names are used to identify lexical tokens. Non-terminals are in lower case. Lexical tokens are
enclosed in single quotes ‘’.</p><p>The form <code>a..b</code> represents the set of characters from a through b as alternatives.</p><h2 id="customizing-a-project-source-code-representation">Source code representation</h2><p>A program consists of one or more <em>translation units</em> stored in files written in the Unicode character set,
stored as a sequence of bytes using the UTF-8 encoding. Except for comments and the contents of character and string
literals, all input elements are formed only from the ASCII subset (U+0000 to U+007F) of Unicode.</p><p>A raw byte stream is translated into a sequence of tokens which white space and comments are discarded. Doc
comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols
of the syntactic grammar.</p><h3 id="customizing-a-project-source-code-representation-lexical-translations">Lexical Translations</h3><p>A raw byte stream is translated into a sequence of tokens which white space and comments are discarded. Doc
comments may optionally be discarded as well. The resulting input elements form the tokens that are the terminal symbols
of the syntactic grammar.</p><p>The longest possible translation is used at each step, even if the result does not ultimately make a correct program
while another lexical translation would.</p><blockquote>
<p>Example: <code>a--b</code> is translated as <code>a</code>, <code>--</code>, <code>b</code>, which does not form a grammatically correct expression, even though the tokenization <code>a</code>, <code>-</code>, <code>-</code>, <code>b</code> could form a grammatically correct expression.</p>
</blockquote><h3 id="customizing-a-project-source-code-representation-line-terminators">Line Terminators</h3><p>The C3 compiler divides the sequence of input bytes into lines by recognizing <em>line terminators</em></p><p>Lines are terminated by the ASCII LF character (U+000A), also known as “newline”. A line termination specifies the
termination of the // form of a comment.</p><h3 id="customizing-a-project-source-code-representation-input-elements-and-tokens">Input Elements and Tokens</h3><p>An input element may be:</p><ol>
<li>White space</li>
<li>Comment</li>
<li>Doc Contract</li>
<li>Token</li>
</ol><p>A token may be:</p><ol>
<li>Identifier</li>
<li>Keyword</li>
<li>Literal</li>
<li>Separator</li>
<li>Operator</li>
</ol><p>A Doc Contract consists of:</p><ol>
<li>A stream of descriptive text</li>
<li>A list of directive Tokens</li>
</ol><p>Those input elements that are not white space or comments are tokens. The tokens are the terminal symbols of the
syntactic grammar. Whitespace and comments can serve to separate tokens that might be tokenized in another manner. For
example the characters <code>+</code> and <code>=</code> may form the operator token <code>+=</code> only if there is no intervening white space or
comment.</p><h3 id="customizing-a-project-source-code-representation-white-space">White Space</h3><p>White space is defined as the ASCII horizontal tab character (U+0009), form feed character (U+000A), vertical tab (
U+000B), carriage return (U+000D), space character (U+0020) and the line terminator character (U+000D).</p><pre><code>WHITESPACE      ::= [ \t\f\v\r\n]</code></pre><h3 id="customizing-a-project-source-code-representation-letters-and-digits">Letters and digits</h3><pre><code>UC_LETTER       ::= [A-Z]
LC_LETTER       ::= [a-z]
LETTER          ::= UC_LETTER | LC_LETTER
DIGIT           ::= [0-9]
HEX_DIGIT       ::= [0-9a-fA-F]
BINARY_DIGIT    ::= [01]
OCTAL_DIGIT     ::= [0-7]
LC_LETTER_US    ::= LC_LETTER | "_"
UC_LETTER_US    ::= UC_LETTER | "_"
ALPHANUM        ::= LETTER | DIGIT
ALPHANUM_US     ::= ALPHANUM | "_"
UC_ALPHANUM_US  ::= UC_LETTER_US | DIGIT
LC_ALPHANUM_US  ::= LC_LETTER_US | DIGIT</code></pre><h3 id="customizing-a-project-source-code-representation-comments">Comments</h3><p>There are three types of regular comments:</p><ol>
<li><code>// text</code> a line comment. The text between <code>//</code> and line end is ignored.</li>
<li><code>/* text */</code> block comments. The text between <code>/*</code> and <code>*/</code> is ignored. It has nesting behaviour, so for every <code>/*</code>
discovered between the first <code>/*</code> and the last <code>*/</code> a corresponding <code>*/</code> must be found.</li>
</ol><h3 id="customizing-a-project-source-code-representation-doc-contract">Doc contract</h3><ol>
<li><code>&lt;* text *&gt;</code> doc block comment. The text between <code>&lt;*</code> and <code>*&gt;</code> is optionally parsed using the doc comment
syntactic grammar. A compiler may choose to read <code>&lt;* text *&gt;</code> as a regular comment.</li>
</ol><h3 id="customizing-a-project-source-code-representation-identifiers">Identifiers</h3><p>Identifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and
digits.
The first character in an identifier must be a letter or underscore.</p><p>C3 has three types of identifiers: const identifiers - containing only underscore and upper-case letters,
type identifiers - starting with an upper case letter followed by at least one underscore letter and regular
identifiers, starting with a lower case letter.</p><pre><code>IDENTIFIER      ::=  "_"* LC_LETTER ALPHANUM_US*
CONST_IDENT     ::=  "_"* UC_LETTER UC_ALPHANUM_US*
TYPE_IDENT      ::=  "_"* UC_LETTER UC_ALPHANUM_US* LC_LETTER ALPHANUM_US*
CT_IDENT        ::=  "$" IDENTIFIER
CT_CONST_IDENT  ::=  "$" CONST_IDENT
CT_TYPE_IDENT   ::=  "$" TYPE_IDENT
AT_TYPE_IDENT   ::=  "@" TYPE_IDENT
PATH_SEGMENT    ::= "_"* LC_LETTER LC_ALPHANUM_US*</code></pre><h3 id="customizing-a-project-source-code-representation-keywords">Keywords</h3><p>The following keywords are reserved and may not be used as identifiers:</p><pre><code>asm         any         anyfault
assert      attribute   break
case        cast        catch
const       continue    default
defer       def         do
else        enum        extern
errtype     false       fn
generic     if          import
inline      macro
module      nextcase    null
public      return      struct
switch      true        try
typeid      var         void        
while

bool        quad        double      
float       long        ulong
int         uint        byte
short       ushort      char
isz         usz         float16
float128

$and        $assert     $case       
$default    $echo       $else       
$error      $endfor     $endforeach 
$endif      $endswitch  $for        
$foreach    $if         $switch     
$typef      $vaarg      $vaconst
$vacount    $varef      $vatype</code></pre><h3 id="customizing-a-project-source-code-representation-operators-and-punctuation">Operators and punctuation</h3><p>The following character sequences represent operators and punctuation.</p><pre><code>&amp;       @       ~       |       ^       :
,       /       $       .       ;       )
&gt;       &lt;       #       {       }       -
(       )       *       [       ]       %
&gt;=      &lt;=      +       +=      -=      !
?       ?:      &amp;&amp;      ??      &amp;=      |=
^=      /=      ..      ==      ({      })
[&lt;      &gt;]      (&lt;      &gt;)      ++      --      
%=      !=      ||      ::      &lt;&lt;      &gt;&gt;      
!!      ...     &lt;&lt;=     &gt;&gt;=</code></pre><h3 id="customizing-a-project-source-code-representation-integer-literals">Integer literals</h3><p>An integer literal is a sequence of digits representing an integer constant.
An optional prefix sets a non-decimal base: 0b or 0B for binary,
0o, or 0O for octal, and 0x or 0X for hexadecimal.
A single 0 is considered a decimal zero.
In hexadecimal literals, letters a through f and A through F represent values 10 through 15.</p><p>For readability, an underscore character _ may appear after a base prefix
or between successive digits; such underscores do not change the literal’s value.</p><pre><code>INTEGER         ::= DECIMAL_LIT | BINARY_LIT | OCTAL_LIT | HEX_LIT
DECIMAL_LIT     ::= '0' | [1-9] ('_'* DECIMAL_DIGITS)?
BINARY_LIT      ::= '0' [bB] '_'* BINARY_DIGITS
OCTAL_LIT       ::= '0' [oO] '_'* OCTAL_DIGITS
HEX_LIT         ::= '0' [xX] '_'* HEX_DIGITS

BINARY_DIGIT    ::= [01]
HEX_DIGIT       ::= [0-9a-fA-F]

DECIMAL_DIGITS  ::= DIGIT ('_'* DIGIT)*
BINARY_DIGITS   ::= BINARY_DIGIT ('_'* BINARY_DIGIT)*
OCTAL_DIGITS    ::= OCTAL_DIGIT ('_'* OCTAL_DIGIT)*
HEX_DIGITS      ::= HEX_DIGIT ('_'* HEX_DIGIT)*</code></pre><pre><code>42
4_2
0_600
0o600
0O600           // second character is capital letter 'O'
0xBadFace
0xBad_Face
0x_67_7a_2f_cc_40_c6
170141183460469231731687303715884105727
170_141183_460469_231731_687303_715884_105727

0600            // Invalid, non zero decimal number may not start with 0 
_42             // an identifier, not an integer literal
42_             // invalid: _ must separate successive digits
0_xBadFace      // invalid: _ must separate successive digits</code></pre><h3 id="customizing-a-project-source-code-representation-floating-point-literals">Floating point literals</h3><p>A floating-point literal is a decimal or hexadecimal representation of a floating-point constant.</p><p>A decimal floating-point literal consists of an integer part (decimal digits), a decimal point,
a fractional part (decimal digits), and an exponent part (e or E followed by an optional
sign and decimal digits). One of the integer part or the fractional part may be elided;
one of the decimal point or the exponent part may be elided. An exponent value exp scales
the mantissa (integer and fractional part) by powers of 10.</p><p>A hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part
(hexadecimal digits), a radix point, a fractional part (hexadecimal digits),
and an exponent part (p or P followed by an optional sign and decimal digits).
One of the integer part or the fractional part may be elided; the radix point
may be elided as well, but the exponent part is required.
An exponent value exp scales the mantissa (integer and fractional part) by powers of 2.</p><p>For readability, an underscore character _ may appear after a base prefix or between successive digits;
such underscores do not change the literal value.</p><pre><code>FLOAT_LIT       ::= DEC_FLOAT_LIT | HEX_FLOAT_LIT
DEC_FLOAT_LIT   ::= DECIMAL_DIGITS '.' DECIMAL_DIGITS? DEC_EXPONENT? 
                    | DECIMAL_DIGITS DEC_EXPONENT
                    | '.' DECIMAL_DIGITS DEC_EXPONENT?
DEC_EXPONENT    ::= [eE] [+-]? DECIMAL_DIGITS
HEX_FLOAT_LIT   ::= '0' [xX] HEX_MANTISSA HEX_EXPONENT
HEX_MANTISSA    ::= HEX_DIGITS '.' HEX_DIGITS?
                    | HEX_DIGITS
                    | '.' HEX_DIGITS 
HEX_EXPONENT    ::= [pP] [+-] DECIMAL_DIGITS</code></pre><h3 id="customizing-a-project-source-code-representation-characters">Characters</h3><p>Characters are the fundamental components of strings and character literals.</p><pre><code>CHAR_ELEMENT    ::= [\x20-\x26] | [\x28-\x5B] | [\x5D-\x7F]
CHAR_LIT_BYTE   ::= CHAR_ELEMENT | \x5C CHAR_ESCAPE
CHAR_ESCAPE     ::= [abefnrtv\'\"\\] 
                    | 'x' HEX_DIGIT HEX_DIGIT
UNICODE_CHAR    ::= unicode_char                    
                    | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
                    | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT 
                          HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT</code></pre><h3 id="customizing-a-project-source-code-representation-backslash-escapes">Backslash escapes</h3><p>The following backslash escapes are available for characters and string literals:</p><pre><code class="lang-text">\<span class="number">0</span>      <span class="number">0</span>x<span class="number">00</span> zero value
\a      <span class="number">0</span>x<span class="number">07</span> alert/bell
\b      <span class="number">0</span>x<span class="number">08</span> backspace
\e      <span class="number">0</span>x<span class="number">1</span>B escape
\f      <span class="number">0</span>x<span class="number">0</span>C form feed
\n      <span class="number">0</span>x<span class="number">0</span>A newline
\r      <span class="number">0</span>x<span class="number">0</span>D carriage return
\t      <span class="number">0</span>x<span class="number">09</span> horizontal tab
\v      <span class="number">0</span>x<span class="number">0</span>B vertical tab
\\      <span class="number">0</span>x<span class="number">5</span>C backslash
\<span class="string">'      <span class="number">0</span>x<span class="number">27</span> single quote '</span>
\<span class="string">"      <span class="number">0</span>x<span class="number">22</span> double quote "</span>
\x      Escapes a single byte hex value
\u      Escapes a two byte unicode hex value 
\U      Escapes a four byte unicode hex value</code></pre><h3 id="customizing-a-project-source-code-representation-string-literals">String literals</h3><p>A string literal represents a string constant obtained from concatenating a sequence of characters.
String literals are character sequences between double quotes, as in “bar”. Within the quotes,
any character may appear except newline and unescaped double quote. The text between the
quotes forms the value of the literal, with backslash escapes interpreted as they are in
rune literals, with the same restrictions. The two-digit hexadecimal (\xnn) escapes represent
individual bytes of the resulting string; all other escapes represent the (possibly multibyte)
UTF-8 encoding of individual characters. Thus inside a string literal <code>\xFF</code> represent a single
byte of value <code>0xFF</code> = 255, while <code>ÿ</code>, <code>\u00FF</code>, <code>\U000000FF</code> and <code>\xc3\xbf</code> represent the two bytes
<code>0xc3 0xbf</code> of the UTF-8 encoding of character <code>U+00FF</code>.</p><pre><code>STRING_LIT      ::= \x22 (CHAR_LIT_BYTE | UNICODE_CHAR)* \x22</code></pre><h4>Compile time string concatenation</h4><p>Strings will concatenate if declared in sequence.</p><p>Example:</p><pre><code class="lang-c">String s = <span class="string">"abc"</span> <span class="string">"def"</span> <span class="string">"ghi"</span>;
<span class="comment">// This is equivalent to:</span>
String s = <span class="string">"abcdefghi"</span>;</code></pre><h3 id="customizing-a-project-source-code-representation-raw-string-literals">Raw string literals</h3><p>Raw string literals are enclosed between `` and consist of the raw UTF8 in the source
code between the “`”. A sequence of two “`” will be interpreted as a single escaped “`” that does
not terminate the literal.</p><h4>Compile time concatenation</h4><p>Raw strings will concatenate with other regular strings and raw strings (
see <a href="#compile-time-string-concatenation">string literal compile time concatenation</a>).</p><h4>Source code pre-filtering</h4><p>The source code will pre-filter <code>\r</code> (<code>0x0D</code>) from the source code. This means that it is also implicitly
filtered out of raw strings.</p><h3 id="customizing-a-project-source-code-representation-character-literals">Character literals</h3><p>A character literal is enclosed in <code>'</code> and may either consist of 1, 2, 4, 8, 16 bytes.</p><pre><code>CHARACTER_LIT   ::= "'" (CHAR_LIT_BYTE+) | UNICODE_CHAR "'"</code></pre><h2 id="customizing-a-project-types">Types</h2><p>Types consist of built-in types and user-defined types (enums, structs, unions, bitstructs, fault and distinct).</p><h3 id="customizing-a-project-types-boolean-types">Boolean types</h3><p><code>bool</code> may have the two values <code>true</code> and <code>false</code>. It holds a single bit of information but is
stored in a <code>char</code> type.</p><h3 id="customizing-a-project-types-integer-types">Integer types</h3><p>The built-in integer types:</p><pre><code class="lang-text">char      unsigned <span class="number">8</span>-bit
ichar     signed <span class="number">8</span>-bit
ushort    unsigned <span class="number">16</span>-bit
short     signed <span class="number">16</span>-bit
uint      unsigned <span class="number">32</span>-bit
int       signed <span class="number">32</span>-bit
ulong     unsigned <span class="number">64</span>-bit
long      signed <span class="number">64</span>-bit
uint<span class="number">128</span>   unsigned <span class="number">128</span>-bit
int<span class="number">128</span>    singed <span class="number">128</span>-bit</code></pre><p>In addition, the following type aliases exist:</p><pre><code class="lang-text">uptr      unsigned pointer size
iptr      signed pointer size
usz       unsigned pointer offset / object size
isz       signed pointer offset  / object size</code></pre><h3 id="customizing-a-project-types-floating-point-types">Floating point types</h3><p>Built-in floating point types:</p><pre><code>float16   IEEE 16-bit*
bfloat16  Brainfloat*
float     IEEE 32-bit
double    IEEE 64-bit
float128  IEEE 128-bit*</code></pre><p>(* optionally supported)</p><h3 id="customizing-a-project-types-vector-types">Vector types</h3><p>A vector lowers to the platform’s vector types where available. A vector has a base type and a width.</p><pre><code>vector_type        ::= type "[&lt;" length "&gt;]"</code></pre><h4>Vector base type</h4><p>The base type of a vector must be boolean, an integer or a floating point type.</p><h4>Min width</h4><p>The vector width must be at least 1.</p><h4>Element access</h4><p>Vector elements are accessed using <code>[]</code>. It is possible to take the address of a single element.</p><h4>Alignment</h4><p>Alignment of vectors are platform dependent, but is at least the alignment of its element type.</p><h4>Vector operations</h4><p>Vectors support the same arithmetics as its underlying type, and will perform the operation
element-wise.</p><p>Example:</p><pre><code class="lang-c">int[&lt;<span class="number">2</span>&gt;] a = { <span class="number">1</span>, <span class="number">3</span> };
int[&lt;<span class="number">2</span>&gt;] b = { <span class="number">2</span>, <span class="number">7</span> };

int[&lt;<span class="number">2</span>&gt;] c = a * b;
<span class="comment">// Equivalent to</span>
int[&lt;<span class="number">2</span>&gt;] c = { a[<span class="number">0</span>] * b[<span class="number">0</span>], a[<span class="number">1</span>] * b[<span class="number">1</span>] };</code></pre><h3 id="customizing-a-project-types-array-types">Array types</h3><p>An array has the alignment of its elements. An array must have at least one element.</p><h3 id="customizing-a-project-types-slice-types">Slice types</h3><p>The slice consist of a pointer, followed by an usz length, having the alignment of pointers.</p><h3 id="customizing-a-project-types-pointer-types">Pointer types</h3><p>A pointer is the address to memory.</p><pre><code class="lang-text">pointer_type       ::= type <span class="string">"*"</span></code></pre><h4>Pointee type</h4><p>The type of the memory pointed to is the <strong>pointee type</strong>. It may be any runtime type.</p><h4>iptr and uptr</h4><p>A pointer may be losslessly cast to an <code>iptr</code> or <code>uptr</code>. An <code>iptr</code> or <code>uptr</code> may be cast to a pointer of any type.</p><h4>The wildcard pointer void*</h4><p>The <code>void*</code> may implicitly cast into any other pointer type. The <code>void*</code>
[implicitly casts into any other pointer.</p><p>A void* pointer may never be dereferenced.</p><h4>Pointer arithmetic on void*</h4><p>Performing pointer arithmetics on void* will assume that the element size is 1. This includes
pointer arithmetics using subscripting.</p><h4>Subscripting</h4><p>Subscripting a pointer is equal to performing pointer arithmetics using the index, followed by a deref.
Subscripts on pointers may be negative and will never do bounds checks.</p><h4>Deref</h4><p>Dereferencing a pointer will return the value in the memory location interpreted as the <strong>pointee type</strong>.</p><h3 id="customizing-a-project-types-">#</h3><h3 id="customizing-a-project-types-struct-types">Struct types</h3><p>A struct may not have zero members.</p><h4>Alignment</h4><p>A non-packed struct has the alignment of the member that has the highest alignment. A packed struct
has alignment 1. See <a href="#attributes">align attribute</a> for details on changing the alignment.</p><h3 id="customizing-a-project-types-union-types">Union types</h3><p>A union may not have zero members.</p><h4>Alignment</h4><p>A union has the alignment of the member that has the highest alignment. See <a href="#attributes">align attribute</a> for
details on changing the alignment.</p><h3 id="customizing-a-project-types-fault-types">Fault types</h3><p>A fault is an extensible enum which can be used to create an Excuse for an empty <a href="https://waveproc.github.io/language-common/optionals-essential/#what-is-an-optional">optional</a>.</p><h4>Alignment</h4><p>A fault type has the same alignment as a pointer. See <a href="#attributes">align attribute</a> for details on changing the
alignment.</p><h3 id="customizing-a-project-types-enum-types">Enum types</h3><h3 id="customizing-a-project-types-function-types">Function types</h3><h3 id="customizing-a-project-types-typeid-type">Typeid type</h3><p>The typeid is a pointer sized value which uniquely identifies a type.</p><h3 id="customizing-a-project-types-any-type">Any type</h3><p>The <code>any</code> is a fat pointer (2 pointers wide) holding a pointer to a value and its corresponding <a href="#typeid-type">typeid</a>.
It cannot be dereferenced.</p><h4>Fields</h4><p><code>.ptr</code> returns a <code>void*</code> pointer to the underlying value <code>.type</code> returns the <a href="#typeid-type">typeid</a>
of the underlying value.</p><h4>Switching over <code>any</code></h4><p>Switching over an <code>any</code> value creates an <a href="#any-switch">any switch</a>.</p><h3 id="customizing-a-project-types-anyfault-type">Anyfault type</h3><h2 id="customizing-a-project-declarations-and-scope">Declarations and scope</h2><h2 id="customizing-a-project-expressions">Expressions</h2><h3 id="customizing-a-project-expressions-assignment-expression">Assignment expression</h3><pre><code>assignment_expr    ::= ct_type_assign | unary_expr assignment_op expr
ct_type_assign     ::= ct_type_ident "=" type
assignment_op      ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&lt;&lt;=" | "&gt;&gt;=" | "&amp;=" | "^=" | "|="</code></pre><h4>Type assign</h4><p>This assigns a new type to a compile time type variable. The value of the expression is the type assigned.</p><h4>Combined assign</h4><p>All assignment operations except for “=” are combined assign operation. They first perform the operation indicated
by the leftmost character(s) in the operator (e.g <code>+</code> for <code>+=</code>, <code>&lt;&lt;</code> for <code>&lt;&lt;=</code> etc) with the lhs and the rhs.
The result is then assigned to the left hand side. The result of the operation is the new value of the left
hand side.</p><h4>Implicit conversion</h4><p>If the left hand side is a pointer and the operation is “+=” or “-=” an attempt to implicitly convert to
isz/usz will be tried.</p><p>For all other types and operations, <strong>an implicit conversion</strong> of rhs to the type of lhs will be tried.</p><h3 id="customizing-a-project-expressions-ternary-elvis-and-or-else-expressions">Ternary, elvis and or-else expressions</h3><pre><code>ternary_group_expr ::= suffix_group_expr | ternary_expr | elvis_expr | orelse_expr
ternary_expr       ::= or_expr "?" expr ":" ternary_group_expr
elvis_expr         ::= suffix_expr "?:" ternary_group_expr
orelse_expr        ::= suffix_expr "??" ternary_group_expr</code></pre><h4>Ternary evaluation</h4><p>The most left-hand expression is evaluated to a boolean. If it is true, the value of the middle
expression is returned, otherwise the last expression is returned.</p><p>Only the most left-hand expression and the returned expressions are evaluated.</p><p>The middle and last expression are implicitly converted to their <strong>unified type</strong>.</p><p>The resulting type is the <strong>unified type</strong>.</p><h4>Elvis evaluation</h4><p>Lhs and rhs are implicitly converted to their <strong>unified type</strong>.</p><p>The lhs is evaluated, it is then converted to a boolean, if the result it true, return the lhs value
before its boolean conversion. Otherwise return the right hand side.</p><p>The right hand side is only evaluated if the lhs evaluates to false.</p><p>The resulting type is the <strong>unified type</strong>.</p><h4>Orelse evaluation</h4><p>The lhs must be optional. The non-optional type for lhs and rhs are calculated.
The <strong>unified type</strong> of the result is calculated. Lhs are converted to the unified type
preserving their optionality.</p><p>At runtime, lhs is evaluated. If it evaluates to an optional, rhs is returned instead.</p><p>Rhs is only evaluated if lhs evaluates to an optional.</p><p>The resulting type of the orelse is the post conversion type of the rhs.</p><h3 id="customizing-a-project-expressions-suffix-expression">Suffix expression</h3><p>Suffix expressions convert a fault to an optional.</p><pre><code>suffix_group_exp   ::= or_group_expr | suffix_expr
suffix_expr        ::= or_group_expr "?" "!"?</code></pre><h4>Effect of “?”</h4><p>The “?” will convert the expression into an optional. The left hand side must be a fault type.
If an optional “!” follows, this optional is immediately returned, as if by a <code>return &lt;expr&gt;?</code> statement.</p><h4>Type of the expression</h4><p>The type is a <strong>wildcard optional</strong>. If “!” is added, it is a <strong>wildcard</strong> type.</p><h3 id="customizing-a-project-expressions-rethrow-expression">Rethrow expression</h3><p>If the expression is optional, implicitly return with the optional value.</p><pre><code>rethrow_expr       ::= expr "!"</code></pre><h4>The expression to rethrow</h4><p>The expression must have an optional type, otherwise this is a compile time error.</p><h4>Type</h4><p>The type of “rethrow” is the inner expr type without optional.</p><h3 id="customizing-a-project-expressions-relational-expression">Relational expression</h3><pre><code>rel_group_expr     ::= add_group_expr | relational_expr
relational_expr    ::= rel_group_expr relational_op add_group_expr
relational_op      ::= "&lt;" | "&gt;" | "&lt;=" | "&gt;="</code></pre><p>TODO</p><h3 id="customizing-a-project-expressions-and-expression">And expression</h3><p>This binary expression evaluates the lhs, and if the result is <code>true</code> evaluates the rhs. The
result is true if both lhs and rhs are true.</p><pre><code>and_group_expr     ::= rel_group_expr | and_expr
and_expr           ::= and_group_expr "&amp;&amp;" rel_group_expr</code></pre><h4>Type</h4><p>The type of the and-expression is <code>bool</code>.</p><h3 id="customizing-a-project-expressions-or-expression">Or expression</h3><p>This binary expression evaluates the lhs, and if the result is <code>false</code> evaluates the rhs. The
result is true if lhs or rhs is true.</p><pre><code>or_group_expr      ::= and_group_expr | or_expr
or_expr            ::= or_group_expr "||" and_group_expr</code></pre><h4>Constant folded arithmetics</h4><p>Constant folding will happen for constant integers and floating. Vectors operations will
not be constant-folded.</p><p>Constant folded operations are: multiplication, division, addition, subtraction,
bit shifts, bit negation, bitwise and, or and xor, comparison, logical and/or,
and negation.</p><h4>Type</h4><p>The type of the or-expression is <code>bool</code>.</p><h3 id="customizing-a-project-expressions-casts">Casts</h3><h3 id="customizing-a-project-expressions-pointer-casts">Pointer casts</h3><h4>Integer to pointer cast</h4><p>Any integer of pointer size or larger may be explicitly cast to a pointer. An integer to pointer cast is considered
non-constant, except in the special case where the integer == 0. In that case, the result is constant <code>null</code>.</p><p>Example:</p><pre><code>byte a = 1;
int* b = (int*)a; // Invalid, pointer type is &gt; 8 bits.
int* c = (int*)1; // Valid, but runtime value.
int* d = (int*)0; // Valid and constant value.</code></pre><h4>Pointer to integer cast</h4><p>A pointer may be cast to any integer, truncating the pointer value if the size of the pointer is larger than the pointer
size. A pointer to integer cast is considered non-constant, except in the special case of a null pointer, where it is
equal to the integer value 0.</p><p>Example:</p><pre><code>fn void test() { ... }
def VoidFunc = fn void test();

VoidFunc a = &amp;test;
int b = (int)null;
int c = (int)a; // Invalid, not constant
int d = (int)((int*)1); // Invalid, not constant</code></pre><h3 id="customizing-a-project-expressions-subscript-operator">Subscript operator</h3><p>The subscript operator may take as its left side a pointer, array or slice. The index may be of any integer
type. TODO
<em>NOTE</em> The subscript operator is not symmetrical as in C. For example in C3 <code>array[n] = 33</code> is allowed, but
not <code>n[array] = 33</code>. This is a change from C.</p><h3 id="customizing-a-project-expressions-operands">Operands</h3><h3 id="customizing-a-project-expressions-compound-literals">Compound Literals</h3><p>Compound literals have the format</p><pre><code>compound_literal   ::= TYPE_IDENTIFIER '(' initializer_list ')'
initializer_list   ::= '{' (initializer_param (',' initializer_param)* ','?)? '}'
initializer_param  ::= expression | designator '=' expression
designator         ::= array_designator | range_designator | field_designator
array_designator   ::= '[' expression ']'
range_designator   ::= '[' range_expression ']'
field_designator   ::= IDENTIFIER
range_expression   ::= (range_index)? '..' (range_index)?
range_index        ::= expression | '^' expression</code></pre><p>Taking the address of a compound literal will yield a pointer to stack allocated temporary.</p><h3 id="customizing-a-project-expressions-function-calls">Function calls</h3><h4>Function argument resolution</h4><p>Call slots are in order: regular slots, vaarg slot, name-only slots.</p><p>No regular slots may appear after the vaarg slot, however there may be named parameters with default values 
after the vaarg slot if it’s not a raw vaarg.</p><p>These “name-only” slots need to have a parameter name and a default value, and may only be called as named 
arguments.</p><p>Named arguments may never be <em>splat</em> expressions.</p><ol>
<li>Step through all the arguments, resolve the named arguments and determine if there are any regular arguments.</li>
<li>If there are regular arguments, then named arguments may only be in name-only slots, otherwise it is an error.</li>
<li>If there are named arguments in the regular slots, all slots not provided arguments must have default values.</li>
<li>Proceed with evaluation of arguments from left to right in call invocation order.</li>
<li>Regular arguments are placed in the regular slots from left to right.</li>
<li>If a regular argument is a <em>splat</em> expression, evaluate it <em>without inference</em> and determine if it is an array, vector, untyped list or slice with a known size, otherwise it is an error.</li>
<li>A regular argument <em>splat</em> will be expanded into as many slots as its length, this may expand into vaarg arguments.</li>
<li>In the vaarg slot, <em>splatting</em> a slice will <em>forward</em> it.</li>
<li>In the vaarg slot, <em>splatting</em> an array, vector or untyped list will expand its elements as if they were provided as arguments.</li>
<li>A named argument may never appear more than once.</li>
<li>The vaarg slot may never be accessed using named arguments.</li>
</ol><h4>Varargs</h4><p>For varargs, a <code>bool</code> or <em>any integer</em> smaller than what the C ABI specifies for the c <code>int</code> type is cast to <code>int</code>. Any
float smaller than a double is cast to <code>double</code>. Compile time floats will be cast to double. Compile time integers will
be cast to c <code>int</code> type.</p><h2 id="customizing-a-project-statements">Statements</h2><pre><code>stmt               ::= compound_stmt | non_compound_stmt
non_compound_stmt  ::= assert_stmt | if_stmt | while_stmt | do_stmt | foreach_stmt | foreach_r_stmt 
                       | for_stmt | return_stmt | break_stmt | continue_stmt | var_stmt 
                       | declaration_stmt | defer_stmt | nextcase_stmt | asm_block_stmt
                       | ct_echo_stmt | ct_error_stmt | ct_assert_stmt | ct_if_stmt | ct_switch_stmt 
                       | ct_for_stmt | ct_foreach_stmt | expr_stmt</code></pre><h3 id="customizing-a-project-statements-asm-block-statement">Asm block statement</h3><p>An asm block is either a string expression or a brace enclosed list of asm statements.</p><pre><code>asm_block_stmt      ::= "asm" ("(" constant_expr ")" | "{" asm_stmt* "}")
asm_stmt            ::= asm_instr asm_exprs? ";"
asm_instr           ::= ("int" | IDENTIFIER) ("." IDENTIFIER)
asm_expr            ::= CT_IDENT | CT_CONST_IDENT | "&amp;"? IDENTIFIER | CONST_IDENT | FLOAT_LITERAL
                        | INTEGER | "(" expr ")" | "[" asm_addr "]"
asm_addr            ::= asm_expr (additive_op asm_expr asm_addr_trail?)?
asm_addr_trail      ::= "*" INTEGER (additive_op INTEGER)? | (shift_op | additive_op) INTEGER</code></pre><p>TODO</p><h3 id="customizing-a-project-statements-assert-statement">Assert statement</h3><p>The assert statement will evaluate the expression and call the panic function if it evaluates
to false.</p><pre><code>assert_stmt        ::= "assert" "(" expr ("," assert_message)? ")" ";"
assert_message     ::= constant_expr ("," expr)*</code></pre><h4>Conditional inclusion</h4><p><code>assert</code> statements are only included in “safe” builds. They may turn into <strong>assume directives</strong> for
the compiler on “fast” builds.</p><h4>Assert message</h4><p>The assert message is optional. It can be followed by an arbitrary number of expressions, in which case
the message is understood to be a format string, and the following arguments are passed as values to the
format function.</p><p>The assert message must be a compile time constant. There are no restriction on the format argument expressions.</p><h4>Panic function</h4><p>If the assert message has no format arguments or no assert message is included,
then the regular panic function is called. If it has format arguments then <code>panicf</code> is called instead.</p><p>In the case the <code>panicf</code> function does not exist (for example, compiling without the standard library),
then the format and the format arguments will be ignored and the <code>assert</code> will be treated
as if no assert message was available.</p><h3 id="customizing-a-project-statements-break-statement">Break statement</h3><p>A break statement exits a <code>while</code>, <code>for</code>, <code>do</code>, <code>foreach</code> or <code>switch</code> scope. A labelled break
may also exit a labelled <code>if</code>.</p><pre><code>break_stmt         ::= "break" label? ";"</code></pre><h4>Break labels</h4><p>If a break has a label, then it will instead exit an outer scope with the label.</p><h4>Unreachable code</h4><p>Any statement following break in the same scope is considered unreachable.</p><h3 id="customizing-a-project-statements-compile-time-echo-statement">Compile time echo statement</h3><p>During parsing, the compiler will output the text in the statement when it is semantically checked.
The statement will be turned into a NOP statement after checking.</p><pre><code>ct_echo_stmt       ::= "$echo" constant_expr ";"</code></pre><h4>The message</h4><p>The message must be a compile time constant string.</p><h3 id="customizing-a-project-statements-compile-time-assert-statement">Compile time assert statement</h3><p>During parsing, the compiler will check the compile time expression
and create a compile time error with the optional message. After
evaluation, the <code>$assert</code> becomes a <strong>NOP</strong> statement.</p><pre><code>ct_assert_stmt     ::= "$assert" constant_expr (":" constant_expr) ";"</code></pre><h4>Evaluated expression</h4><p>The checked expression must evaluate to a boolean compile time constant.</p><h4>Error message</h4><p>The second parameter, which is optional, must evaluate to a constant string.</p><h3 id="customizing-a-project-statements-compile-time-error-statement">Compile time error statement</h3><p>During parsing, when semantically checked this statement will output
a compile time error with the message given.</p><pre><code>ct_error_stmt      ::= "$error" constant_expr ";"</code></pre><h4>Error message</h4><p>The parameter must evaluate to a constant string.</p><h3 id="customizing-a-project-statements-compile-time-if-statement">Compile time if statement</h3><p>If the cond expression is true, the then-branch is processed by the compiler. If it
evaluates to false, the else-branch is processed if it exists.</p><pre><code>ct_if_stmt         ::= "$if" constant_expr ":" stmt* ("$else" stmt*)? "$endif"</code></pre><h4>Cond expression</h4><p>The cond expression must be possible to evaluate to true or false at compile time.</p><h4>Scopes</h4><p>The “then” and “else” branches will add a compile time scope that is exited when reaching <code>$endif</code>.
It adds no runtime scope.</p><h4>Evaluation</h4><p>Statements in the branch not picked will not be semantically checked.</p><h3 id="customizing-a-project-statements-compile-time-switch-statement">Compile time switch statement</h3><pre><code>ct_switch_stmt     ::= "$switch" ("(" ct_expr_or_type ")")? ct_case_stmt+ "$endswitch"
ct_case_stmt       ::= ("$default" | "$case" ct_expr_or_type) ":" stmt*</code></pre><h4>No cond expression switch</h4><p>If the cond expression is missing, evaluation will go through each case until one case expression
evaluates to true.</p><h4>Type expressions</h4><p>If a cond expression is a type, then all case statement expressions must be types as well.</p><h4>Ranged cases</h4><p>Compile time switch does not support ranged cases.</p><h4>Fallthrough</h4><p>If a case clause has no statements, then when executing the case, rather than exiting the switch,
the next case clause immediately following it will be used. If that one should also be missing statements,
the procedure will be repeated until a case clause with statements is encountered,
or the end of the switch is reached.</p><h4>Break and nextcase</h4><p>Compile time switches do not support <code>break</code> nor <code>nextcase</code>.</p><h4>Evaluation of statements</h4><p>Only the case which is first matched has its statements processed by the compiler. All other statements
are ignored and will not be semantically checked.</p><h3 id="customizing-a-project-statements-continue-statement">Continue statement</h3><p>A continue statement jumps to the cond expression of a <code>while</code>, <code>for</code>, <code>do</code> or <code>foreach</code></p><pre><code>continue_stmt      ::= "continue" label? ";"</code></pre><h4>Continue labels</h4><p>If a <code>continue</code> has a label, then it will jump to the cond of the while/for/do in the outer scope
with the corresponding label.</p><h4>Unreachable code</h4><p>Any statement following <code>continue</code> in the same scope is considered unreachable.</p><h3 id="customizing-a-project-statements-declaration-statement">Declaration statement</h3><p>A declaration statement adds a new runtime or compile time variable to the current scope. It is available after the
declaration statement.</p><pre><code>declaration_stmt   ::= const_declaration | local_decl_storage? optional_type decls_after_type ";"
local_decl_storage ::= "tlocal" | "static"
decls_after_type   ::= local_decl_after_type ("," local_decl_after_type)*
decl_after_type    ::= CT_IDENT ("=" constant_expr)? | IDENTIFIER opt_attributes ("=" expr)?</code></pre><h4>Thread local storage</h4><p>Using <code>tlocal</code> allocates the runtime variable as a <strong>thread local</strong> variable. In effect this is the same as declaring
the variable as a global <code>tlocal</code> variable, but the visibility is limited to the function. <code>tlocal</code> may not be
combined with <code>static</code>.</p><p>The initializer for a <code>tlocal</code> variable must be a valid global init expression.</p><h4>Static storage</h4><p>Using <code>static</code> allocates the runtime variable as a function <strong>global</strong> variable. In effect this is the same as declaring
a global, but visibility is limited to the function. <code>static</code> may not be combined with <code>tlocal</code>.</p><p>The initializer for a <code>static</code> variable must be a valid global init expression.</p><h4>Scopes</h4><p>Runtime variables are added to the runtime scope, compile time variables to the compile time scope. See <strong>var statements
</strong>.</p><h4>Multiple declarations</h4><p>If more than one variable is declared, no init expressions are allowed for any of the variables.</p><h4>No init expression</h4><p>If no init expression is provided, the variable is <strong>zero initialized</strong>.</p><h4>Opt-out of zero initialization</h4><p>Using the @noinit attribute opts out of <strong>zero initialization</strong>.</p><h4>Self referencing initialization</h4><p>An init expression may refer to the <strong>address</strong> of the same variable that is declared, but not the <strong>value</strong> of the
variable.</p><p>Example:</p><pre><code class="lang-c">void* a = &amp;a;  <span class="comment">// Valid</span>
int a = a + <span class="number">1</span>; <span class="comment">// Invalid</span></code></pre><h3 id="customizing-a-project-statements-defer-statement">Defer statement</h3><p>The defer statements are executed at (runtime) scope exit, whether through <code>return</code>, <code>break</code>, <code>continue</code> or rethrow.</p><pre><code>defer_stmt         ::= "defer" ("try" | "catch")? stmt</code></pre><h4>Defer in defer</h4><p>The defer body (statement) may not be a defer statement. However, if the body is a compound statement then
this may have any number of defer statements.</p><h4>Static and tlocal variables in defer</h4><p>Static and tlocal variables are allowed in a defer statement. Only a single variable is instantiated regardless of
the number of inlining locations.</p><h4>Defer and return</h4><p>If the <code>return</code> has an expression, then it is evaluated before the defer statements (due to exit from the current
function scope),
are executed.</p><p>Example:</p><pre><code class="lang-c">int a = <span class="number">0</span>;
defer a++;
return a;
<span class="comment">// This is equivalent to</span>
int a = <span class="number">0</span>;
int temp = a;
a++;
return temp;</code></pre><h4>Defer and jump statements</h4><p>A defer body may not contain a <code>break</code>, <code>continue</code>, <code>return</code> or rethrow that would exit the statement.</p><h4>Defer execution</h4><p>Defer statements are executed in the reverse order of their declaration, starting from the last declared
defer statement.</p><h4>Defer try</h4><p>A <code>defer try</code> type of defer will only execute if the scope is left through normal fallthrough, <code>break</code>,
<code>continue</code> or a <code>return</code> with a result.</p><p>It will not execute if the exit is through a rethrow or a <code>return</code> with an optional value.</p><h4>Defer catch</h4><p>A <code>defer catch</code> type of defer will only execute if the scope is left through a rethrow or a <code>return</code> with an optional
value</p><p>It will not execute if the exit is a normal fallthrough, <code>break</code>, <code>continue</code> or a <code>return</code> with a result.</p><h4>Non-regular returns - longjmp, panic and other errors</h4><p>Defers will not execute when doing <code>longjmp</code> terminating through a <code>panic</code> or other error. They
are only invoked on regular scope exits.</p><h3 id="customizing-a-project-statements-expr-statement">Expr statement</h3><p>An expression statement evaluates an expression.</p><pre><code>expr_stmt          ::= expr ";"</code></pre><h4>No discard</h4><p>If the expression is a function or macro call either returning an optional <em>or</em> annotated <code>@nodiscard</code>, then
the expression is a compile time error. A function or macro returning an optional can use the <code>@maydiscard</code>
attribute to suppress this error.</p><h3 id="customizing-a-project-statements-if-statement">If statement</h3><p>An if statement will evaluate the cond expression, then execute the first statement (the “then clause”) in the if-body
if it evaluates to “true”, otherwise execute the else clause. If no else clause exists, then the
next statement is executed.</p><pre><code>if_stmt            ::= "if" (label ":")? "(" cond_expr ")" if_body
if_body            ::= non_compound_stmt | compound_stmt else_clause? | "{" switch_body "}"
else_clause        ::= "else" (if_stmt | compound_stmt)</code></pre><h4>Scopes</h4><p>Both the “then” clause and the else clause open new scopes, even if they are non-compound statements.
The cond expression scope is valid until the exit of the entire statement, so any declarations in the
cond expression are available both in then and else clauses. Declarations in the “then” clause is not available
in the else clause and vice versa.</p><h4>Special parsing of the “then” clause</h4><p>If the then-clause isn’t a compound statement, then it must follow on the same row as the cond expression.
It may not appear on a consecutive row.</p><h4>Break</h4><p>It is possible to use labelled break to break out of an if statement. Note that an unlabelled <code>break</code> may not
be used.</p><h4>If-try</h4><p>The cond expression may be a try-unwrap chain. In this case, the unwrapped variables are
scoped to the “then” clause only.</p><h4>If-catch</h4><p>The cond expression may be a catch-unwrap. The unwrap is scoped to the “then” clause only.
If one or more variables are in the catch, then the “else” clause have these variables
implicitly unwrapped.</p><p>Example:</p><pre><code>int! a = foo();
int! b = foo();
if (catch a, b)
{
    // Do something
}
else
{
    int x = a + b; // Valid, a and b are implicitly unwrapped.
}</code></pre><h4>If-catch implicit unwrap</h4><p>If an if-catch’s “then”-clause will jump out of the outer scope in all code paths and
the catch is on one or more variables, then this variable(s) will be implicitly unwrapped in the outer scope
after the if-statement.</p><p>Example:</p><pre><code>int! a = foo();
if (catch a)
{
  return;
}  
int x = a; // Valid, a is implicitly unwrapped.</code></pre><h3 id="customizing-a-project-statements-nextcase-statement">Nextcase statement</h3><p>Nextcase will jump to another <code>switch</code> case.</p><pre><code>nextcase_stmt      ::= "nextcase" ((label ":")? (expr | "default"))? ";"</code></pre><h4>Labels</h4><p>When a nextcase has a label, the jump is to the switch in an outer scope with the corresponding label.</p><h4>No expression jumps</h4><p>A <code>nextcase</code> without any expression jumps to the next case clause in the current switch. It is not possible
to use no expression <code>nextcase</code> with labels.</p><h4>Jumps to default</h4><p>Using <code>default</code> jumps to the default clause of a switch.</p><h4>Missing case</h4><p>If the switch has constant case values, and the nextcase expression is constant, then the value of
the expression must match a case clause. Not matching a case is a compile time error.</p><p>If one or more cases are non-constant and/or the nextcase expression is non-constant, then no compile time check is
made.</p><h4>Variable expression</h4><p>If the nextcase has a non-constant expression, or the cases are not all constant, then first the nextcase expression
is evaluated. Next, execution will proceed <em>as if</em> the switch was invoked again, but with the nextcase expression as the
switch cond expression. See <strong>switch statement</strong>.</p><p>If the switch does not have a cond expression, nextcase with an expression is not allowed.</p><h4>Unreachable code</h4><p>Any statement in the same scope after a <code>nextcase</code> are considered <strong>unreachable</strong>.</p><h3 id="customizing-a-project-statements-switch-statement">Switch statement</h3><pre><code>switch_stmt        ::= "switch" (label ":")? ("(" cond_expr ")")? switch body
switch_body        ::= "{" case_clause* "}"
case_clause        ::= default_stmt | case_stmt
default_stmt       ::= "default" ":" stmt*
case_stmt          ::= "case" label? expr (".." expr)? ":" stmt*</code></pre><h4>Regular switch</h4><p>If the cond expression exists and all case statements have constant expression, then first the
cond expression is evaluated, next the case corresponding to the expression’s value will be jumped to
and the statement will be executed. After reaching the end of the statements and a new case clause <em>or</em> the
end of the switch body, the execution will jump to the first statement after the switch.</p><h4>If-switch</h4><p>If the cond expression is missing or the case statements are non-constant expressions, then each case clause will
be evaluated in order after the cond expression has been evaluated (if it exists):</p><ol>
<li>If a cond expression exists, calculate the case expression and execute the case if it is matching the
cond expression. A default statement has no expression and will always be considered matching the cond expression
reached.</li>
<li>If no con expression exists, calculate the case expression and execute the case if the expression evaluates to
“true” when implicitly converted to boolean. A default statement will always be considered having the “true” result.</li>
</ol><h4>Any-switch</h4><p>If the cond expression is an <code>any</code> type, the switch is handled as if switching was done over the <code>type</code>
field of the <code>any</code>. This field has the type of <a href="#typeid-type">typeid</a>, and the cases follows the rules
for <a href="#switching-over-typeid">switching over typeid</a>.</p><p>If the cond expression is a variable, then this variable is implicitly converted to a pointer with
the pointee type given by the case statement.</p><p>Example:</p><pre><code class="lang-c">any a = abc();
switch (a)
{
    case int:
        int b = *a;   <span class="comment">// a is int*</span>
    case float:
        float z = *a; <span class="comment">// a is float*</span>
    case Bar:
        Bar f = *a;   <span class="comment">// a is Bar*</span>
    default:
        <span class="comment">// a is not unwrapped</span>
}</code></pre><h4>Ranged cases</h4><p>Cases may be ranged. The start and end of the range must both be constant integer values. The start must
be less or equal to the end value. Using non-integers or non-constant values is a compile time error.</p><h4>Fallthrough</h4><p>If a case clause has no statements, then when executing the case, rather than exiting the switch, the next case clause
immediately following it will be executed. If that one should also be missing statement, the procedure
will be repeated until a case clause with statements is encountered (and executed), or the end of the switch is reached.</p><h4>Exhaustive switch</h4><p>If a switch case has a default clause <em>or</em> it is switching over an enum and there exists a case for each enum value
then the switch is exhaustive.</p><h4>Break</h4><p>If an unlabelled break, or a break with the switch’s label is encountered,
then the execution will jump out of the switch and proceed directly after the end of the switch body.</p><h4>Unreachable code</h4><p>If a switch is exhaustive and all case clauses end with a jump instruction, containing no break statement out
of the current switch, then the code directly following the switch will be considered <strong>unreachable</strong>.</p><h4>Switching over typeid</h4><p>If the switch cond expression is a typeid, then case declarations may use only the type name after the case,
which will be interpreted as having an implicit <code>.typeid</code>. Example: <code>case int:</code> will be interpreted as if
written <code>case int.typeid</code>.</p><h4>Nextcase without expression</h4><p>Without a value <code>nextcase</code> will jump to the beginning of the next case clause. It is not allowed to
put <code>nextcase</code> without an expression if there are no following case clauses.</p><h4>Nextcase with expression</h4><p>Nextcase with an expression will evaluate the expression and then jump <em>as if</em> the switch was entered with
the cond expression corresponding to the value of the nextcase expression. Nextcase with an expression cannot
be used on a switch without a cond expression.</p><h4>Do statement</h4><p>The do statement first evaluates its body (inner statement), then evaluates the cond expression.
If the cond expression evaluates to true, jumps back into the body and repeats the process.</p><pre><code>do_stmt            ::= "do" label? compound_stmt ("while" "(" cond_expr ")")? ";"</code></pre><h4>Unreachable code</h4><p>The statement after a <code>do</code> is considered unreachable if the cond expression cannot ever be false
and there is no <code>break</code> out of the do.</p><h4>Break</h4><p><code>break</code> will exit the do with execution continuing on the following statement.</p><h4>Continue</h4><p><code>continue</code> will jump directly to the evaluation of the cond, as if the end of the statement had been reached.</p><h4>Do block</h4><p>If no <code>while</code> part exists, it will only execute the block once, as if it ended with <code>while (false)</code>, this is
called a “do block”</p><h3 id="customizing-a-project-statements-for-statement">For statement</h3><p>The <code>for</code> statement will perform the (optional) init expression. The cond expression will then be tested. If
it evaluates to <code>true</code> then the body will execute, followed by the incr expression. After execution will
jump back to the cond expression and execution will repeat until the cond expression evaluates to <code>false</code>.</p><pre><code>for_stmt           ::= "for" label? "(" init_expr ";" cond_expr? ";" incr_expr ")" stmt
init_expr          ::= decl_expr_list?
incr_expr          ::= expr_list?</code></pre><h4>Init expression</h4><p>The init expression is only executed once before the rest of the for loop is executed.
Any declarations in the init expression will be in scope until the for loop exits.</p><p>The init expression may optionally be omitted.</p><h4>Incr expression</h4><p>The incr expression is evaluated before evaluating the cond expr every time except for the first one.</p><p>The incr expression may optionally be omitted.</p><h4>Cond expression</h4><p>The cond expression is evaluated every loop. Any declaration in the cond expression is scoped to the
current loop, i.e. it will be reinitialized at the start of every loop.</p><p>The cond expression may optionally be omitted. This is equivalent to setting the cond expression to
always return <code>true</code>.</p><h4>Unreachable code</h4><p>The statement after a <code>for</code> is considered unreachable if the cond expression cannot ever be false, or is
omitted and there is no <code>break</code> out of the loop.</p><h4>Break</h4><p><code>break</code> will exit the <code>for</code> with execution continuing on the following statement after the <code>for</code>.</p><h4>Continue</h4><p><code>continue</code> will jump directly to the evaluation of the cond, as if the end of the statement had been reached.</p><h4>Equivalence of <code>while</code> and <code>for</code></h4><p>A <code>while</code> loop is functionally equivalent to a <code>for</code> loop without init and incr expressions.</p><h3 id="customizing-a-project-statements-foreach-and-foreach_r-statements">Foreach and foreach_r statements</h3><p>The <code>foreach</code> statement will loop over a sequence of values. The <code>foreach_r</code> is equivalent to
<code>foreach</code> but the order of traversal is reversed.
<code>foreach</code> starts with element <code>0</code> and proceeds step by step to element <code>len - 1</code>.
<code>foreach_r</code> starts starts with element <code>len - 1</code> and proceeds step by step to element <code>0</code>.</p><pre><code>foreach_stmt       ::= "foreach" label? "(" foreach_vars ":" expr ")" stmt
foreach_r_stmt     ::= "foreach_r" label? "(" foreach_vars ":" expr ")" stmt
foreach_vars       ::= (foreach_index ",")? foreach_var
foreach_var        ::= type? "&amp;"? IDENTIFIER</code></pre><h4>Break</h4><p><code>break</code> will exit the foreach statement with execution continuing on the following statement after.</p><h4>Continue</h4><p><code>continue</code> will cause the next iteration to commence, as if the end of the statement had been reached.</p><h4>Iteration by value or reference</h4><p>Normally iteration are by value. Each element is copied into the foreach variable. If <code>&amp;</code>
is added before the variable name, the elements will be retrieved by reference instead, and consequently
the type of the variable will be a pointer to the element type instead.</p><h4>Foreach variable</h4><p>The foreach variable may omit the type. In this case the type is inferred. If the type differs from the element
type, then an implicit conversion will be attempted. Failing this is a compile time error.</p><h4>Foreach index</h4><p>If a variable name is added before the foreach variable, then this variable will receive the index of the element.
For <code>foreach_r</code> this mean that the first value of the index will be <code>len - 1</code>.</p><p>The index type defaults to <code>usz</code>.</p><p>If an optional type is added to the index, the index will be converted to this type. The type must be an
integer type. The conversion happens as if the conversion was a direct cast. If the actual index value
would exceed the maximum representable value of the type, this does not affect the actual iteration, but
may cause the index value to take on an incorrect value due to the cast.</p><p>For example, if the optional index type is <code>char</code> and the actual index is <code>256</code>, then the index value would show <code>0</code>
as <code>(char)256</code> evaluates to zero.</p><p>Modifying the index variable will not affect the foreach iteration.</p><h4>Foreach support</h4><p>Foreach is natively supported for any slice, array, pointer to an array, vector and pointer to a vector.
These types support both iteration by value and reference.</p><p>In addition, a type with <strong>operator overload</strong> for <code>len</code> and <code>[]</code> will support iteration by value,
and a type with <strong>operator overload</strong> for <code>len</code> and <code>&amp;[]</code> will support iteration by reference.</p><h3 id="customizing-a-project-statements-return-statement">Return statement</h3><p>The return statement evaluates its expression (if present) and returns the result.</p><pre><code>return_stmt        ::= "return" expr? ";"</code></pre><h4>Jumps in return statements</h4><p>If the expression should in itself cause an implicit return, for example due to the rethrow operator <code>!</code>, then this
jump will happen before the return.</p><p>An example:</p><pre><code>return foo()!;
// is equivalent to:
int temp = foo()!;
return temp;</code></pre><h4>Return from expression blocks</h4><p>A <code>return</code> from an expression block only returns out of the expression block, it never returns from the
expression block’s enclosing scope.</p><h4>Empty returns</h4><p>An empty return is equivalent to a return with a void type. Consequently constructs like <code>foo(); return;</code>
and <code>return (void)foo();</code>
are equivalent.</p><h4>Unreachable code</h4><p>Any statement directly following a return in the same scope are considered unreachable.</p><h3 id="customizing-a-project-statements-while-statement">While statement</h3><p>The while statement evaluates the cond expression and executes the statement if it evaluates to true.
After this the cond expression is evaluated again and the process is repeated until cond expression returns false.</p><pre><code>while_stmt         ::= "while" label? "(" cond_expr ")" stmt</code></pre><h4>Unreachable code</h4><p>The statement after a while is considered unreachable if the cond expression cannot ever be false
and there is no <code>break</code> out of the while.</p><h4>Break</h4><p><code>break</code> will exit the while with execution continuing on the following statement.</p><h4>Continue</h4><p><code>continue</code> will jump directly to the evaluation of the cond, as if the end of the statement had been reached.</p><h3 id="customizing-a-project-statements-var-statement">Var statement</h3><p>A var statement declares a variable with inferred type, or a compile time type variable. It can be used both
for runtime and compile time variables. The use for runtime variables is limited to macros.</p><pre><code>var_stmt           ::= "var" IDENTIFIER | CT_IDENT | CT_TYPE_IDENT ("=" expr)? ";"</code></pre><h4>Inferring type</h4><p>In the case of a runtime variable, the type is inferred from the expression. Not providing an expression
is a compile time error. The expression must resolve to a runtime type.</p><p>For compile time variables, the expression is optional. The expression may resolve to a runtime or compile time type.</p><h4>Scope</h4><p>Runtime variables will follow the runtime scopes, identical to behaviour in a declaration statement. The compile
time variables will follow the compile time scopes which are delimited by scoping compile time
statements (<code>$if</code>, <code>$switch</code>,
<code>$foreach</code> and <code>$for</code>).</p><h2 id="customizing-a-project-attributes">Attributes</h2><p>Attributes are modifiers attached to modules, variables, type declarations etc.</p><table>
<thead>
<tr>
<th>name</th>
<th>used with</th>
</tr>
</thead>
<tbody>
<tr>
<td>@align</td>
<td>fn, const, variables, user-defined types, struct member</td>
</tr>
<tr>
<td>@benchmark</td>
<td>module, fn</td>
</tr>
<tr>
<td>@bigendian</td>
<td>bitstruct only</td>
</tr>
<tr>
<td>@builtin</td>
<td>macro, fn, global, constant</td>
</tr>
<tr>
<td>@callconv</td>
<td>fn, call</td>
</tr>
<tr>
<td>@deprecated</td>
<td>fn, macro, interface, variables, constants, user-defined types, struct member</td>
</tr>
<tr>
<td>@dynamic</td>
<td>fn</td>
</tr>
<tr>
<td>@export</td>
<td>fn, globals, constants, struct, union, enum, fault</td>
</tr>
<tr>
<td>@extern</td>
<td>fn, globals, constants, user-defined types</td>
</tr>
<tr>
<td>@if</td>
<td>all except local variables and calls</td>
</tr>
<tr>
<td>@inline</td>
<td>fn, call</td>
</tr>
<tr>
<td>@interface</td>
<td>fn</td>
</tr>
<tr>
<td>@littleendian</td>
<td>bitstruct only</td>
</tr>
<tr>
<td>@local</td>
<td>module, fn, macro, globals, constants, user-defined types, attributes and aliases</td>
</tr>
<tr>
<td>@maydiscard</td>
<td>fn, macro</td>
</tr>
<tr>
<td>@naked</td>
<td>fn</td>
</tr>
<tr>
<td>@nodiscard</td>
<td>fn, macro</td>
</tr>
<tr>
<td>@noinit</td>
<td>variables</td>
</tr>
<tr>
<td>@noinline</td>
<td>fn, call</td>
</tr>
<tr>
<td>@noreturn</td>
<td>fn, macro</td>
</tr>
<tr>
<td>@nostrip</td>
<td>fn, globals, constants, struct, union, enum, fault</td>
</tr>
<tr>
<td>@obfuscate</td>
<td>enum, fault</td>
</tr>
<tr>
<td>@operator</td>
<td>fn, macro</td>
</tr>
<tr>
<td>@optional</td>
<td>interface methods</td>
</tr>
<tr>
<td>@overlap</td>
<td>bitstruct only</td>
</tr>
<tr>
<td>@packed</td>
<td>struct, union</td>
</tr>
<tr>
<td>@priority</td>
<td>initializer/finalizer</td>
</tr>
<tr>
<td>@private</td>
<td>module, fn, macro, globals, constants, user-defined types, attributes and aliases</td>
</tr>
<tr>
<td>@public</td>
<td>module, fn, macro, globals, constants, user-defined types, attributes and aliases</td>
</tr>
<tr>
<td>@pure</td>
<td>call</td>
</tr>
<tr>
<td>@reflect</td>
<td>fn, globals, constants, user-defined types</td>
</tr>
<tr>
<td>@section</td>
<td>fn, globals, constants</td>
</tr>
<tr>
<td>@test</td>
<td>module, fn</td>
</tr>
<tr>
<td>@unused</td>
<td>all except call and initializer/finalizers</td>
</tr>
<tr>
<td>@used</td>
<td>all except call and initializer/finalizers</td>
</tr>
<tr>
<td>@weak</td>
<td>fn, globals, constants</td>
</tr>
<tr>
<td>@winmain</td>
<td>fn</td>
</tr>
</tbody>
</table><h4>@deprecated</h4><p>Takes an optional constant string. 
If the node is in use, print the deprecation and add the optional string if present.</p><h4>@optional</h4><p>Marks an <em>interface</em> method as optional, and so does not need to be implemented by
a conforming type.</p><h4>@winmain</h4><p>Marks a <code>main</code> function as a win32 winmain function, which is the entrypoint for a windowed 
application on Windows. This allows the main function to take a different set of 
arguments than usual.</p><h4>@callconv</h4><p><code>@callconv</code> can
 be used with a function or a call. It takes a constant string which is 
either “veccall”, “stdcall” or “cdecl”. If more than one <code>@callconv</code> 
is applied to a function or call, the last one takes precedence.</p><h3 id="customizing-a-project-attributes-user-defined-attributes">User defined attributes</h3><p>User defined attributes group a list of attributes.</p><pre><code>attribute_decl     ::= "def" AT_TYPE_IDENT ("(" parameters ")")? attribute* "=" "{" attribute* "}" ";"</code></pre><h4>Empty list of attributes</h4><p>The list of attributes may be empty.</p><h4>Parameter arguments</h4><p>Arguments given to user defined attributes will be passed on to the attributes in the list.</p><h4>Expansion</h4><p>When a user defined attribute is encountered, its list of attributes is
copied and appended instead of the user defined attribute. Any argument passed to 
the attribute is evaluated and passed as a constant by the name of the parameter
to the evaluation of the attribute parameters in the list.</p><h4>Nesting</h4><p>A user defined attribute can contain other user defined attributes. The definition
may not be cyclic.</p><h2 id="customizing-a-project-methods">Methods</h2><h4>Operator overloading</h4><p><code>@operator</code> overloads may only be added to user defined types (distinct, unions, struct, enum and fault).</p><h5>Indexing operator ([])</h5><p>This requires a return type and a method parameter, which is the index.</p><h5>Reference indexing operator (&amp;[])</h5><p>This requires a return type and a method parameter, which is the index. If <code>[]</code> is implemented,
it should return a pointer to <code>[]</code>.</p><h5>Assigning index operator (=[])</h5><p>This has a void return type, and index should match that of <code>[]</code> and <code>&amp;[]</code>. Value should match that 
of <code>[]</code> and be the pointee of the result of <code>&amp;[]</code>.</p><h5>Len operator (len)</h5><p>This must have an integer return type.</p><h4>Dynamic methods</h4><p><code>@dynamic</code> may be used on methods for any type except <code>any</code> and interfaces.</p><h2 id="customizing-a-project-modules">Modules</h2><p>Module paths are hierarchal, with each sub-path appended with ‘::’ + the name:</p><pre><code>path               ::= PATH_SEGMENT ("::" PATH_SEGMENT)</code></pre><p>Each module declaration starts its own <strong>module section</strong>. All imports and all <code>@local</code> declarations
are only visible in the current <strong>module section</strong>.</p><pre><code>module_section     ::= "module" path opt_generic_params? attributes? ";"
generic_param      ::= TYPE_IDENT | CONST_IDENT
opt_generic_params ::= "(&lt;" generic_param ("," generic_param)* "&gt;)"</code></pre><p>Any visibility attribute defined in a <strong>module section</strong> will be the default visibility in all
declarations in the section.</p><p>If the <code>@benchmark</code> attribute is applied to the <strong>module section</strong> then all function declarations
will implicitly have the <code>@benchmark</code> attribute.</p><p>If the <code>@test</code> attribute is applied to the <strong>module section</strong> then all function declarations
will implicitly have the <code>@test</code> attribute.</p><hr><p>title: Thank You
description: Thank You
sidebar:</p><pre><code>order: 1000</code></pre><hr><h2 id="customizing-a-project-thank-you">Thank You</h2><ul>
<li>A huge “thank you” goes out to all contributors and sponsors.</li>
<li>A special mention to <a href="https://huly.io/">Huly® Platform™</a> for sponsoring $100/month.</li>
</ul><h2 id="customizing-a-project-special-mentions">Special Mentions</h2><ul>
<li>Bas van der Berg the Author of <a href="http://www.c2lang.org/">C2</a></li>
<li>Jon Goodwin the Author of <a href="http://cone.jondgoodwin.com/">Cone</a></li>
<li>Andrey Penechko the Author of <a href="https://github.com/MrSmith33/vox">Vox</a>.</li>
</ul></div>
  </div>



</body></html>